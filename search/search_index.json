{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#welcome-to-the-eda-hackathon-at-kpn-mini-srexperts-2026","title":"Welcome to the EDA Hackathon at KPN Mini SReXperts 2026","text":"<p>Welcome to this Hackathon event focusing on Nokia's Data Center Fabric product portfolio. We hope this set of activities will be challenging and informative no matter what experience level you are.</p>"},{"location":"index.html#open-to-all-and-something-for-everyone","title":"Open to all and something for everyone","text":"<p>Whether you're a relative novice to Nokia's products, or a seasoned expert, there is something in this event for you!  All you will need is your trusty laptop, an afternoon of focus and possibly some coffee (supplied!) and you should find something to benefit both you and your organizations.</p>"},{"location":"index.html#getting-started","title":"Getting started","text":"<p>This page is your starting point into the event, it should get you familiar with the lab environment provided by Nokia, and provide an overview of the suggested sample activities.</p> <p>Please read this page all the way through before attempting any of the activities.</p> <p>During this session you will work in groups (or alone if you prefer) on any projects that you are inspired to tackle or on one of the pre-provided activities of varying difficulty.</p> <p>As long as you have a laptop with the ability to SSH and a web browser, we have example activities and a datacenter fabric lab topology to help you progress if you don\u2019t have something specific already in mind.</p> <p>Need help, not a problem, pop your hand in the air and an eager expert will be there to guide you.</p>"},{"location":"index.html#lab-environment","title":"Lab Environment","text":"<p>For this event each (group of) participant(s) will receive their own dedicated cloud instance (VM) running a copy of the datacenter fabric lab topology.  You will see this called \"your VM\", \"your group's hackathon VM\", \"your group's event VM\", \"your instance\", \"your server\" and other similar phrases in the activities.  They all mean the same thing, your own dedicated cloud instance.</p> <p>If everything went according to plan, you should have received:</p> <ul> <li>The public IP address of your VM.</li> <li>SSH credentials to a public cloud instance dedicated to you.</li> <li>HTTPS URL's for this repository and access to a web based IDE in case you don't have one installed on your operating system.</li> </ul> <p>Warning</p> <p>The public cloud compute instances will be destroyed once the event is concluded.</p> Please make sure to backup any code, config, etc. offline (e.g. onto your laptop) if you'd like to keep it after the hackathon."},{"location":"index.html#ssh","title":"SSH","text":"<p>The simplest way to get going is to use your SSH client to connect to your group's event VM instance and work from there.  All tools and applications are pre-installed and you will have direct access to your entire network.</p> <p>SSH is also important if you want to directly access your network from your laptop but more on that later.</p> hostname <code>refer to the paper provided or the slide presented</code> username <code>refer to the paper provided or the slide presented</code> password <code>refer to the paper provided or the slide presented</code>"},{"location":"index.html#wifi","title":"WiFi","text":"<p>WiFi is important here.  Without it your event experience is going to be rather dull.  To connect to the hackathon event's WiFi, refer to the paper provided or the slide presented.</p>"},{"location":"index.html#topology","title":"Topology","text":"<p>When accessing your event VM instance you'll find that the Hackathon GitHub repository contains all of the documentation, examples, solutions and loads of other great stuff, has already been cloned for you.</p> <p>In this event, every group has their own complete data center fabric network at their disposal.  Your network comprises an 3 leafs, 2 spines, 2 borderleafs, and 5 linux hosts.  This network is already deployed and provisioned and is ready to go!</p> <p>Don't worry: This is your personal group network, you cannot impact any other groups.</p> Network Topology"},{"location":"index.html#accessing-topology-nodes","title":"Accessing Topology nodes","text":""},{"location":"index.html#from-your-groups-event-instance-vm","title":"From your group's event instance VM","text":"<p>To access the lab nodes from within the VM, users should identify the names of the deployed nodes using the <code>sudo containerlab inspect -a</code> command.  You will notice they all start with ``.  Your entire network is powered by ContainerLab.</p> <p>If you'd like to see the full list of devices, their hostnames and IP addresses in your network use the following command.</p> cmdoutput <pre><code>sudo containerlab inspect -a\n</code></pre> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                 Topology                 \u2502    Lab Name   \u2502     Name    \u2502             Kind/Image             \u2502  State  \u2502 IPv4/6 Address \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 kpn-mini-srx-hackathon/clab/kpn.clab.yml \u2502 kpn-hackathon \u2502 borderleaf1 \u2502 nokia_srlinux                      \u2502 running \u2502 10.128.1.36    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/nokia/srlinux:25.10.1      \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 borderleaf2 \u2502 nokia_srlinux                      \u2502 running \u2502 10.128.1.37    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/nokia/srlinux:25.10.1      \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 client1     \u2502 linux                              \u2502 running \u2502 10.128.1.38    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/srl-labs/network-multitool \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 client2     \u2502 linux                              \u2502 running \u2502 10.128.1.39    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/srl-labs/network-multitool \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 client3     \u2502 linux                              \u2502 running \u2502 10.128.1.40    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/srl-labs/network-multitool \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 client4     \u2502 linux                              \u2502 running \u2502 10.128.1.41    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/srl-labs/network-multitool \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 client5     \u2502 linux                              \u2502 running \u2502 10.128.1.42    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/srl-labs/network-multitool \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 leaf1       \u2502 nokia_srlinux                      \u2502 running \u2502 10.128.1.33    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/nokia/srlinux:25.10.1      \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 leaf2       \u2502 nokia_srlinux                      \u2502 running \u2502 10.128.1.34    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/nokia/srlinux:25.10.1      \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 leaf3       \u2502 nokia_srlinux                      \u2502 running \u2502 10.128.1.35    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/nokia/srlinux:25.10.1      \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 spine1      \u2502 nokia_srlinux                      \u2502 running \u2502 10.128.1.31    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/nokia/srlinux:25.10.1      \u2502         \u2502 N/A            \u2502\n\u2502                                          \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                          \u2502               \u2502 spine2      \u2502 nokia_srlinux                      \u2502 running \u2502 10.128.1.32    \u2502\n\u2502                                          \u2502               \u2502             \u2502 ghcr.io/nokia/srlinux:25.10.1      \u2502         \u2502 N/A            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Using the names from the above output, we can login to a node using the following command:</p> <p>For example, to access the <code>leaf1</code> node via ssh simply type:</p> <pre><code>ssh admin@leaf1\n</code></pre>"},{"location":"index.html#accessing-tools","title":"Accessing Tools","text":"<p>EDA, Grafana and Prometheus are accessible through the browser. You can find them at:</p> <ul> <li>EDA <code>https://&lt;your-IP&gt;:9443</code> </li> <li>Grafana <code>https://&lt;your-IP&gt;:9443/core/httpproxy/v1/grafana/dashboards</code> </li> <li>Prometheus <code>https://&lt;your-IP&gt;:9443/core/httpproxy/v1/prometheus/query</code> </li> </ul>"},{"location":"index.html#proposed-workflow","title":"Proposed workflow","text":"<p>You are free to explore and execute the activity at your own will, but for an EDA beginner, we suggest the following order of activities:</p> <ol> <li>Intro. This page will give you a high level introduction to the concepts used in EDA and get you familiar with the UI.</li> <li>SR Linux CLI. While this hackathon mainly focusses on EDA, we think it can still be useful to get introduced with SR Linux CLI. This activity teaches you the basics of our CLI. [~15 minutes]</li> <li>Declarative Intents. This activity dives deeper in the concept of declarative intents, an ideal way to start configuring things in EDA. [~15 minutes]</li> <li>EDA Query Language. Next to deploying intents and configurations on your network, it is very import to be able to verify the Network's state. EDA Query Language allows you to fetch network wide state information. [~30 minutes]</li> <li>Underlay/Overlay Networks. In this activity, you will deploy the underlay network in your fabric using the Fabrics resource. [~30 minutes]</li> <li>Telco-Cloud use-case. Here you will deploy a L3 EVPN service on which you will enable weighted ECMP to achieve equal load balancing on the edge links. [~60 minutes]</li> <li>References. Off course we want to keep the party going. If time allows, you can continue your learning with the <code>Reference</code> activities. Explore EDA concepts further, deploy more complicated service architectures or try out some more advanced use-cases.</li> </ol>"},{"location":"index.html#faq","title":"FAQ","text":""},{"location":"index.html#my-employersecurity-department-locked-down-my-laptop","title":"My employer/security department locked down my laptop","text":"<p>No worries, we have got you covered! Each instance is running a web-based VSCode code server, when accessing it at <code>https://&lt;my-IP&gt;:8000</code> should prompt you for a password (which is documented on the slide provided), and you should be able to access the topology through the terminal there.</p>"},{"location":"index.html#cloning-this-repository","title":"Cloning this repository","text":"<p>If you would like to work locally on your personal device you should clone this repository. This can be done using one of the following commands.</p> <p>HTTPS:</p> <pre><code>git clone https://github.com/lvaneeckh/kpn-mini-srx-hackathon.git\n</code></pre> <p>SSH:</p> <pre><code>git clone git@github.com:lvaneeckh/kpn-mini-srx-hackathon.git\n</code></pre> <p>GitHub CLI:</p> <pre><code>gh repo clone lvaneeckh/kpn-mini-srx-hackathon\n</code></pre>"},{"location":"index.html#useful-links","title":"Useful links","text":"<ul> <li>Network Developer Portal</li> <li>containerlab</li> </ul>"},{"location":"index.html#sr-linux","title":"SR Linux","text":"<ul> <li>Learn SR Linux</li> <li>YANG Browser</li> <li>gNxI Browser</li> </ul>"},{"location":"index.html#misc-toolssoftware","title":"Misc Tools/Software","text":""},{"location":"index.html#windows","title":"Windows","text":"<ul> <li>WSL environment</li> <li>Windows Terminal</li> <li>MobaXterm</li> <li>PuTTY Installer</li> <li>PuTTY Binary</li> </ul>"},{"location":"index.html#macos","title":"MacOS","text":"<ul> <li>Ghostty</li> <li>iTerm2</li> <li>Warp</li> <li>Hyper</li> <li>Terminal</li> </ul>"},{"location":"index.html#linux","title":"Linux","text":"<ul> <li>Ghostty</li> <li>Gnome Console</li> <li>Gnome Terminal</li> </ul>"},{"location":"index.html#ides","title":"IDEs","text":"<ul> <li>VS Code</li> <li>VS Code Web</li> <li>Sublime Text</li> <li>IntelliJ IDEA</li> <li>Eclipse</li> <li>PyCharm</li> </ul>"},{"location":"index.html#thanks-and-contributions","title":"Thanks and contributions","text":"<p>The event team would like to thank the following team members (in alphabetical order) for their contributions: Asad Arafat, Bhavish Khatri, Diogo Pinheiro, Gordon Gidofalvy, Guilherme Cale, Hans Thienpondt, James Cumming, Joao Machado, Kaelem Chandra, Korhan Kayhan, Laleh Kiani, Louis Van Eeckhoudt, Maged Makramalla, Miguel Redondo Ferrero, Roman Dodin, Saju Salahudeen, Samier Barguil, Shafkat Waheed, Shashi Sharma, Simon Tibbitts, Siva Sivakumar, Subba Konda, Sven Wisotzky, Thomas Hendriks, Tiago Amado. Zeno Dhaene, Tim Raphael and Vasileios Tekidis</p>"},{"location":"blog/index.html","title":"Blog","text":""},{"location":"eda/index.html","title":"EDA","text":"<p>Event Driven Automation (EDA) is the state of the art automation platform that completes Nokia's Data Center portfolio:</p> <p></p> <p>The design goals behind EDA were lofty and our ambitions were to create an infrastructure automation platform that addresses many challenges seen in the data center networking.</p> <p>In the configuration management domain EDA breaks the status quo of imperative, box-by-box configuration and leverages declarative and abstracted configuration model. In this mode a user declares what services or components they want to get deployed by providing its desired state in the form of an input that abstracts the complexities and implementation details.</p> <p>What is more important than the configuration intent - is the state the system is in. EDA takes a unique stance on state handling by coupling the configuration intent with its actual state and presenting it to the users. Having the state of the system aligned with the configuration inputs is crucial to operations.</p> <p>For operations domain EDA provides a unified, instant network-wide view of the running configuration and state via its EDA Query Language (EQL) capabilities. Having a way to create a query that runs over your whole network and provides instant and live results is table stakes for auditing, troubleshooting and state correlation.</p> <p>While the concept of declarative intents or blueprints is not new, in EDA made sure our users can extend and program almost every aspect of the platform. Do not agree how we modeled a DC fabric inputs? You have all the instruments to change it or even create your own implementation of it.</p> <p>And it would be a miss to keep EDA anchored to Nokia-only devices, that is why we ensured that EDA core is multivendor and users can leverage EDA superpowers with other vendors and their devices and APIs<sup>1</sup>.</p> <p>At this SReXplore event, you get a unique chance to spend a day with EDA by venturing into the exercises meticulously crafted by the EDA team and be the judge of its capabilities.</p>"},{"location":"eda/index.html#how-to-get-through-the-exercises","title":"How to get through the exercises?","text":"<p>As EDA is likely a new system for you, we recommend you to start from the beginner-level exercises in the order they are presented, unless you feel adventurous and want to hit the ground running.</p> <p>When inside a particular exercise, you should complete the tasks in the order they are presented. It might be tempting to skip ahead but a task may have a dependency on the previous step, so do tackle them in order.</p>"},{"location":"eda/index.html#access-details","title":"Access details","text":"<p>The lab environment you work on features a DC network topology with EDA already installed and a number of SR Linux datacenter switches already onboarded onto the platform. In particular, EDA manages five switches in total: <code>leaf11</code>, <code>leaf12</code>, <code>leaf13</code>, <code>spine11</code>, <code>spine12</code>.</p> EDA Managed nodes <p>As you go through the exercise, you might connect to the EDA UI, one of the switches or clients connected to them.</p> UILab serverSR Linux switchesClients <p>Most of the exercises can be completed by using EDA Web UI. The UI is accessible over <code>https://{your-group-id}.srexperts.net:9443</code>.</p> <p>The login credentials are available in the leaflet provided to you.</p> <p>The lab server runs the EDA platform and the whole lab topology. You will need to login to the topology server when you want to SSH further into one of the switches or clients.</p> <pre><code>ssh nokia@{your-group-id}.srexperts.net\n</code></pre> <p>You will find the server credentials in the leaflet provided to you.</p> <p>While you will mostly work with EDA UI, you would want to SSH into the switches to verify the configuration you made in EDA. To access the switches you first need to login to the lab server, and then from the server's shell you SSH further to the desired switch.</p> run from the lab server<pre><code>ssh admin@{switch-hostname}\n</code></pre> <p>The switch hostnames are:</p> <ul> <li><code>clab-srexperts-leaf11</code></li> <li><code>clab-srexperts-leaf12</code></li> <li><code>clab-srexperts-leaf13</code></li> <li><code>clab-srexperts-spine11</code></li> <li><code>clab-srexperts-spine12</code></li> </ul> <p>You will find the switch credentials in the leaflet provided to you.</p> <p>Clients are the Linux containers connected to the switches that you would need to configure to perform end-to-end ping tests between the hosts.</p> <p>To access the clients you first need to login to the lab server, and then from the server's shell you SSH further to the desired client.</p> run from the lab server<pre><code>ssh admin@{client-hostname}\n</code></pre> <p>The switch hostnames are:</p> <ul> <li><code>clab-srexperts-client11</code></li> <li><code>clab-srexperts-client12</code></li> <li><code>clab-srexperts-client13</code></li> </ul> <p>The client's credentials are <code>admin:multit00l</code></p>"},{"location":"eda/index.html#eda-ui","title":"EDA UI","text":"<p>Most exercises can be completed using EDA's Web UI. As any modern platform, EDA's UI is an API client of the backend API server and uses the same endpoints as any automation system would use, which means that technically every exercise can be solved using any automation interface that consumes EDA API.</p> <p>Still, for the most part we expect you to follow the lead and use the UI to complete the majority of the tasks. Chances are high that this will be your first time seeing and using the EDA UI, so let us give you a quick introduction.</p>"},{"location":"eda/index.html#main-page","title":"Main page","text":"<p>When you log in to the EDA UI you land on the Main page, here are the main areas of interest:</p> <p></p> <p> The home page features a dashboard that provides some key information about the managed nodes and their interfaces.</p> <p> The home page has two dashboards to select from. The page picker lets you do this. The picker will be available on other pages as well.</p> <p> Namespace selector. When you have more than one namespace (<code>eda</code> is the default namespace) you will be able to switch between them.</p> <p> Transaction basket. This is where your uncommitted transactions will be stored. Clicking on the basket icon also lets you do operations on the transactions.</p> <p> Workflows. This menu icon lists the recently run workflows.</p> <p> User menu. This is where you can change your password, log out, and access the help and about pages.</p> <p> Side menu toggle. Expands/collapses the left side menu where all EDA apps and menu items are.</p> <p> Panel selector. EDA provides two default panels - Main and System Administration. The panels control what apps are visible in the side menu. Users can create their own panels and switch between them based on the use case.</p> <p> Application icon. Clicking on the icon in the collapsed view opens up the application page.</p> <p> Application category toggle. Can be used to hide/show the application category.</p>"},{"location":"eda/index.html#app-page","title":"App page","text":"<p>When you select an app from the list  you get a page that lists all instances of this particular app/resource created. In the screenshot below we selected the Nodes from the menu and get a list of Node resources that EDA manages.</p> <p></p> <p>The important elements on this view are:</p> <p> Context menu button. Opens up a menu with commands like edit, duplicate, delete.</p> <p> Click on this icon to display the status bar for the selected resource.</p>"},{"location":"eda/index.html#status-bar","title":"Status bar","text":"<p>When the status bar is expanded, it shows the current information about the selected  resource.</p> <p></p> <p>Every bit of the information about the resource will be available in the sidebar, starting with Metadata , then Status  and continuing with specification of the selected resource.</p>"},{"location":"eda/index.html#edit-page","title":"Edit page","text":"<p>Naturally, you will spend quite some time creating and editing resources. When you click Create button from the App page listing the resources or double click on the row in the grid, or choose Edit from the context menu, you will be presented with an Edit page:</p> <p></p> <p>This form has three main areas (from left to right):</p> <ol> <li>Navigation bar, aka Form fields</li> <li>Form view</li> <li>YAML view</li> </ol> <p>When editing or creating a resource, you would use either the Form view where every resource field is represented as a form field, or the YAML view where you can edit the resource in YAML format. You can start with a form view and continue in YAML editor, the changes are always synchronized.</p> <p>At the left bottom of this page you will find two buttons that allow you to either commit the resource straight away, or add it to a transaction basket.</p>"},{"location":"eda/index.html#transaction-basket","title":"Transaction basket","text":"<p>The transaction basket allows you to group resources together and commit them as a single transaction in an all-or-nothing fashion. Transactions are the key ingredient in EDA's mission to drive human error to zero.</p> <p>By adding resources to the transaction basket you can commit them all together or perform a Dry Run to ensure that the changes pass all sorts of validations before touching the network elements.</p> <p>The workflow below demonstrates how a VLAN resource gets added to the transaction basket, after which a dry run is performed to validate the transaction and then the diffs are browsed to understand the scope of the changes this transaction would result in should we have proceeded with the commit.</p>"},{"location":"eda/index.html#namespace-selector","title":"Namespace selector","text":"<p>When you first login to EDA as administrator, you have access to all available EDA namespaces. Since in this event you will only work in the default <code>eda</code> namespace, you can select it using the namespace selector as shown below:</p> <p></p> <p>By switching from All Namespaces to the <code>eda</code> namespace the UI will fill in the namespace name in the Edit Page when you will create new EDA resources.</p>"},{"location":"eda/index.html#reset-eda","title":"Reset EDA","text":"<p>As you go through the exercises, you will create and modify quite a few resources in EDA. It might happen that the resources from one unfinished challenge will interfere with the tasks you attempt next.</p> <p>In such cases you can manually delete conflicting resources, but if you want to reset EDA to a state as it was at the beginning of the event, you can easily do this by running the following command from the lab server:</p> <pre><code>TX_HASH=$(cat ~/kpn-mini-srx-hackathon/eda/eda-init-tx)\nedactl git restore $TX_HASH\n</code></pre> <p>This script will immediately revert all changes happened in EDA since you first logged in so you can start fresh.</p>"},{"location":"eda/index.html#where-to-next","title":"Where to next?","text":"<p>After this brief introduction to the EDA UI you are ready to start exploring the next generation of network automation by either starting \"The tour of EDA\" that we have prepared for you, or venturing into self-paced exploration.</p> <ol> <li> <p>Pending vendors' support for YANG and modern management interfaces.\u00a0\u21a9</p> </li> </ol>"},{"location":"eda/advanced/service-automation.html","title":"Service Automation using Python","text":"Short Description Define an EDA virtual network integrating Layer 2/3 services using Python Difficulty Advanced Tools used Python, Pydantic Topology Nodes  client11,  client12,  client13,  leaf11,  leaf12,  leaf13 References EDA API Guide, OpenAPI Swagger spec, Pydantic EDA <p>This is the final exercise in a four-part series on using EDA to automate datacenter overlay connectivity services. In this step, you will create the Virtual Network from Part 3 against, but this time using Python and EDA's REST API instead of clicking through the UI.</p> <ul> <li>Part 1: achieve layer-2 connectivity using bridge domains</li> <li>Part 2: achieve layer-3 connectivity using routers</li> <li>Part 3: combine layer-2 and layer-3 connectivity through a single EDA object: the Virtual Network</li> <li>Part 4 (this activity): automate overlay service provisioning from Part 3 with Python, Pydantic and EDA REST API.</li> </ul>"},{"location":"eda/advanced/service-automation.html#objective","title":"Objective","text":"<p>This exercise shares the same goal as Part 3: enabling three Linux hosts to communicate within the same subnet (switched traffic) and across different subnets (routed traffic). However, this time you will use the EDA API with Python as the API client using generated Pydantic classes based on the EDA OpenAPI specification.</p> <p>If you haven\u2019t already completed the EDA REST API, we recommend doing so first. It offers a concise overview of key concepts that will help in understanding this exercise.</p>"},{"location":"eda/advanced/service-automation.html#technology-explanation","title":"Technology explanation","text":"<p>EDA API is extensible. Every EDA resource that gets added when a user installs the application, becomes extends the EDA API surface in a similar way as custom resources in Kubernetes become available through the Kubernetes API. This model provides that powerful extensibility where a system can be customized on-the-fly, by simply installing the EDA App via the EDA Store, and the app will plug its API to the common API layer of the system.</p> <p>EDA's API have two API sets that users typically interact with:</p> <ol> <li>Core API     This is the EDA Core system API. Things like Transactions, Alarms, and User management are all part of the this API set.     It extends with installing a new version of the EDA platform.</li> <li>Apps API     Every applications onboarded to the EDA platform (both provided by Nokia or anyone else) will extend the Apps API by adding the applications API to the common API layer.     This is how extensibility of the API is achieved in EDA.</li> </ol> <p>EDA users can use any REST API client to interact with the EDA API, and in the EDA REST API exercise you had a chance to use the Postman client to interact with the EDA API. In this advanced exercise you will adopt a more sophisticated and powerful approach, you will use Python and its <code>httpx</code> client library as a REST API client, and for extra fun you will consume the EDA API via Pydantic models generated for the EDA OpenAPI specification.</p> <p>Pydantic and OpenAPI</p> <p>Pydantic is a Python library used for data validation and data parsing using Python type annotations. It\u2019s widely used to define schemas (models) for structured data, such as the kind you get from JSON APIs. It provides automatic validation, detailed error messages and conversion of input data to Python native types.</p> <p>OpenAPI (formerly Swagger) is a standard specification for documenting and defining RESTful APIs. As the specification is usually written in YAML of JSON, it can be used to generate Documentation and Client SDKs.</p>"},{"location":"eda/advanced/service-automation.html#why-pydantic","title":"Why Pydantic?","text":"<p>Why would you even use Pydantic? What's wrong with just reading the OpenAPI spec, identifying the request body and go fire off the request? The answer is simple: Pydantic makes your code more robust, easy to write and read and thus makes your life easier. Let us expand.</p> <p>Without Pydantic, every request you have would look like a JSON object inside your body. But how would you create this JSON body? Manually typing it in or templating with Jinja - and you are in for a good time debugging and runtime errors the moment you make a typo, miss a required field or transition to an API that has changed.</p> <p>With Pydantic, you get the native Python classes generated from the OpenAPI spec so that you can programmatically generate request bodies, get IDE support and autocompletion and validate the provided data against the OpenAPI schema before you send the requests to the server.</p>"},{"location":"eda/advanced/service-automation.html#how-pydantic-and-openapi-work-together","title":"How Pydantic and OpenAPI Work Together","text":"<p>Pydantic models are commonly derived from an OpenAPI specification, which outlines the structure and rules of an API:</p> <ul> <li>OpenAPI defines the expected input, output, and behavior of an API.</li> <li>Pydantic enforces those rules and provides a Pythonic way to construct and validate data.</li> </ul> <p>This allows developers to work with EDA resources programmatically, avoiding the need to manually craft JSON or YAML definitions.</p> <p>The Pydantic EDA community project provides the Pydantic models for EDA API. It generates them from the EDA OpenAPI specifications published in the EDA OpenAPI spec repo.</p> <p>Before diving into the task of creating a Virtual Network with Python, let's first review the basics concepts behind a Pydantic model, and for that we will use one of the most basic units of automation - the Interface.</p>"},{"location":"eda/advanced/service-automation.html#interface-pydantic-model","title":"Interface Pydantic Model","text":"<p>In EDA, all resources are schema driven, this means, that the representation of a resource may look different, but the structure is exactly the same, no matter what automation interface you use. For example, let's consider the Interface resource as it appears in the UI and in the API documentation.</p> <p>In the EDA UI go to the  TOPOLOGY \u2192 IInterfaces and click on <code>leaf11-ethernet-1-49</code> to open the schema form. In the other tab visit the EDA API documentation ( icon in the top right of the page) and open the Interface Application API tab.</p> <p>You'll notice that the resource definition appears the same, only the format differs (YAML vs. JSON); see the screenshots below:</p> EDA UI Interface yaml definitionAPI Interface documentation <p></p> <p></p> <p>Since EDA models its resources after the Kubernetes Custom Resources (CRs), each object follows a structure familiar to Kubernetes users:</p> <ul> <li><code>apiVersion</code>: The API group and API version the object belongs to</li> <li><code>kind</code>: What kind of object it is</li> <li><code>metadata</code>: Identification fields like a <code>name</code> string and a <code>namespace</code>, plus auxiliary metadata like <code>labels</code> and <code>annotations</code>.</li> <li><code>spec</code>: provides the specification for the resource - its configuration.</li> <li><code>status</code>: (not shown here) provides state/status information about the resource, such as its current state, the nodes it is deployed on or health.</li> </ul> <p>With Pydantic classes you can define EDA resources using native Python code, providing type validation, structure enforcement, and a more native development experience.</p> <p>Let's see side by side an Interface CR and it's Pydantic definition:</p> Interface yaml definitionInterface Pydantic definition <pre><code>apiVersion: interfaces.eda.nokia.com/v1\nkind: Interface\nmetadata:\n  name: leaf11-ethernet-1-49\n  namespace: eda\nspec:\n  type: interface\n  description: \"inter-switch link to spine11\"\n  enabled: true\n  mtu: 9198\n  members:\n    - node: g15-leaf11\n      interface: ethernet-1-49\n</code></pre> <pre><code>import pydantic_eda.apps.interfaces.v1alpha1.models as iface # (1)!\n\n\ndef interface(ns: str, name: str) -&gt; iface.Interface: #(2)!\n    iface_ = iface.Interface(\n        apiVersion=\"interfaces.eda.nokia.com/v1\",\n        kind=\"Interface\",\n        metadata=iface.InterfaceMetadata( #(3)!\n            name=name,\n            namespace=ns,\n        ),\n        spec=iface.InterfaceSpec(\n            description=\"inter-switch link to spine11\",\n            mtu=9198,\n            members=[\n                iface.InterfaceSpecMember(\n                    interface=\"ethernet-1-49\",\n                    node=\"g15-leaf11\",\n                ),\n            ],\n        ),\n    )\n\n    return iface_\n</code></pre> <ol> <li>The first thing we do is importing the Pydantic classes that have been already generated by the EDA community.</li> <li>Our function takes as arguments the <code>namespace</code> and the <code>name</code> of the CR, and returns the Interface object.</li> <li>Metadata is modeled as a class and takes the <code>namespace</code> and <code>name</code> as input.</li> <li>The <code>spec</code> is also modeled as the InterfaceSpec class.</li> </ol> <p>Click at each annotation  to see a explanation of that relevant section.</p> <p>The Python <code>interface</code> function shown is only one component of the complete code needed to fully provision a Virtual Network. It serves as a building block within a larger program. A complete Python solution includes:</p> <ul> <li>A <code>client</code> to manage the REST API connection and handle transaction creation and commit</li> <li><code>logging</code> for monitoring interaction status</li> <li>Additional <code>functions</code> for defining other Pydantic-based EDA resources (e.g., Virtual Network)</li> <li>A <code>main</code> routine that orchestrates the overall workflow</li> </ul> <p>For this exercise, we\u2019ll provide these core components so you can concentrate on constructing the Pydantic model for the Virtual Network.</p>"},{"location":"eda/advanced/service-automation.html#tasks","title":"Tasks","text":"<p>Now it's time to apply what we've learned so far and create a Virtual Network in the most pythonic way possible.</p> <p>IMPORTANT</p> <p>Remove any Bridge Domains, Bridge Interfaces or VLANs created in the Bridge Domains/Part 1 and the Routers/Part 2 as our Virtual Network will create them or simply reset EDA using the git time machine.</p>"},{"location":"eda/advanced/service-automation.html#setup-environment","title":"Setup environment","text":"<p>Tip</p> <p>It\u2019s highly recommended to use a code editor with Python auto-completion and suggestions enabled, as it will significantly improve your productivity and help avoid syntax errors when working with Pydantic models.</p> <p>Clone the openapi-example-python that provides the EDA API client implemented in Python. You can clone it to your own personal device or your dedicated hackathon instance VM running the lab topology.</p> <p>If you're working on your local device, make sure the uv python package manager and installer is installed beforehand.</p> <pre><code>git clone  -b srx-2025 https://github.com/eda-labs/openapi-example-python.git\ncd openapi-example-python\n</code></pre> <p>After you cloned the repository, initialize the virtual environment:</p> <pre><code>uv sync\n</code></pre> <p>In the <code>main.py</code> file, configure the <code>YOUR_EDA_EXT_DOMAIN_NAME:PORT</code> with your EDA Web UI/API address you have been provided with.</p>"},{"location":"eda/advanced/service-automation.html#start-coding","title":"Start Coding","text":"<p>The project structure is the following:</p> <pre><code>openapi-example-python/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 client.py              # Handles REST API communication and transactions\n\u2502   \u251c\u2500\u2500 logging.py             # Sets up logging configuration\n\u2502   \u2514\u2500\u2500 virtualnetwork.py      # Defines Pydantic models for Virtual Network\n\u251c\u2500\u2500 main.py                    # Entry point to tie everything together\n\u251c\u2500\u2500 pyproject.toml             # Project metadata and dependencies (used by uv)\n\u251c\u2500\u2500 uv.lock                    # Lockfile with exact versions of dependencies\n</code></pre> <p>The <code>client.py</code> and <code>logging.py</code> files are prebuilt and ready to use.</p> <p>Your task is to implement the Virtual Network definition inside the <code>virtualnetwork.py</code> file that is then referenced in the <code>main.py</code>. The <code>virtualnetwork.py</code> file has an import block that pulls in the generated Pydantic classes for the services application that contains the VirtualNetwork resource. By importing this module, you get access to the generated classes from the OpenAPI spec for this application.</p> <p>Since you already have an idea what the virtual network resource consists of after completing the Part 3 of this challenge, you may start by typing starting to define your virtual network:</p> <pre><code>vnet_ = service.VirtualNetwork()\n</code></pre> <p>And let IDE help you identify what properties a <code>VirtualNetwork</code> class has. Since the Virtual Network is a composite resource that references Bridge Domains, IRBs, VLANs and so on, you will have multiple specifications in the generated Pydantic model, they will differ by the name, but to see which one is relevant for which resource might require some looking around in the provided pydantic module.</p>"},{"location":"eda/advanced/service-automation.html#test-your-code","title":"Test your code","text":"<p>Once you have your code ready you can execute it with <code>uv run python main.py</code>.</p> <p>If everything works correctly, you should see output similar to the following:</p> <pre><code>[*]\u2500[~/openapi-example-python]\n\u2514\u2500\u2500&gt; python main.py\n[05/10/25 14:34:41] INFO     Authenticating with EDA API server                                                                                                                         client.py:54\n                    INFO     Adding 'VirtualNetwork' resource from 'services.eda.nokia.com/v1' to the 'create' transaction list                                                        client.py:101\n                    INFO     Transaction 183 committed                                                                                                                                 client.py:160\n[05/10/25 14:34:43] INFO     Transaction 183 state: complete                                                                                                                           client.py:166\n\n[*]\u2500[~/openapi-example-python]\n</code></pre> <p>You can go now to the EDA UI System \u2192 Transactions and check the details of the Transaction and see your Virtual Network in the list of Virtual Network resources.</p> Hint <p>Your function should list the specification of the bridge domains, a router, the routed interfaces and everything you used to create a VNET resource in the Part 3. You high level structure could look like this:</p> <pre><code>def virtualnetwork(ns: str, name: str) -&gt; service.VirtualNetwork:\n    vnet = service.VirtualNetwork(\n        apiVersion=\"services.eda.nokia.com/v1\",\n        kind=\"VirtualNetwork\",\n        metadata=service.VirtualNetworkMetadata(\n            name=name, namespace=ns, labels={\"role\": \"exercise\"}\n        ),\n        spec=service.VirtualNetworkSpec(\n            routers=[\n                router,\n            ],\n            routedInterfaces=[\n                routed_if_client11,\n                routed_if_client13,\n            ],\n            bridgeDomains=[\n                bd_300,\n                bd_312,\n            ],\n            vlans=[\n                vlan_300,\n                vlan_312,\n            ],\n            irbInterfaces=[\n                irb_300,\n                irb_312,\n            ],\n        ),\n    )\n\n    return vnet\n</code></pre>"},{"location":"eda/advanced/service-automation.html#test-the-connectivity","title":"Test the connectivity","text":"<p>With the Virtual Network committed to the fabric, you should now have IP connectivity between your clients! Login to one of the clients and try to ping the IP of the other ones!</p> <p>See Access Details if you need a reminder on how to access the nodes in the topology.</p> Client11Client12Client13 <ul> <li><code>ping -I eth1.300 10.30.0.12</code></li> <li><code>ping -I eth1.311 10.30.2.12</code></li> <li><code>ping -I eth1.311 10.30.3.13</code></li> </ul> <ul> <li><code>ping -I bond0.300 10.30.0.13</code></li> <li><code>ping -I bond0.312 10.30.1.11</code></li> <li><code>ping -I bond0.312 10.30.3.13</code></li> </ul> <ul> <li><code>ping -I eth1.300 10.30.0.11</code></li> <li><code>ping -I eth1.313 10.30.1.11</code></li> <li><code>ping -I eth1.313 10.30.2.12</code></li> </ul>"},{"location":"eda/advanced/service-automation.html#summary-and-review","title":"Summary and review","text":"<p>Great job! By completing this activity, you have accomplished the following:</p> <ul> <li>Gained an understanding of how to represent EDA resources in Python using Pydantic models. In a fully modeled way, without any YANG pains.</li> <li>Converted a Virtual Network configuration from the EDA UI into structured Python code.</li> <li>Programmatically created and submitted EDA resources using the REST API.</li> <li>Worked with project scaffolding, transaction handling, and data validation.</li> <li>Automated Virtual Network provisioning, enabling consistent and reusable deployment workflows.</li> </ul> Possible solution Python code (only look here as a last resort!) <p>The solution to this challenge is provided here.</p> <p>This is just one possible solution. There are many valid ways to approach these tasks. If your code achieves the desired outcome, then your solution is perfectly valid!</p>"},{"location":"eda/beginner/allocations.html","title":"Allocations","text":"Short Description A fully declarative system must have a way to declare, manage and use allocations such as IP addresses, indexes and subnets. Difficulty Beginner Topology Nodes leaf11, leaf12, leaf13, spine11, spine12 Tools used EDA UI References Allocation Pools documentation <p>One of infamous challenges of network automation lies in the domain of Network Source of Trust, often abbreviated as NSoT. Managing IP addresses, ASN numbers, VLAN IDs and tunnel indexes without a system that allows you to both manage and enforce allocations to the network elements is a recipe for network configuration drift and sleepless nights.</p> <p>EDA acts as an enforcing source of truth system, as it not only manages the allocation pools with IP addresses, VLAN IDs and so on, but also ensures that the allocated resources are actually provisioned on the managed devices.</p> <p>Want to learn more about allocations?</p> <p>After completing this exercise that introduces you to the concept of allocations you may want to try out the more advanced activity - Custom Allocations - that explores how custom allocations can be defined such that you get to define what resource identifiers are allocated.</p>"},{"location":"eda/beginner/allocations.html#objective","title":"Objective","text":"<p>Our objective is to learn what EDA's Allocation Pools are and how they ensure a consistent and automated way of resource identifiers allocations used in the EDA Intents.</p> <p>Below is a call flow diagram that illustrates how EDA handles identifiers allocation requests from the user.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant A as Interface App\n    participant P as Allocation Pool\n\n    U-&gt;&gt;A: I need a new p2p interface&lt;br/&gt;with IP taken out from an allocation pool\n    A-&gt;&gt;P: Can I have a new IP&lt;br/&gt;to for the p2p interface I want to create?\n    P-&gt;&gt;A: Here is a new unused IP from the pool\n\n    Note over A: Creates a new IP interface&lt;br/&gt;using the IP allocated from the pool\n\n    A-&gt;&gt;U: I have created the interface</code></pre>"},{"location":"eda/beginner/allocations.html#technology-explanation","title":"Technology Explanation","text":"<p>EDA manages resource identifiers such as IP addresses, VLAN IDs, ASN numbers and tunnel indexes via a concept of Allocation Pools.</p> <p>As with anything in EDA, an Allocation Pool is declaratively defined as a resource of a specific type. Four kinds of allocation pools are available in EDA, each defines a pool with a unique property to cater for a specific allocation use case:</p> <ul> <li>Indices     Specify a size and starting value     Return an integer on allocation</li> <li>IP Addresses     Specify an IPv4 or IPv6 subnet including mask in CIDR format (e.g. <code>192.0.2.0/24</code>)     Return an address from the subnet on allocation, without any mask information (e.g. <code>192.0.2.1</code>)</li> <li>IP Addresses + Masks     Specify an IPv4 or IPv6 subnet including mask in CIDR format (e.g. <code>192.0.2.0/24</code>)     Return an address from the subnet on allocation, with mask information (e.g. <code>192.0.2.1/24</code>)</li> <li>Subnets     Specify an IPv4 or IPv6 subnet including mask in CIDR format (e.g. <code>192.0.2.0/24</code>) and a subnet length (e.g. <code>31</code>)     Return a subnet of the specified length from the provided subnet on allocation, with mask information (e.g. <code>192.0.2.8/31</code>)</li> </ul> <p>EDA Allocation Pools have certain interesting capabilities that make them play nice in the declarative setting:</p> <ul> <li>Deterministic allocations \u2014 If provided the same allocation input, the value of any previous allocation will be returned. No surprises!</li> <li>Persist allocations \u2014 Restarting the platform does not result in any re-indexing.</li> <li>Implicit freeing of allocations \u2014 If a resource is updated and no longer needs an allocation, it\u2019s freed up for something else.</li> </ul>"},{"location":"eda/beginner/allocations.html#creating-an-allocation-pool","title":"Creating an Allocation Pool","text":"<p>An operator would create an allocation pool of a specific kind like any other resource, for example, here is a resource definition for an allocation pool of type <code>indices</code> that is used to allocate AS Numbers:</p> <pre><code>apiVersion: core.eda.nokia.com/v1\nkind: IndexAllocationPool\nmetadata:\n  name: srexperts-asnpool\n  namespace: eda\nspec:\n  segments:\n    - start: 4200001000\n      size: 1000\n</code></pre> <p>The <code>kind</code> field is set to <code>IndexAllocationPool</code> to indicate that this is an allocation pool of type <code>indices</code>.</p> <p>As mentioned above, the indices allocation pools are determined by the <code>start</code> and <code>size</code> fields. You can have many segments in a pool, but the segments must not overlap.</p>"},{"location":"eda/beginner/allocations.html#using-allocation-pools","title":"Using Allocation Pools","text":"<p>The YAML above defines the <code>srexperts-asnpool</code> allocation pool, which starts from <code>4200001000</code> and has a size of <code>1000</code> elements in it. Whenever any EDA resource asks for an allocation from this pool, it will be allocated an AS Number from the range <code>[4200001000, 4200001999]</code> in the sequential order.</p> <p>Here is how this pool is referenced in the Fabric resource that creates the DC fabric across all leaf and spines in our topology:</p> <pre><code>apiVersion: fabrics.eda.nokia.com/v1alpha1\nkind: Fabric\nmetadata:\n  name: srexperts-fabric\n  namespace: eda\nspec:\n  interSwitchLinks:\n    linkSelector:\n      - eda.nokia.com/role=interSwitch\n    unnumbered: IPV6\n  leafs:\n    asnPool: srexperts-asnpool\n    leafNodeSelector:\n      - eda.nokia.com/role=leaf\n  overlayProtocol:\n    # omitted\n  underlayProtocol:\n    # omitted\n</code></pre> <p>Many resources you find in EDA will allow you to specify either a pool to select the identifier from, or allow you to set the identifier yourself in a static way.</p> <p>For example, when creating a VLAN resource, you can either set the VLAN ID manually, or let EDA allocate a VLAN ID from a pool of VLANs.</p> <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: VLAN\nmetadata:\n  name: macvrf-100-vlan1\n  namespace: eda\nspec:\n  bridgeDomain: macvrf-100\n  interfaceSelector:\n    - edge-type=compute\n  uplink:\n    # omitted\n  vlanID: '1'\n  vlanPool: ''\n  # omitted\n</code></pre> <p>In the example above, the VLAN resource is using a statically assigned VLAN ID of <code>1</code>, and does not leverage any allocation pools, as the <code>vlanPool</code> field is left empty.</p>"},{"location":"eda/beginner/allocations.html#custom-allocations","title":"Custom Allocations","text":"<p>Custom Allocations (aka Preallocations) are a way to mark identifiers in an allocation pool allocatable to only specific resources that requested them. For example, from the pool of AS Numbers we can preallocate the AS Number <code>4200001111</code> to the <code>leaf11</code> specifically by creating the allocation.</p> <pre><code>apiVersion: core.eda.nokia.com/v1\nkind: IndexAllocationPool\nmetadata:\n  name: srexperts-asnpool\n  namespace: eda\nspec:\n  publishAllocations: true\n  segments:\n    - start: 4200001000\n      size: 1000\n      allocations:\n        - name: srexperts-fabric-leaf-leaf11\n          value: 4200001111\n</code></pre> <p>The preallocation is defined in the allocation pool resource by providing the <code>allocations</code> block with the list of the following field pairs:</p> <ol> <li><code>name</code>: the \"allocation key\" that a specific application (fabric in the example above) would provide when requesting an allocation from the pool.</li> <li><code>value</code>: the value that should be allocated to the application.</li> </ol> <p>With the preallocation defined as above, the fabric application can request an allocation from the <code>srexperts-asnpool</code> pool for the <code>leaf11</code> node and the preallocated value <code>4200001111</code> will be returned from the pool as the application would provide a key that matches the <code>name</code> field of the preallocation.</p> <p>Applications are in control of the key format they send along with the request for an allocation. The Fabric apps uses the key in the following format: <code>{fabric-name}-{role-name}-{node-name}</code> which in the example above had been translated to <code>srexperts-fabric-leaf-leaf11</code>.</p> <p>Custom Allocations activity</p> <p>While this activity introduces you to the concept of allocations, we also have a more advanced - Custom Allocations - exercise that you can try out to understand how you can pre-allocate resources from the pool and to have deterministic allocation results.</p>"},{"location":"eda/beginner/allocations.html#reservations","title":"Reservations","text":"<p>What if you want to reserve a block of indices, ip addresses or subnets from being allocated? For example, you want to create an IP Address pool that allocates IP addresses from subnet <code>10.1.0.0/16</code> and reserve the first 100 addresses as they are not used in your design, or allocated for other systems, not managed by EDA.</p> <p>This is a job for Reservations. Reservations allow you to define blocks of identifiers that should not be allocated from this pool, effectively making them \"reserved\". Here is how we would define the reservations for the IP Address pool as per our intent to block first 100 addresses from a subnet:</p> <pre><code>apiVersion: core.eda.nokia.com/v1\nkind: IPAllocationPool\nmetadata:\n  name: my-ip-pool\n  namespace: eda\nspec:\n  segments:\n    - reservations:\n        - end: 10.1.0.0\n          start: 10.1.0.99\n      subnet: 10.1.0.0/16\n</code></pre>"},{"location":"eda/beginner/allocations.html#tasks","title":"Tasks","text":""},{"location":"eda/beginner/allocations.html#identify-allocation-pools","title":"Identify Allocation Pools","text":"<p>Your first task is to find the existing allocation pools in the <code>eda</code> namespace. Start by logging in the EDA UI and find the Allocation Pools.</p> Hint: How to find existing allocation pools in UI <p>Look for Allocations group in the left sidebar.</p> <p>You may also use Kubernetes API and <code>kubectl</code> tool available on the server instance to find existing allocation pools. Try listing Index Allocation Pools using <code>kubectl</code>, you will need to know the resource kind to use; maybe EDA UI can give you a hint?</p> Hint: How to find allocation pool kind? <p>To find the resource kind for the specific allocation, find the allocation resource in the EDA UI, and switch to the YAML view of the resource to see its kind:</p> <p>Knowing the resource kind, you can use <code>kubectl</code> and list resources by its kind:</p> <pre><code>kubectl -n eda get indexallocationpools\n</code></pre>"},{"location":"eda/beginner/allocations.html#find-allocated-asn-numbers","title":"Find Allocated ASN Numbers","text":"<p>Now that you know what allocation pools exist in your EDA instance, it is time to find out how these pools are used.</p> <p>The SReXperts 2025 topology that is deployed in the lab environment you work on used EDA to deploy the fabric configuration over the three leafs and two spines that make up the datacenter topology.</p> EDA Managed nodes <p>The pre-created Fabric resource configured the data center underlay to make it possible to create virtual networks on top of it. In particular, the Fabric resource is responsible for the following configuration on the managed nodes:</p> <ul> <li>export/import policies</li> <li>network instances</li> <li>bgp peers in the underlay and overlay</li> <li>inter-switch link configs</li> <li>and so on and so forth</li> </ul> <p>And all that, by submitting a single Fabric resource, that looks like in its entirety like this:</p> <pre><code>apiVersion: fabrics.eda.nokia.com/v1alpha1\nkind: Fabric\nmetadata:\n  name: srexperts-fabric\n  namespace: eda\n  labels:\n    role: hackathon-infra\nspec:\n  borderLeafs:\n    borderLeafNodeSelector:\n      - eda.nokia.com/role=borderleaf\n  interSwitchLinks:\n    linkSelector:\n      - eda.nokia.com/role=interSwitch\n    unnumbered: IPV6\n  leafs:\n    leafNodeSelector:\n      - eda.nokia.com/role=leaf\n  overlayProtocol:\n    bfd:\n      desiredMinTransmitInt: 1000000\n      detectionMultiplier: 3\n      enabled: true\n      minEchoReceiveInterval: 1000000\n      requiredMinReceive: 1000000\n    bgp:\n      autonomousSystem: 65000\n      clusterID: '1'\n      rrClientNodeSelector:\n        - eda.nokia.com/role=leaf\n        - eda.nokia.com/role=borderleaf\n      rrNodeSelector:\n        - eda.nokia.com/role=spine\n    protocol: IBGP\n  spines:\n    spineNodeSelector:\n      - eda.nokia.com/role=spine\n  systemPoolIPV4: systemipv4-pool\n  underlayProtocol:\n    bfd:\n      desiredMinTransmitInt: 1000000\n      detectionMultiplier: 3\n      enabled: true\n      minEchoReceiveInterval: 1000000\n      requiredMinReceive: 1000000\n    bgp:\n      asnPool: asn-pool\n    protocol:\n      - EBGP\n</code></pre> <p>Checkout the highlighted lines in the Fabric resource YAML. This is where we reference allocation pools of different kinds.</p> <p>The Fabric application that processes the Fabric resource sees the referenced allocation pools and uses EDA SDK to request a next allocation for a particular resource.</p> <p>You can check what values have been allocated from the relevant allocation pools using EQL. We are interested in the AS Numbers allocated for the data center switches, and as shown in the Fabric resource definition, the <code>srexperts-asnpool</code> is the allocation pool that is used to allocate AS Numbers.</p> <p>Open the Queries page and list allocated values by submitting the following EQL query:</p> <pre><code>.namespace.allocations.v1.template.instance.allocation where ( .namespace.allocations.v1.template.name = \"srexperts-asnpool\" )\n</code></pre> <p>This query lists the allocation key that an application used to request an AS number and the associated value.</p> <p></p> <p>The result of this query shows that our leafs have been allocated AS numbers from the <code>srexperts-asnpool</code>, namely:</p> <ul> <li>leaf11 - 4200001000</li> <li>leaf12 - 4200001001</li> <li>leaf13 - 4200001002</li> </ul>"},{"location":"eda/beginner/allocations.html#changing-as-numbering-scheme","title":"Changing AS Numbering scheme","text":"<p>In this task you are asked to change the AS Numbers used for the data center switches in our fabric from the default starting range of 4200001000 to some other 4-byte ASN range.</p> Hints <p>You can edit the existing <code>srexperts-asnpool</code> allocation pool and change the start and size of the AS Number range to fit the 2-byte AS Number scheme.</p> <p>If you want a more challenging task, create a new pool and reference it from the Fabric resource under the <code>leafs</code> block, while keeping spines using the original allocation pool.</p> <p>When changing the pool configuration don't commit the change right away, use the Dry Run functionality to appreciate the automation mechanics that will expand a single pool change to a configuration change across the entire fabric.</p> <p>By completing these tasks you should have a basic understanding of Allocation Pools used in EDA. What are they used for, what types of pools we have in the product and how they serve different purposes.</p> <p>You also learned how to find what allocation values have been used, change existing and create new allocation pools, and how resources reference the pools to request identifiers from them.</p>"},{"location":"eda/beginner/bridge-domains.html","title":"Bridge domains","text":"Short Description Creating bridge domains with EDA to achieve layer 2 connectivity Difficulty Beginner Topology Nodes  client11,  client13,  leaf11,  leaf13 <p>This is the first exercise in a 4-part series around using EDA to achieve connectivity to, from, and within your datacenter. In this exercise, we will achieve layer-2 connectivity between two hosts in the same broadcast domain.</p> <ul> <li>Part 1 (this activity): achieve layer-2 connectivity using bridge domains</li> <li>Part 2: achieve layer-3 connectivity using routers</li> <li>Part 3: combine layer-2 and layer-3 connectivity through a single EDA object - the Virtual Network (VNET)</li> <li>Part 4: automate parts 1 through 3 of this exercise with Python</li> </ul>"},{"location":"eda/beginner/bridge-domains.html#objective","title":"Objective","text":"<p>In this exercise, we enable the layer 2 connectivity between the two linux hosts in our lab topology. Both linux hosts have an IP address in the same IP subnet and our objective is to ensure that the traffic is switched over the datacenter fabric using a dedicated and isolated MAC-VRF service.</p>"},{"location":"eda/beginner/bridge-domains.html#technology-explanation","title":"Technology explanation","text":"<p>Layer-2 or switched traffic in a datacenter is often used in distributed workloads to accommodate connectivity between two computes, without the router being aware of which IPs the computes use to communicate. Some prominent examples where Layer 2 connectivity is required are:</p> <ol> <li> <p>VM mobility</p> <p>Virtual machines are being recreated with the same IP on a different physical compute, to allow for maintenance and rapid failover.</p> </li> <li> <p>DHCP</p> <p>Broadcast traffic is often a significant and important part of connectivity between computes and relies exclusively on MAC addresses to communicate. One such example is the dynamic host configuration protocol (DHCP) used to dynamically assign IP addresses.</p> </li> </ol> <p>In this exercise, we'll take a look at how layer 2 connectivity can be facilitated using EDA's Bridge Domains. A bridge domain is another word for a Virtual Private LAN Service (VPLS in SR OS lingvo) or a MAC-VRF (SR Linux).</p>"},{"location":"eda/beginner/bridge-domains.html#tasks","title":"Tasks","text":"<p>See Access Details if you need a reminder on how to access the nodes in the topology.</p>"},{"location":"eda/beginner/bridge-domains.html#inspect-the-ip-configuration-of-both-clients","title":"Inspect the IP configuration of both clients","text":"<p>Before we start, we need to verify the IP configuration on both clients. We're interested in two things:</p> <ol> <li>the VLAN the clients use to communicate</li> <li>the IP address of each client so we can test later whether the connectivity is in place.     Multiple IP addresses are configured for different hackathon exercises, so you're looking for an IP in the subnet <code>10.30.0.0/24</code></li> </ol> <p>To connect to the shell of the client nodes, you should connect to the server running your lab and then ssh to each node, for example, for <code>client11</code>:</p> execute from the lab server<pre><code>ssh admin@clab-srexperts-client11\n</code></pre> <pre><code>[*]\u2500[client11]\u2500[~]\n\u2514\u2500\u2500&gt;\n</code></pre> <p>When in the client shell, try to answer these questions:</p> <ul> <li>Which VLAN are the clients using to communicate?</li> <li>Which command can you use to test the connectivity?</li> </ul> Hint: the relevant IP interfaces on the clients client-11client-13 <pre><code>[*]\u2500[client11]\u2500[~]\n\u2514\u2500\u2500&gt; ip route show 10.30.0.0/24\n10.30.0.0/24 dev eth1.300 proto kernel scope link src 10.30.0.11\n</code></pre> <pre><code>[*]\u2500[client13]\u2500[/]\n\u2514\u2500\u2500&gt; ip a | grep \"10.30.0\" -A 5 -B 2\n5: eth1.300@eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9500 qdisc noqueue state UP group default qlen 1000\n    link/ether aa:c1:ab:b9:1b:9e brd ff:ff:ff:ff:ff:ff\n    inet 10.30.0.13/24 scope global eth1.300\n       valid_lft forever preferred_lft forever\n    inet6 fd00:fdfd:0:3000::13/64 scope global\n       valid_lft forever preferred_lft forever\n    inet6 fe80::a8c1:abff:feb9:1b9e/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> Solution <p>The VLAN the computes will use to access the layer 2 domain is VLAN <code>300</code>. Note that there are both IPv4 and IPv6 addresses configured on the node.</p> <p>To test the connectivity, the following command can be used. Note that connectivity is currently not working, as expected. We will have to create the Bridge Domain to achieve it.</p> <pre><code># for IPv4\n[x]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.13\nPING 10.30.0.13 (10.30.0.13) 56(84) bytes of data.\nFrom 10.30.0.11 icmp_seq=1 Destination Host Unreachable\n\n--- 10.30.0.13 ping statistics ---\n1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms\n</code></pre> <pre><code># for IPv6\n[x]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::13\nPING fd00:fdfd:0:3000::13(fd00:fdfd:0:3000::13) 56 data bytes\nFrom fd00:fdfd:0:3000::11 icmp_seq=1 Destination unreachable: Address unreachable\n\n--- fd00:fdfd:0:3000::13 ping statistics ---\n1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms\n</code></pre>"},{"location":"eda/beginner/bridge-domains.html#list-bridge-domains","title":"List Bridge Domains","text":"<p>Login to the EDA UI using the assigned Group ID and EDA credentials provided to you.</p> <p>The EDA platform consists of the core and the apps that extend it and provide the resources for declarative network management. Although you can make your own apps, Nokia already provides an extensive library of pre-installed apps that can handle a lot of configuration tasks. Programming your own app is beyond the scope of this exercise.</p> <p>Look at the app menu in the left sidebar for \"Bridge Domains\", which is located in the \"Virtual Networks\" category.</p> <p></p> <p>When you click on the Bridge Domain menu element, you will see the list of existing Bridge Domains. A few of them are already there to power up other exercises, but none of them enable connectivity over VLAN 300 that our clients are intent on using.</p> <p>If you come from operations you don't just blindly trust some lines in a management system, you want proofs, and better yet, the exact config that is running on the devices. Normally, you would log in to the switches, maybe one by one, and run the show commands. But this is so eighties, how about you use the query language that EDA provides and ask all your network elements to list their MAC VRFs?</p> <p>EDA comes with a built-in network-wide query engine that allows you to query the network devices in a performant and scalable way. Using the sidebar navigation menu, select the Queries menu and paste the following in the EQL Query input field:</p> <pre><code>.namespace.node.srl.network-instance where ( type = \"mac-vrf\" )\n</code></pre> <p>You should see a network-wide query result with all nodes reporting back all network instances of type <code>mac-vrf</code> they have configured.</p> <p></p> <p>Then you can ask the nodes to list all subinterfaces they have and their single-tagged vlan ids:</p> <pre><code>.namespace.node.srl.interface.subinterface.vlan.encap.single-tagged\n</code></pre> <p>You will likely won't see any subinterface with VLAN 300, and that's expected, we did not configure this either. So let's get to it.</p>"},{"location":"eda/beginner/bridge-domains.html#create-a-bridge-domain","title":"Create a bridge domain","text":"<p>In the Virtual Networks \u2192 Bridge Domains app page click the \"Create\" button in the top-right to create a new bridge domain. In the center of the screen you can see all configuration options for the new bridge domain, and on the right is a YAML representation of the same. You can either fill the form fields, or edit the YAML, whatever you prefer.</p> <p></p> <p>Create a new bridge domain, so you can attach some interfaces to it in the next step. If you're not sure which value you need to pick for a particular property, you can leave the field default or empty. The most important properties are:</p> <ul> <li>A name so you can reference this bridge domain later.</li> <li>The type should be left as \"EVPNVXLAN\", as the Bridge Domain (mac vrf) will be used to provide overlay services.</li> </ul> A note about namespaces <p>Namespaces in EDA are used to separate resources into any way you see fit: in a real-life network, you may want to split your fabric resources into regions or functions, for example. In the hackathon we have only one namespace -  <code>eda</code> - which has been pre-configured in your lab topology.</p> <p>When you are finished, you can press the Commit button to commit the transaction<sup>1</sup> right away which will result in EDA verifying the correctness of the Bridge Domain configuration and... It will store the Bridge Domain resource in the EDA database, but no config will be pushed to the nodes. Why, you ask?</p> <p>The bridge domain configuration is only pushed to nodes when Bridge Interface resources are created that refer a bridge domain; And since we don't have them yet - EDA does not push anything to the nodes. We'll add them in the next step.</p> <p>The solution can be found below in YAML format, if you want to refer to it. You can copy this yaml object into the right column in the GUI to change your current config.</p> Solution <p>It is enough to define the Bridge Domain like this:</p> <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: BridgeDomain\nmetadata:\n  name: bridge-domain-vlan300\n  namespace: eda\nspec:\n  type: EVPNVXLAN\n  vniPool: vni-pool\n  eviPool: evi-pool\n  tunnelIndexPool: tunnel-index-pool\n</code></pre> <p>The key pieces here are the pools used for the VNI, EVI and tunnel index allocation. Want to know more about pools and how EDA presents itself as a source of truth and IPAM? Read about Allocation Pools first.</p> <p>After committing the Bridge Domain you can verify that it was not instantiated on the nodes by running the same EQL query listing all mac-vrfs as we did before.</p>"},{"location":"eda/beginner/bridge-domains.html#create-bridge-interfaces","title":"Create Bridge Interfaces","text":"<p>Bridge interfaces enable the attachment of the network interfaces to a particular service/vrf/bridge-domain. They can refer to a physical interface on a device, perform actions on ingress/egress and set the VLAN ID and thus ensure that multiple virtual machines can share the same physical interface, yet are logically isolated.</p> <p>In EDA, you can create Bridge Interfaces resources one at a time by referencing a particular interface object, or create several of them by using labels. We'll start with manually specifying an interface, but in a future step we'll do this again with labels, which are much easier to work with!</p> <p>Find the Bridge Interfaces section of the Virtual Networks category of your side menu on the left. You should not see any existing bridge interfaces, as we will create them in this exercise. Hit the Create button and let's dive in.</p> <p>Recall, that the Bridge Interface resource in EDA can reference an existing Interface object to a single Bridge Interface mapped to a network interface. You are tasked with creating a Bridge Interface that would target the already existing interface <code>leaf11-client11</code> and associate it with the Bridge Domain we created earlier. In the Bridge Interface form you should at a minimum provide the following:</p> <ol> <li>Bridge Interface a name</li> <li>A reference to the Bridge Domain that this Bridge Interface should be connected to</li> <li>A VLAN ID that this Bridge Interface should be using (hint: you found out the VLAN ID in one of the previous steps!).</li> <li>A reference to the Interface resource that this Bridge Interface should be using.</li> </ol> <p>Once you figured out what to enter in the Bridge Interface form, don't hit the Commit button right away as we did with the Bridge Domain. Let's explore the power of transactions and dry runs, by clicking the Add to Transaction button and stage our change into the transaction basket.</p> Solution <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: BridgeInterface\nmetadata:\n  name: client11-bridge-domain-300\n  namespace: eda\nspec:\n  description: Provides a logical connection from client11 to the bridge domain using VLAN ID 300\n  ###### WARNING ######\n  # this name should match the name of the bridge domain created earlier\n  #####################\n  bridgeDomain: bridge-domain-vlan300\n  vlanID: '300'\n  interface: leaf11-client11\n</code></pre> <p>Learn more about Transactions and Dry Run functionality.</p> <p>Use the Dry Run functionality in EDA to check what would change if we were to commit our Bridge Interface.</p> <p>As shown in the video snippet above, you can check the diffs that the particular transaction would emit, and there you have a chance to see what node-specific configs would be pushed to which nodes if we were to commit our transaction.</p> <p>The Dry Run functionality does not touch the network elements in any way. All the potential change sets are computed by EDA. Safe and fast.</p> <p>The change set in the diff view should indicate that a subinterface with vlan-id is created on the <code>leaf11</code> switch as well as the network instance of type <code>mac-vrf</code> that this subinterface is connected to.</p> <p>Create the Bridge Interface targeting <code>leaf13</code> node as well, to attach the second client to the bridge domain before proceeding further.</p>"},{"location":"eda/beginner/bridge-domains.html#resource-status","title":"Resource status","text":"<p>You should be able to see the Bridge Interface status reflected in the GUI. To see the status of the configured object in EDA you can use the info icon or double click on the created resource to open up the view mode.</p> <p>You can also navigate to your bridge domain, and find out which leaf nodes are now participating in the service.</p> <p></p>"},{"location":"eda/beginner/bridge-domains.html#testing-the-connectivity","title":"Testing the connectivity","text":"<p>With Bridge Domain and two Bridge Interfaces committed to the fabric, you should now have IP connectivity between your two clients! Login to one of the clients participating in the layer-2 service, and try to ping the IP of the other one!</p> client-11client-13 <p>Connect to the server and then SSH into the client</p> <pre><code>ssh admin@clab-srexperts-client11\n</code></pre> <p>Once in the shell, ping client13:</p> <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.13\nPING 10.30.0.13 (10.30.0.13) 56(84) bytes of data.\n64 bytes from 10.30.0.13: icmp_seq=1 ttl=64 time=3.13 ms\n\n--- 10.30.0.13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 3.128/3.128/3.128/0.000 ms\n</code></pre> <p>And with IPv6:</p> <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::13\nPING fd00:fdfd:0:3000::13(fd00:fdfd:0:3000::13) 56 data bytes\n64 bytes from fd00:fdfd:0:3000::13: icmp_seq=1 ttl=64 time=1.92 ms\n\n--- fd00:fdfd:0:3000::13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 1.915/1.915/1.915/0.000 ms\n</code></pre> <p>Connect to the server and then SSH into the client</p> <pre><code>ssh admin@clab-srexperts-client13\n</code></pre> <p>Once in the shell, ping client11:</p> <pre><code>[*]\u2500[client13]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.11\nPING 10.30.0.11 (10.30.0.11) 56(84) bytes of data.\n64 bytes from 10.30.0.11: icmp_seq=1 ttl=64 time=0.779 ms\n\n--- 10.30.0.11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.779/0.779/0.779/0.000 ms\n</code></pre> <p>And with IPv6:</p> <pre><code>[*]\u2500[client13]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::11\nPING fd00:fdfd:0:3000::11(fd00:fdfd:0:3000::11) 56 data bytes\n64 bytes from fd00:fdfd:0:3000::11: icmp_seq=1 ttl=64 time=0.841 ms\n\n--- fd00:fdfd:0:3000::11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.841/0.841/0.841/0.000 ms\n</code></pre> <p>Beautiful, we have configured the network connectivity in the overlay between clients 11 and 13 using EDA's Bridge Domain and Bridge Interface Resources. By the way, you can the same queries using EQL as we did at the beginning of this exercise to see the new bridge domain and interfaces present.</p>"},{"location":"eda/beginner/bridge-domains.html#using-labels","title":"Using labels","text":"<p>In the previous step, we have created a single bridge interface per (bridge-domain, interface, VLAN) combination. For dozens of services with hundreds of physical interfaces, this quickly becomes impractical. In this task, we'll take a look at label-based operations.</p> <p>Start off by deleting the bridge interfaces you have created so far (you can keep the bridge domain). You can remove the Bridge Interfaces one by one, or by selecting them in the grid view and bulk deleting via the  menu icon. After deleting the Bridge Interface objects feel free to run the EQL queries to ensure that the nodes were stripped off of the relevant configurations.</p> <p>Next up, find the two Interfaces <code>leaf11-client11</code> and <code>leaf13-client13</code> in the Interfaces menu under the Topology group and have a look at the labels metadata field: </p> <p>Each resource in EDA can have a number of labels, which can be used to select the resources. Want to know more about the labels - we have a dedicated exercise for it.</p> <p>A label consists of a label key and a label value and is often written in the form of <code>key=value</code> string. For example, let's imagine that our two clients - client11 and client13 - are VMware hypervisors. Then we might want to tag them with the <code>tenant-type=vmware-hv</code> label to provide this metadata information that we can act on later.</p> <p>You can edit the Interface resources one by one, or select them both and make use of the Bulk Edit edit unt</p> <p>To avoid issues with other exercises, don't delete any existing label by overriding their label key!</p> <p>After assigning your new label to both interfaces, the list should look as follows (notice the filter in the Labels column at the top of the grid):</p> <p></p>"},{"location":"eda/beginner/bridge-domains.html#vlan-resource","title":"VLAN resource","text":"<p>Now that both interfaces have been assigned a common label, any EDA application can select them based on the tag. If before we had to create two instances of Bridge Interface for each interface/vlab/bridge-domain triplet, now we can optimize the workflow by using a different EDA resource - the VLAN resource.</p> <p>The VLAN resource, in contrast to the Bridge Interface, selects the interfaces based on the label selector, and does not allow you to individually pick an interface. It provides a way to connect the customer-facing interfaces to the bridge domain in a bulk mode. And this is exactly what you are tasked with, even though your fabric only has two clients, you can imagine running real fabric with hundreds or thousands VMs that ought to be interconnected via the overlay network service.</p> <p>Select the VLANs application under the Services category in the sidebar and open the creation window for your first VLAN resource. When filling the the resource form, focus on:</p> <ul> <li>A name for your VLAN so you can easily recognize it later</li> <li>An optional description</li> <li>A reference to the bridge domain you created earlier</li> <li>A label in the <code>Interface Selector</code> section of the spec that you assigned to both client interfaces. This field does not auto-complete yet, so you need to manually enter the label. Follow the pattern <code>{key}={value}</code> and type in the label you assigned to the interfaces in the previous step.</li> <li>The VLAN ID you discovered at the start of this exercise. Note: replace the \"pool\" value from the field (which indicates that EDA should choose a VLAN from the allocation pool automatically) with the ID you discovered earlier.</li> </ul> <p>After filling out the required fields, feel free to run a Dry Run and ensure that you see configuration changes aimed at both leaf switches and matching the configuration you've seen when manually added the Bridge Interfaces.</p> <p>If everything was configured correctly and committed, you should now be able to see the status of both interfaces in your VLAN object.</p> Solution <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: VLAN\nmetadata:\n  name: bridge-domain-vlan300\n  namespace: eda\nspec:\n  ###### WARNING ######\n  # this name should match the name of the bridge domain created earlier\n  #####################\n  bridgeDomain: bridge-domain-vlan300\n  description: &gt;-\n    This object creates a subinterface for each port assigned to label\n    \"tenant-type=vmware-hv\"\n  interfaceSelector:\n    - tenant-type=vmware-hv\n  vlanID: '300'\n</code></pre>"},{"location":"eda/beginner/bridge-domains.html#test-the-connectivity","title":"Test the connectivity","text":"<p>To ensure that everything was configured correctly, re-check the connectivity between both clients</p> client-11client-13 <p>Connect to the server and then SSH into the client</p> <pre><code>ssh admin@clab-srexperts-client11\n</code></pre> <p>Once in the shell, ping client13:</p> <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.13\nPING 10.30.0.13 (10.30.0.13) 56(84) bytes of data.\n64 bytes from 10.30.0.13: icmp_seq=1 ttl=64 time=3.13 ms\n\n--- 10.30.0.13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 3.128/3.128/3.128/0.000 ms\n</code></pre> <p>And with IPv6:</p> <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::13\nPING fd00:fdfd:0:3000::13(fd00:fdfd:0:3000::13) 56 data bytes\n64 bytes from fd00:fdfd:0:3000::13: icmp_seq=1 ttl=64 time=1.92 ms\n\n--- fd00:fdfd:0:3000::13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 1.915/1.915/1.915/0.000 ms\n</code></pre> <p>Connect to the server and then SSH into the client</p> <pre><code>ssh admin@clab-srexperts-client13\n</code></pre> <p>Once in the shell, ping client11:</p> <pre><code>[*]\u2500[client13]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.11\nPING 10.30.0.11 (10.30.0.11) 56(84) bytes of data.\n64 bytes from 10.30.0.11: icmp_seq=1 ttl=64 time=0.779 ms\n\n--- 10.30.0.11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.779/0.779/0.779/0.000 ms\n</code></pre> <p>And with IPv6:</p> <pre><code>[*]\u2500[client13]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::11\nPING fd00:fdfd:0:3000::11(fd00:fdfd:0:3000::11) 56 data bytes\n64 bytes from fd00:fdfd:0:3000::11: icmp_seq=1 ttl=64 time=0.841 ms\n\n--- fd00:fdfd:0:3000::11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.841/0.841/0.841/0.000 ms\n</code></pre> <p>Great job completing the Bridge Domains exercise! You've successfully:</p> <ul> <li>Created layer-2 connectivity between client11 and client13 using EDA's Bridge Domain resources</li> <li>Learned how to configure Bridge Interfaces to connect physical interfaces to virtual networks</li> <li>Mastered the use of EDA's transaction and dry run capabilities to preview configuration changes</li> <li>Discovered the power of label-based operations to efficiently manage multiple interfaces</li> <li>Implemented VLAN resources to streamline the configuration process using interface selectors</li> </ul> <p>Your work has established a functional layer-2 network service that allows both IPv4 and IPv6 communication between the clients. This foundation in EDA's declarative approach to network configuration will serve you well as you progress to more advanced topics like layer-3 connectivity with routers and virtual networks.</p> <p>Ready for the next challenge? Continue to Part 2: Routers to build on what you've learned!</p> <ol> <li> <p>If you want to learn more about transactions, checkout transactions section of the Declarative Intents exercise.\u00a0\u21a9</p> </li> </ol>"},{"location":"eda/beginner/configlets.html","title":"Configlets","text":"Short Description Using EDA Configlets to configure an NTP server Difficulty Beginner Topology Nodes  leaf11-13,  spine11-12 <p>As we established in the Declarative Intents exercise, EDA intents define the desired state of a given service, protocol, deployment or in general any component of a target system. An application developer, be it Nokia or a 3<sup>rd</sup>-party, can create resources that declaratively define a particular aspect of a target element. But clearly, the development of EDA apps happens in stages, and not everything on a target node may already have a corresponding EDA App that automates the desired state.</p> <p>In these cases where the desired state cannot be expressed using EDA intents alone it would be great to have a way to provision a user-defined configuration on a target node. This is what Configlets are for!</p>"},{"location":"eda/beginner/configlets.html#objective","title":"Objective","text":"<p>Your task is to configure an new gRPC server on all switches in your fabric. Since there is not EDA App that allows to configure the gRPC server you will have to use the Configlet and provide the configuration yourself.</p>"},{"location":"eda/beginner/configlets.html#technology-explanation","title":"Technology explanation","text":"<p>The CConfiglets resource located in the   CONFIGURATION category is a low level resource that allows a user to define the configuration in the JSON format that will be applied to the target node at a defined path. It is meant to be a stop-gap solution for configuration regions or objects that are not covered by EDA Apps.</p> <p>The benefits of Configlets:</p> <ul> <li>Full configuration coverage. By providing node-level config snippets you can configure the darkest corners of a supported network OS.</li> </ul> <p>But the drawbacks are very much noticeable:</p> <ul> <li>No abstraction. You provide the config in the node-level JSON format, so it can get large very quickly.</li> <li>No vendor-agnosticism. You have to know the exact configuration format of the target node, if you have multiple network OSes that you want to cover with a Configlet resource, you should specify the same config twice in two different native OS configurations.</li> <li>No state associated with the created object. Your configlet is just a way to deliver the configuration to the node, but if this config resulted in a working service - you wouldn't know.</li> <li>Linking to other resources is not possible. You can't request an IP or refer to a created object. Just the raw config itself.</li> </ul> <p>A Configlet resource example looks like this:</p> <pre><code>apiVersion: config.eda.nokia.com/v1alpha1\nkind: Configlet\nmetadata:\n  name: my-configlet\n  namespace: eda\nspec:\n  endpointSelector:\n    - key=value\n  operatingSystem: srl # set to the EDA-supported OS\n  configs:\n    - path: .some.path{.name==\"new-name\"}\n      operation: Create\n      config: |-\n        {\n          \"name\": \"new-name\",\n          \"some-key\": \"some-value\",\n        }\n</code></pre> <p>It has the <code>endpointSelector</code> attribute that allows you to specify the target nodes using the label selection mechanism.</p> <p>The <code>operatingSystem</code> attribute specifies the target network OS, and you can see that you can only have one OS per resource, which proves that you need to create multiple resources if you want to cover multiple OSes.</p> <p>The <code>configs</code> list allows to specify multiple configurations for the same target node. Each config snippet has a <code>path</code> where the <code>config</code> blob will be inserted, and an <code>operation</code> that specifies the action to be performed on the target node.</p>"},{"location":"eda/beginner/configlets.html#tasks","title":"Tasks","text":"<p>See Access Details if you need a reminder on how to access the nodes in the topology.</p> <p>Your task is to create a new gRPC server on all switches in your fabric. The gRPC server should be named <code>hackathon-grpc</code> and run over port <code>55555</code>; it should have gNMI service enabled.</p> <p>Since there is no EDA app yet to create the gRPC server, you will have to use a Configlet resource to achieve this.</p>"},{"location":"eda/beginner/configlets.html#configure-the-grpc-server-in-sr-linux","title":"Configure the gRPC server in SR Linux","text":"<p>With Configlets, you have to specify the configuration yourself in the resource body. That means you first need to obtain the config in JSON format, as this is the format accepted by the Configlet.</p> <p>The easiest way to get the config in the desired format is to create a candidate configuration for an object on the Network OS and then display it in the JSON format. SR Linux supports both candidates and JSON output, so what you need is to configure the gRPC server as per task description.</p> <p>You are encouraged to try to configure an gRPC server yourself if you feel like it, but as this is an EDA exercise and not an SR Linux exercise, here is the procedure how to do that:</p> <ol> <li>Login to any leaf switch in your fabric</li> <li>Enter in the candidate mode with <code>enter candidate</code> command</li> <li> <p>When in the candidate mode, paste the following snippet that configures the NTP server as per the requirements</p> <pre><code>system {\n  grpc-server hackathon-grpc {\n    admin-state enable\n    port 55555\n    services [\n        gnmi\n    ]\n  }\n}\n</code></pre> </li> <li> <p>Now enter in the context of a candidate config for the gRPC server:</p> <pre><code>--{ * candidate shared default }--[  ]--\nA:g15-leaf11# system grpc-server hackathon-grpc\n\n--{ * candidate shared default }--[ system grpc-server hackathon-grpc ]--\nA:g15-leaf11#\n</code></pre> </li> <li> <p>Since Configlet resource can insert the config at the specified path (provided in the JSONPath notation) we can display that path using the <code>pwc</code> command in SR Linux:</p> <pre><code>--{ * candidate shared default }--[ system grpc-server hackathon-grpc ]--\nA:g15-leaf11# pwc jspath\n.system.grpc-server{.name==\"hackathon-grpc\"}\n</code></pre> <p>The displayed path is what goes into the <code>.spec.configs[].path</code> field of the Configlet resource. Note it down.</p> </li> <li> <p>Now display the config under this path in JSON format:</p> <pre><code>--{ * candidate shared default }--[ system grpc-server hackathon-grpc ]--\nA:g15-leaf11# info | as json\n{\n  \"name\": \"hackathon-grpc\",\n  \"admin-state\": \"enable\",\n  \"port\": 55555,\n  \"services\": [\n    \"gnmi\"\n  ]\n}\n</code></pre> <p>Great, that's it.</p> </li> </ol>"},{"location":"eda/beginner/configlets.html#navigate-to-the-configlets-menu","title":"Navigate to the Configlets menu","text":"<p>Now that we have all information we need, let's create the Configlet resource.</p> <p>Look at the app menu in the left sidebar for CConfiglets in the   CONFIGURATION category.</p> <p></p> <p>When you click on the CConfiglets menu element, you get the list of existing Configlets. These were required for us to create the hackathon infra. As you can see, we used EDA to configure the fabric, and we had a use case for Configlets ourselves.</p>"},{"location":"eda/beginner/configlets.html#creating-a-new-configlet","title":"Creating a new configlet","text":"<p>Click on Create button and start filling in the form or YAML representation with the information you collected so far. Shouldn't be hard now.</p> <p>Maybe one hint for you, the Configlet allows you to list the nodes you wish to apply Configlet to manually using the <code>endpoints</code> field, or use the label selection via the <code>endpointsSelector</code> field. You can check what labels do your nodes have and pick the right ones to select leaf and spine switches.</p> <p>The solution can be found below in the YAML format if you want to have a shortcut, but better ask our experts for guidance. Still, you can copy this yaml object into the right column in the edit form to set the values to the right ones.</p> Solution <pre><code>apiVersion: config.eda.nokia.com/v1alpha1\nkind: Configlet\nmetadata:\n  name: hackathon-grpc-exercise\n  namespace: eda\n  labels:\n    role: exercise\nspec:\n  configs:\n    - config: |\n        {\n          \"name\": \"hackathon-grpc\",\n          \"admin-state\": \"enable\",\n          \"port\": 55555,\n          \"services\": [\n            \"gnmi\"\n          ]\n        }\n      operation: Create\n      path: .system.grpc-server{.name==\"hackathon-grpc\"}\n  endpointSelector:\n    - eda.nokia.com/role=leaf\n    - eda.nokia.com/role=spine\n  operatingSystem: srl\n</code></pre>"},{"location":"eda/beginner/configlets.html#check-your-work","title":"Check your work","text":"<p>If you have used the Dry Run functionality, you have already seen the diff of your intended change. But if you committed right away, you always have a chance to open up the Transaction history and switch to the diffs view to explore them:</p>"},{"location":"eda/beginner/configlets.html#summary","title":"Summary","text":"<p>In this exercise, you learned how to use EDA Configlets to configure network elements when there isn't a dedicated EDA App available for your specific configuration needs. You've successfully:</p> <ol> <li>Created a Configlet resource to configure a gRPC server on all switches in your fabric</li> <li>Learned how to extract the JSON path and configuration in JSON from SR Linux</li> <li>Applied the configuration using label-based selection to target specific nodes</li> </ol> <p>Configlets serve as a powerful stop-gap solution when you need to configure aspects of your network that aren't yet covered by EDA Apps. While they lack the abstraction, vendor-agnosticism, and state awareness of proper EDA intents, they provide complete configuration coverage by allowing you to specify node-level configuration snippets directly.</p> <p>Remember that Configlets should be used judiciously - they're best suited for temporary solutions until proper EDA Apps become available for your configuration needs. The ideal approach is to use declarative intents whenever possible, falling back to Configlets only when necessary.</p>"},{"location":"eda/beginner/declarative-intents.html","title":"Declarative Abstracted Intents","text":""},{"location":"eda/beginner/declarative-intents.html#declarative-abstracted-intents","title":"Declarative Abstracted Intents","text":"Short Description Declarative Abstracted Intents is the main EDA concept and it is used to define the behavior of a resource. Difficulty Beginner Topology Nodes leaf11, leaf12, leaf13, spine11, spine12 Tools used EDA UI <p>The EDA framework was built around the core concepts of the declarative abstracted intents, event sourcing, loose coupling and transactions which set EDA aside from other traditional network automation systems.</p> <p>While many existing network automation frameworks still leverage the imperative configuration paradigm and state polling, we believe that the future of a reliable network automation lies in the event-based, declarative space.</p>"},{"location":"eda/beginner/declarative-intents.html#objective","title":"Objective","text":"<p>The goal of this exercise is to introduce you to the main EDA concepts such as declarative resource model, label-based coupling and transactions. By completing the set of tasks you will get a good understanding of the base EDA principles and explore the novel features of configuration management with declarative abstracted intents.</p> <p>No matter if you're coming from a traditional network engineering background, or you're a seasoned network automation engineer, we believe you will find something new in the way EDA-based network automation is done.</p>"},{"location":"eda/beginner/declarative-intents.html#technology-explanation","title":"Technology explanation","text":"<p>This exercise is titled Declarative Abstracted Intents as it is one of the main EDA concepts that enables the next-gen network automation. Let's dissect this term and explore what it means:</p> <ul> <li>The somewhat overloaded intent term refers to a user's input to the EDA automation system. Typically it is provided in the form of a configuration snippet done in one of the serializable data formats such as YAML, JSON, XML, etc.</li> <li> <p>The declarative part of the intent refers to a declarative configuration paradigm that prescribes that the input to the system should say what should be done, not how to do it.</p> <p>For example, compare the declarative and imperative forms of the same intent of configuring two interfaces on a network device:</p> declarativeimperative <pre><code>interfaces:\n  ethernet-1-1:\n    description: \"First interface\"\n  ethernet-1-2:\n    description: \"Second interface\"\n</code></pre> <pre><code>enter candidate\nset / interface ethernet-1/1 description \"First interface\"\nset / interface ethernet-1/2 description \"Second interface\"\ncommit now\n</code></pre> <p>The declarative form says what needs to be configured and leaving the \"how\" to the system, while the imperative form also needs to specify how to do it.</p> </li> <li> <p>The abstracted part of the intent serves two main purposes:</p> <ul> <li>simplify the intent by abstracting away the details of the network device or technology.</li> <li>make the intent vendor-agnostic, so that the same input can be used with many vendor devices.</li> </ul> </li> </ul>"},{"location":"eda/beginner/declarative-intents.html#eda-resources","title":"EDA Resources","text":"<p>In EDA, the declarative abstracted intents are implemented as Resources. Here is an example of the EDA Interface Resource that captures the declarative abstracted intent of configuring a physical interface on a network device:</p> <pre><code>apiVersion: interfaces.eda.nokia.com/v1alpha1\nkind: Interface\nmetadata:\n  name: leaf13-ethernet-1-49\n  namespace: eda\nspec:\n  description: inter-switch link to spine11\n  enabled: true\n</code></pre> <p>Observant readers will immediately notice that this EDA Resource is modeled after the Kubernetes Resource Model, which is a declarative model that describes the interfaces in Kubernetes.</p> <p>You see how this resource has the declarative and abstracted parts of the intent?</p>"},{"location":"eda/beginner/declarative-intents.html#loose-coupling","title":"Loose Coupling","text":"<p>Another important concept in EDA is loose coupling that is enabled by the use of Labels.</p> <p>The concept of a loose coupling says that the resources may be loosely coupled between each other. Instead of explicitly saying that the Resource-A depends on Resource-B and Resource-C, we can label the Resource-B and Resource-C with a label <code>BC</code> and in the Resource-A we can use the <code>BC</code> label to find the resources to act upon.</p> <p>The power of the loose coupling is that it allows for dynamic dependencies between the resources. If we suddenly add another resource labeled with <code>BC</code> label, the Resource-A will automatically pick up the new resource and act on it. Through the hackathon exercise you will see how this concept is used to a great effect.</p>"},{"location":"eda/beginner/declarative-intents.html#transactions","title":"Transactions","text":"<p>The holy grail of worry-free operations is atomic transactions. The worst thing that can happen during the automated configuration provisioning is a partially applied configuration due to not all nodes accepting the configuration.</p> <p>EDA solves this problem by adding a concept of Transactions. The user-submitted declarative intents are all transacted together and either all of them are applied by the nodes or all of them will be rolled back.</p> <p>The transaction-based model also allows for Dry Runs - seeing what changes will be rolled out to your network before actually applying them.</p>"},{"location":"eda/beginner/declarative-intents.html#eda-ui","title":"EDA UI","text":"<p>Every hackathon group has access to an EDA instance and its interfaces. In this exercise you will be using EDA Web UI that you can reach over public Internet by navigating your browser to https://{group-ID}.srexperts.net:9443</p> <p>Use the provided leaflet to get the authentication details and Internet access instructions.</p> <p>After a successful login you will see the main EDA UI page:</p> <p></p> <p>Clicking on the Menu icon toggles the side menu:</p> <p></p> <p>While you don't have a visual memory of the resource groups icons, using the side menu in the expanded view will help you navigate the UI. Also you will find the search bar at the top quite handy.</p>"},{"location":"eda/beginner/declarative-intents.html#tasks","title":"Tasks","text":"<p>Tired of theory? Time to back it up with practical challenges and learn the details by doing.</p>"},{"location":"eda/beginner/declarative-intents.html#adding-an-interface","title":"Adding an Interface","text":"<p>As a warmup, you are tasked with enabling additional interfaces on the leaf switches. According to the lab diagram, EDA manages <code>leaf11</code>, <code>leaf12</code>, <code>leaf13</code> nodes.</p> <p>These nodes already have a number of interfaces configured, let's find out what they are. Since EDA acts as a source of truth for all configuration on the managed nodes, we should see the list of already configured interfaces in the UI.</p> <p>In the left sidebar scroll down to the Topology resource group and select Interfaces resource. A table view with the list of interfaces configured in the system will appear, where we can filter the interfaces which name starts with <code>l</code> character that will narrow down the list to the interfaces.</p> <p>Remember, that our leaf switches are named <code>leaf11</code>, <code>leaf12</code>, <code>leaf13</code>. So all of them have <code>leaf1</code> as a prefix as well as the lag interface configured between the three switches called <code>lag1</code>.</p> <p></p> <p>We have selected the Interface resources on leaf switches that point to the client devices, and you can match these resources to the topology information:</p> EDA Managed nodes <p>Based on this information we can see that our leaf switches have interfaces <code>1</code>, <code>2</code>, <code>3</code>, <code>49</code> and <code>50</code> already configured either in the direction to the client or spine devices. So let's configure some non-connected interface on the leaf switches - for example, interface <code>ethernet-1/5</code>.</p>"},{"location":"eda/beginner/declarative-intents.html#query-interfaces-with-eql","title":"Query Interfaces with EQL","text":"<p>Before you proceed with creating the <code>ethernet-1/5</code> interface, let's query the interfaces on the leaf switches to make sure that there are no interfaces with the same name already configured.</p> <p>Typically you would connect to the leaf switches and run <code>show</code> commands, or use a custom script that does the same in a more automated way. But there is a better way to interrogate the network devices...</p> <p>EDA comes with a built-in network-wide query engine that allows you to query the network devices in a performant and scalable way. Using the sidebar navigation, go to the Queries page:</p> <p></p> <p>And paste the following in the EQL<sup>1</sup> Query input field:</p> <p>Warning</p> <p>In the query below, replace <code>g1</code> in the node name list with the group ID you have been assigned to.</p> <p>For example, if your group ID is 32, then the list should look like:</p> <pre><code>[ \"g32-leaf11\",\"g32-leaf12\",\"g32-leaf13\" ]\n</code></pre> <pre><code>.namespace.node.srl.interface fields [admin-state] where (.namespace.node.name in [ \"g1-leaf11\",\"g1-leaf12\",\"g1-leaf13\" ] and .namespace.node.srl.interface.name = \"ethernet-1/5\")\n</code></pre> <p></p> <p>While this exercise is not about EQL specifically, it is a good opportunity to leverage the power of the query engine to understand the state of the network.</p> <p>You can see that all three leaves have interfaces <code>ethernet-1/5</code> in <code>admin-state=disable</code>. So you are clear to configure those interfaces!</p>"},{"location":"eda/beginner/declarative-intents.html#interface-resource-form","title":"Interface Resource Form","text":"<p>Go to the Topology -&gt; Interfaces menu item where before we looked at the configured interfaces and click the Create button to open the resource creation form. You can also use the search bar and filter for Interface:</p> <p></p> <p>The creation form has the following important panels:</p> <p></p> <p>The form has three distinct sections, as per the screenshot above, and as a user you will be using the form or YAML view to configure the resource and use the navigation to quickly navigate to the relevant fields.</p> <p>You can use the form and YAML views interchangeably, as every change made in one view will be reflected in the other.</p>"},{"location":"eda/beginner/declarative-intents.html#choosing-the-fields","title":"Choosing the Fields","text":"<p>The form has quite some number of fields, but not all of them are relevant to our task or required to be filled in. You must provide the following fields:</p> <ol> <li>Metadata \u2192 Name: the name of the interface resource.     This is not the name of the interface that you will see in the node's configuration, but a name of the Interface resource that will be created in EDA.     For example, since we are tasked to create an interface ethernet-1/5 on all leaf switches, for leaf11 we might want to name the interface resource as <code>leaf11-ethernet-1-5</code>.</li> <li>Specification \u2192 Members: a list of the port name + node name combinations that identify what ports to configure on which nodes</li> </ol>"},{"location":"eda/beginner/declarative-intents.html#interface-members","title":"Interface Members","text":"<p>If you chose to configure the interface via the form view, you have to click + Add button to invoke another modal window where interface members are configured.</p> <p>You will have to provide the Interface name in the normalized format, where spaces and <code>/</code> are replaced with <code>-</code>. For instance, <code>ethernet-1/5</code> should become <code>ethernet-1-5</code>.</p> <p>And after the interface name is sorted, you should provide the node name using the drop down menu.</p> <p></p> <p>When to use multiple members?</p> <p>You might have an urge to configure ethernet-1/5 port on multiple nodes by adding them as members, but this would be a mistake.</p> <p>The members interface list is used for LAG interfaces, the distinct interfaces should be configured with separate Interface resources.</p> <p>This means, that if you are configuring <code>interface-1/5</code> on <code>leaf11</code>, then your Interface resource may be named as <code>leaf11-ethernet-1-5</code>.</p> <p>When you fill in the required fields (name and members), you will see that the two buttons in the bottom right corner of the form will become active, allowing you to directly commit the changes or to add them to a transaction.</p> <p>Feel free to choose your path, but adding all the Interface resources you want to create to a single transaction is a good idea, since we want all the resources to be created in a single transaction.</p> <p>Continue adding other interfaces to the transaction bucket, you should have three interface resources in total.</p>"},{"location":"eda/beginner/declarative-intents.html#dry-run","title":"Dry Run","text":"<p>Once you added three interfaces to the transaction bucket you can Dry Run the transaction and see what your intended changes would look like.</p> <p></p> <p>Executing the Dry Run will either succeed or fail, with an icon indicating the result. The interesting part is checking the diffs</p> <p></p> <p>Looking at the diffs view should give you a precise idea of what changes will be made to the configuration:</p> <p></p> <p>The top three menu items in the left side bar will display configuration diff in the native config of the Network OS the changes will be applied to. In our case, it is SR Linux config that we are looking at and we see how all three nodes get additions of the <code>ethernet-1/5</code> interface!</p>"},{"location":"eda/beginner/declarative-intents.html#commit-transaction","title":"Commit Transaction","text":"<p>Remember, that we are browsing the diff of the Dry Run operations, none of the proposed changes have been applied to the nodes yet, they all have been deduced based on the known state kept in the EDA database.</p> <p>Since the change is looking good you can proceed with committing the configuration and applying the changes to the nodes by closing the Diff view and clicking on the Commit button.</p> <p>In a moment you will see a confirmation that the transaction was committed successfully. Now you can repeat the EQL query and check the admin state of the <code>ethernet-1/5</code> interface on all three nodes. They all should be <code>enabled</code> now.</p>"},{"location":"eda/beginner/declarative-intents.html#configuring-ntp","title":"Configuring NTP","text":"<p>If you are a seasoned network automation engineer with YAML tattoos on your forearms, you might appreciate a more challenging task. Go on and configure the NTP client on all the nodes of your fabric!</p> <p>You will have to use a local NTP server running on <code>10.128.&lt;YOUR GROUP ID&gt;.1</code> and choose the management router as the VRF context in your intent.</p> <ol> <li> <p>EQL stands for EDA Query Language that is resembles other query languages like PromQL, Jira QL and so on.\u00a0\u21a9</p> </li> </ol>"},{"location":"eda/beginner/eda-query-language.html","title":"EDA Query Language","text":""},{"location":"eda/beginner/eda-query-language.html#eda-query-language","title":"EDA Query Language","text":"Short Description The EDA Query Language (EQL) enables real-time querying across the entire fleet of the managed nodes and EDB data. Difficulty Beginner Topology Nodes leaf11, leaf12, leaf13, spine11, spine12 Tools used EDA UI <p>The EDA Query Language (EQL) allows real-time access to any YANG path on any managed elements network-wide, or any resource published in the EDA in-memory Database (EDB). It delivers instant, streaming results ideal for troubleshooting and observability and can feed data to the EDA visualization dashboards or be streamed out to external consumers.</p>"},{"location":"eda/beginner/eda-query-language.html#objective","title":"Objective","text":"<p>The goal of this exercise is to introduce you to the The EDA Query Language (EQL) in which we will review the EQL concepts such as <code>Tables</code>, <code>Selectors</code> or <code>Filters</code>, and solve some real-world troubleshooting challenges. By completing a series of tasks, you\u2019ll gain a solid understanding of how to use EQL in your operations.</p>"},{"location":"eda/beginner/eda-query-language.html#technology-explanation","title":"Technology Explanation","text":""},{"location":"eda/beginner/eda-query-language.html#queries-page","title":"Queries page","text":"<p>The easiest way to run queries is right from the UI, in the Tools section, simply click <code>Queries</code>. You can also use the REST API or <code>edactl</code> command if you prefer.</p> <p></p> <p>The Queries UI consists of a query language selector and the query input fields. The query language selector allows to switch between the Natural Language and the EQL query language.</p> <p>As you might have guessed the Natural Language allows you to form a query using natural language, like \"How many BGP peers I have in my fabric?\". And if you prefer structured queries, EQL is your friend. It is a query language that supports operands, filters and selectors to create complex but precise queries.</p> <p>You will use both languages in the tasks we prepared for you.</p>"},{"location":"eda/beginner/eda-query-language.html#what-makes-up-a-query","title":"What Makes Up a Query?","text":"<p>A query in EQL is composed of several optional components, with only the first one being required:</p> <ul> <li> <p><code>Table</code> (required): The data source you're querying. Example: <code>.namespace.node.srl.interface</code></p> </li> <li> <p><code>Selector</code> (<code>fields</code> keyword): Specifies which fields to return, optionally applying functions to them. Example: <code>.namespace.node.srl.interface fields [oper-state, admin-state]</code></p> </li> <li> <p><code>Filter</code> (<code>where</code> keyword): Defines conditions for filtering results, using expressions within parentheses. Example: <code>.namespace.node.srl.interface where (admin-state = \"disable\" and .node.name = \"leaf1\")</code></p> </li> <li> <p><code>Sort</code> (<code>order by</code> keyword): Determines how the data should be ordered before being returned. Example: <code>.namespace.node.srl.platform.control.process order by [memory-usage descending]</code></p> </li> <li> <p><code>Limit</code> (<code>limit</code> keyword): Restricts the number of returned results. Example: <code>.namespace.node.srl.interface limit 10</code></p> </li> <li> <p><code>Frequency</code> (<code>delta</code> or <code>sample</code> keywords): Controls how often updates are returned, establishing a limit in the frequency of updates. Example: <code>.namespace.node.srl.interface delta milliseconds 1000</code>, or <code>sample milliseconds 1000</code> for updates at regular intervals, regardless of change.</p> </li> </ul> <p>If you fancy a deeper dive into the query components, continue reading; else, jump straight to the tasks.</p>"},{"location":"eda/beginner/eda-query-language.html#table","title":"Table","text":"<p>A Table is defined using JSPath notation. Table boundaries occur at each list or container element within a target node schema, or within containers/lists exposed by EDA applications.</p> <p>In simpler terms, each node in the JSPath hierarchy represents a distinct table. For example:</p> <ul> <li> <p><code>.namespace.node</code> is a table</p> </li> <li> <p><code>.namespace.node.srl</code> is another table</p> </li> <li> <p><code>.namespace.node.srl.interface</code> is yet another table</p> </li> </ul> <p>To specify a table, you use a complete JSPath expression without including keys. Example: <code>.namespace.node.srl.interface.subinterface</code> refers to the subinterface table.</p>"},{"location":"eda/beginner/eda-query-language.html#selector-fields","title":"Selector \u00b7 <code>fields</code>","text":"<p>A Selector is specified using the <code>fields</code> keyword. It defines an array of fields to be returned from the table, and may also include functions applied to those fields.</p> <p>All selected fields must exist in the table being queried, otherwise the query will fail.</p> <p>Only the fields explicitly listed will be returned. If no fields are specified, all fields from the table are returned by default.</p> <p>The <code>fields</code> keyword must come before any <code>where</code> or <code>order by</code> clauses.</p> <p>Example: <code>.namespace.node.srl.interface fields [admin-state, description] order by [oper-state ascending natural]</code></p> <p>You can also use functions within the fields array for evaluation and aggregation:</p> <p><code>average()</code> \u2014 Returns the average value of a field over time.</p> <p><code>count()</code> \u2014 Returns the number of unique matches for a given filter.</p> <p><code>sum()</code> \u2014 Calculates the sum of values for a specific field.</p> <p>These functions are useful for generating insights or summaries within your query results.</p> <p>Example: <code>.namespace.node.srl.interface fields [count(oper-state)] where (oper-state = \"up\")</code></p>"},{"location":"eda/beginner/eda-query-language.html#filter-where","title":"Filter \u00b7 <code>where</code>","text":"<p>A Filter defines criteria for narrowing down query results and is specified using the where keyword. The following rules apply:</p> <ul> <li>A filter is composed of an ordered sequence of fields, operators, values, and  keywords.</li> <li>Keywords like <code>and</code> and <code>or</code> are case-insensitive\u2014both <code>AND</code> and <code>and</code> are valid.</li> </ul> <p>Supported Operators:</p> <ul> <li>Comparison: <code>=</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;</code></li> <li>Logical: <code>and</code>, <code>or</code>, and parentheses <code>()</code> for grouping</li> <li> <p>Membership:</p> <ul> <li><code>in</code>: checks if a field's value is in a list of values</li> <li><code>not in</code>: checks if a field's value is not in a list</li> </ul> </li> </ul> <p>Field names are written without quotes, while values are quoted if they are strings and left unquoted if they are integers. Example: <code>.namespace.node.srl.interface where ((oper-state = \"up\") and (ifindex = 49150))</code></p> <p>As you can see, from the previous example, Filters can combine multiple conditions using parentheses and logical operators.</p> <p>Warning</p> <p>Even a single condition must be enclosed in parentheses: <code>.namespace.node.srl.interface where (oper-state = \"up\")</code></p>"},{"location":"eda/beginner/eda-query-language.html#sort-order-by","title":"Sort \u00b7 <code>order by</code>","text":"<p>A Sort determines the order in which results are returned, rather than filtering which data is selected. It is specified using the <code>order by</code> keyword.</p> <p>You can include one order by clause per query. Its value is an array of fields, sorting directions, and (optionally) sorting algorithms, evaluated in the order provided.</p> <p>Example: <code>.namespace.node.srl.interface order by [oper-state ascending natural]</code></p> <p>The second element specifies the sort direction: <code>ascending</code> or <code>descending</code>.</p> <p>The third element is optional and currently supports only <code>natural</code> as a sorting algorithm.</p>"},{"location":"eda/beginner/eda-query-language.html#limit-limit","title":"Limit \u00b7 <code>limit</code>","text":"<p>The limit keyword restricts the number of results returned by a query. It is applied after all other operations, such as sorting.</p> <p><code>limit</code> takes a single integer value. When combined with order by, it allows you to retrieve the top N or bottom N results, depending on the sort direction.</p> <p>The valid range for limit is <code>1 to 1000</code>. Values outside this range will result in an error.</p> <p>Example: <code>.namespace.node.srl.interface order by [mtu descending] limit 10</code></p>"},{"location":"eda/beginner/eda-query-language.html#frequency-deltasample","title":"Frequency \u00b7 <code>delta</code>/<code>sample</code>","text":"<p>The <code>delta</code> keyword controls how frequently query results are updated. It takes two arguments: a unit ( milliseconds) and a value representing the limit of the response rate.</p> <p>For example: <code>.namespace.node.srl.interface.traffic-rate where (in-bps != 0) delta seconds 1</code> This means the client will receive updates no more than once per second.</p> <p>Use delta to avoid overloading the client with rapid updates and to fine-tune the refresh rate for your use case.</p>"},{"location":"eda/beginner/eda-query-language.html#navigating-the-eda-database","title":"Navigating the EDA Database","text":"<p>After we covered a lot of theory on the query components, the next step is identifying where the relevant data resides within the EDB. The following table lists some most relevant tables/paths:</p> <p>EDA Queries Cheatsheet</p> Path Description .cluster Holds information about cluster metrics and config/state engine. For example, we can get k8s pod status with <code>.cluster.apps.platform.metrics.namespace.pod</code> or we can get execution metrics of the state engine with <code>.cluster.state-engine.v1.script</code> .namespace The root path for all our namespaced resources. .namespace.apps Access config and state information published by the EDA Apps .namespace.alarms All the alarms raised by nodes are written in this table. For example, we can get current alarms with <code>.namespace.alarms.v1.current-alarm</code> or past ones with <code>.namespace.alarms.v1.alarm.history</code> .namespace.allocations Access EDA allocations pools information (irb indexes, ip pools, bgp asn numbers\u2026). We can retrieve the information with <code>.namespace.allocations.v1.template.instance</code> .namespace.node Get real time access to node's config and state. For example, to get all state info about the SR Linux interfaces - <code>.namespace.node.srl.interface.subinterface</code> or display the statistics of all the interfaces with <code>.namespace.node.srl.interface.statistics</code>To change the network OS, simply replace the operating system name, e.g. <code>.namespace.node.sros</code> for Nokia SR OS, or <code>eos</code> for Arista EOS. .namespace.resources A table that contains the state and specifications of all EDA Custom Resources. For example, we can check the health of our Fabric with <code>.namespace.resources.cr.fabrics_eda_nokia_com.v1alpha1.fabric fields [ status.health ]</code> or see the list of BridgeDomains configured in our Fabric with <code>.namespace.resources.cr.services_eda_nokia_com.v1.bridgedomain</code> .namespace.topologies.topology Everything related to the Topologies tool in EDA dashboard goes here"},{"location":"eda/beginner/eda-query-language.html#tasks","title":"Tasks","text":"<p>Done with the theory, let's put things into practice!</p> <p>Imagine this: it\u2019s 3:00 AM, and you\u2019re in the middle of a migration window, moving VMs from one server cluster to another. These servers are connected to multiple leaf switches via a Layer 2 EVPN service (mac-vrf = <code>macvrf1</code>). Based on your experience, you know that a good way to monitor the migration\u2019s progress is by tracking the total number of MAC addresses learned in the service, and closely watching a few specific MACs to see how they shift between switches.</p> <p>Typically you would do this by connecting to every switch and do <code>show</code> commands or have a script that will fetch the show commands and parse the output. With EDA Queries, we can do it centrally, in a fast, performant and always accurate way.</p>"},{"location":"eda/beginner/eda-query-language.html#task-1-query-mac-addresses-in-a-specific-mac-vrf-service","title":"Task 1: Query MAC addresses in a specific mac-vrf service","text":"<p>In this first exercise you have to perform a query that shows you all MAC addresses in the bridge table of the <code>macvrf1</code> deployed in your DC fabric. This service is already present in <code>leaf11</code>, <code>leaf12</code>, and <code>leaf13</code>.</p> Hints <p>The command we would need to execute in our SR Linux switches is: <code>show network-instance macvrf1 bridge-table mac-table all</code>.</p> <p>We need to filter to only show <code>macvrf1</code>, so we need to use the <code>where</code> keyword.</p> Solutions <p>The EQL for this is:</p> <pre><code>.namespace.node.srl.network-instance.bridge-table.mac-table.mac where(.namespace.node.srl.network-instance.name = \"macvrf1\")\n</code></pre>"},{"location":"eda/beginner/eda-query-language.html#natural-language","title":"Natural Language","text":"<p>Remember that Natural Language language selector? It allows you to phrase your queries, well, naturally. So instead of thinking what would the query look like to get all MACs in a certain bridge domain, you could've simply asked:</p> <pre><code>show me all macs in the macvrf1 bridge domain\n</code></pre> <p>You should get the same result, as what NQL does is translates the natural language to a EQL query and runs it. A perfect way to learn and refine future queries.</p>"},{"location":"eda/beginner/eda-query-language.html#task-2-select-specific-fields-to-be-displayed-in-mac-table","title":"Task 2: Select specific fields to be displayed in MAC table","text":"<p>Now that you\u2019ve retrieved the full list, refine your query to display only the essential details, such as the MAC address and the interfaces where each is learned.</p> Hints <p>You need to use the <code>fields</code> keyword. The field we are interested in is the <code>destination</code></p> Solutions <p>The EQL for this is:</p> <pre><code>.namespace.node.srl.network-instance.bridge-table.mac-table.mac fields [destination] where (.namespace.node.srl.network-instance.name = \"macvrf1\")\n</code></pre> <p>You can also try and use the NQL for this task.</p>"},{"location":"eda/beginner/eda-query-language.html#task-3-count-entries-in-mac-table","title":"Task 3: Count entries in MAC table","text":"<p>Now, you want to see if all the macs are there, and you know that in a stable condition you have 21 MACs in your mac-vrf. Count the macs in your mac-vrf.</p> Hints <p>You need to use the <code>count()</code> keyword to count the number of responses for a given EQL.</p> Solutions <p>The EQL for this is:</p> <pre><code>.namespace.node.srl.network-instance.bridge-table.mac-table.mac fields [count(destination)] where (.namespace.node.srl.network-instance.name = \"macvrf1\")\n</code></pre>"},{"location":"eda/beginner/eda-query-language.html#task-4-track-specific-macs-in-your-mac-vrf","title":"Task 4: Track specific MACs in your mac-vrf","text":"<p>And now, let's build a query to keep track of specific MAC addresses in our <code>macvrf1</code> service. Select any MAC address displayed in your Task 2 exercise and build a query that only displays that one.</p> Hints <p>We need to use parentheses <code>()</code> and <code>and</code> to group multiple terms</p> Solutions <p>The EQL for this is:</p> <pre><code>.namespace.node.srl.network-instance.bridge-table.mac-table.mac fields [destination] where ((.namespace.node.srl.network-instance.name = \"macvrf1\") and (address = \"AA:C1:AB:E0:66:72\"))\n</code></pre>"},{"location":"eda/beginner/eda-query-language.html#bonus-task-do-it-in-the-cli","title":"Bonus Task: do it in the cli","text":"<p>We can use the <code>edactl</code> command to perform all the different queries that we have tested. You just have to SSH to your own dedicated VM running the lab topology and type:</p> <p><code>edactl query 'your query here'</code></p> <p>You can optionally use the following Flags:</p> <ul> <li><code>-r &lt;value&gt;</code>: to set the max number of rows visible on the terminal (default 20)</li> <li><code>-s</code>: to stream query results</li> </ul>"},{"location":"eda/beginner/eda-query-language.html#summary","title":"Summary","text":"<p>This exercise introduces the EDA Query Language (EQL), a powerful tool for real-time querying across managed network elements and the EDA in-memory Database (EDB).</p> <p>You learned the key components that EQL consists of, such as:</p> <ul> <li>Tables: Data sources you're querying (e.g., .namespace.node.srl.interface)</li> <li>Selectors: Fields to return using the fields keyword</li> <li>Filters: Conditions for filtering results using the where keyword</li> <li>Sort: Ordering of results using order by</li> <li>Limit: Restricting number of results using limit</li> <li>Frequency: Controlling update frequency using delta or sample</li> </ul> <p>Practiced running the queries using two different query languages:</p> <ul> <li>EQL: Structured query language with precise syntax</li> <li>Natural Language: Alternative interface for forming queries in plain English</li> </ul> <p>And used <code>edactl</code> to run the queries in the CLI.</p>"},{"location":"eda/beginner/label-based-selection.html","title":"Label-based Selection","text":""},{"location":"eda/beginner/label-based-selection.html#label-based-selection","title":"Label-based Selection","text":"Short Description Loose coupling of resources delivers flexible relationships between resources.At the helm of this concept sits labeling mechanism that is widely used in microservices and container orchestration. Difficulty Beginner Topology Nodes leaf11, leaf12, leaf13, spine11, spine12 Tools used EDA UI <p>On a broader scale the relationship between the resources can either be tightly coupled or loosely coupled.</p> <p>The tight coupling binds the resources explicitly to each other, typically using a unique identifier. An example of a tight coupling all of you might have used in the past is an inventory system that lists the IP addresses of the devices that you target with your automation scripts. The tight coupling allows for a more deterministic selection of the target nodes your automation acts against, but it is less flexible and requires more effort to maintain.</p> <p>The loose coupling binds the resources implicitly to each other, typically using a concept of a label or tag. An example of a loose coupling would select a label as a target for your automation, and the objects that were having this tag would be the ones that your automation would act against. The loose coupling allows for flexible and dynamic target selection, making it easier to adapt to changes in the network topology and provide more cloud-native resource management.</p>"},{"location":"eda/beginner/label-based-selection.html#objective","title":"Objective","text":"<p>The goal of this exercise is to introduce you to the concept of loose coupling of resources and how it is achieved in EDA via the concept of labels. You will see how labels are first class citizen in EDA with every resource having an option of being tagged with one or more labels.</p>"},{"location":"eda/beginner/label-based-selection.html#technology-explanation","title":"Technology Explanation","text":"<p>The concept of label-based loose coupling is not new. You may have used it when managing resources in the cloud provider of your choice or with the security platforms where resource tags are used to group resources together. Overall, the concept of tags/labels is well known especially in the cloud-native domain where resources are managed at scale.</p> <p>From the technical perspective, labels are typically implemented as key/value pairs that are attached to a resource and become part of the resource's metadata. A resource with a label is often called labeled or tagged resource.</p> <p>A resource may have none, one or more labels attached to it. The automation system then can select resources using the label selectors and not by pointing to a unique resource identifier (IP or name). Due to the fact that labels are key/value pairs, they have to be uniquely keyed, for example having a set of labels like:</p> <ul> <li><code>nic-type=storage</code></li> <li><code>nic-type=100G</code></li> </ul> <p>is not valid, since the two labels have the same key <code>nic-type</code>. You should choose different keys for the labels.</p> <p>In the diagram below you see how EDA leverages labels to select resources for its intents. The EDA-managed nodes - leafs and spine elements, are labeled with a label that encodes the role of the device (e.g. <code>eda.nokia.com/role=spine</code> for the spine devices)</p> Label-based coupling <p>With the resource being uniformly labeled, EDA can select resources for its intents using the label selectors, instead of specifying the target nodes by their IP addresses or names.</p>"},{"location":"eda/beginner/label-based-selection.html#labeled-resources-in-eda","title":"Labeled resources in EDA","text":"<p>You will see labeled resources a lot in EDA, but probably the first time you get to see and interact with labels is when you look at the list of nodes managed by EDA.</p> <p>Note</p> <p>Labels are assigned by an operator or a system that creates the resource.</p> <p>Have one more look at the diagram above that depicts a leaf-spine topology managed by EDA and let's find this list of nodes in the EDA UI.</p> <p>When logged into the EDA UI you can find the list of nodes managed by EDA using the left side bar navigation and selecting Targets \u2192 Nodes menu.</p> <p></p> <p>You should see the familiar node names (we call these resources TopoNodes) as depicted in the diagram above and the associated metadata, specification and status. In the same table view you can find the Labels column that shows the labels attached to each node; they are collapsed under the <code>+5</code> icon, which means there are 5 labels attached to each node and there is no space to display them all in line.</p> <p>If you hover over this icon you should see the list of labels, but you can also select the Configuration View menu element at the end of each row to see the expanded view of the TopoNode resource:</p> <p></p> <p>In the configuration view labels are shown expanded, and we can see all five of them listed there, each carrying our some meaning:</p> <p></p> <p>For the selected <code>leaf13</code> node, the important label it has attached to it is:</p> <ul> <li><code>eda.nokia.com/role = leaf</code> - this label carries out the role of the node in the topology and has a key - <code>eda.nokia.com/role</code> and a value - <code>leaf</code>.</li> </ul> <p>When onboarding the nodes of the topology to EDA we manually assigned labels to each nodes to identify their role and make it possible for EDA to select the nodes for the intents based on these labels.</p>"},{"location":"eda/beginner/label-based-selection.html#tasks","title":"Tasks","text":"<p>You will find EDA both strict and loose coupling used in EDA. Often the same intent will offer you the choice of using either approach. In the following tasks you will be using label-based selection to select the resources for your intents as well as using strict coupling based on element names.</p>"},{"location":"eda/beginner/label-based-selection.html#configure-login-banner-on-a-single-element","title":"Configure Login Banner on a single element","text":"<p>Your first task is to configure a Login Banner on a single - <code>spine11</code> - element. You will find the Banners resource in the sidebar menu under the Site Profiles group.</p> <p>Don't know what a resource is? Check out the Declarative Intents exercise.</p> <p>Click the Create button to open the resource editor. In the specification section of the Banner resource you will find both strict and loose coupling options for you to choose:</p> <p></p> <p>Since you are tasked with configuring a Login Banner on a single spine element, choose the the option that will allow you to specify the target element by its name.</p> <p>After selecting the <code>spine11</code> element, commit your changes.</p>"},{"location":"eda/beginner/label-based-selection.html#verification","title":"Verification","text":"<p>Once the changes have been committed, you can verify the changes using the network-wide queries. EDA comes with a built-in network-wide query engine that allows you to query the network devices in a performant and scalable way. Using the sidebar navigation, go to the Queries resource and paste the following in the EQL<sup>1</sup> Query input field:</p> <pre><code>.namespace.node.srl.system.banner fields [ login-banner ] #(1)!\n</code></pre> <ol> <li>This query will return the value of the <code>/system/banner/login-banner</code> field from all SR Linux nodes managed by EDA.</li> </ol> <p>You should see only <code>spine11</code> feature the <code>login-banner</code> message, as other nodes shouldn't have been targeted by the Banner resource you have created.</p> <p></p>"},{"location":"eda/beginner/label-based-selection.html#configure-login-banner-on-multiple-elements","title":"Configure Login Banner on multiple elements","text":"<p>Now that you have configured a Login Banner on a single spine element using the strict coupling with a node name, your next task is to configure a Login Banner on all leaf nodes.</p> <p>You will use the loose coupling enabled by the labels to achieve that. Recall the labeling scheme we covered in the technology explanation section where all leaf nodes have the <code>eda.nokia.com/role=leaf</code> label.</p> <p>Go on and edit the Banner resource you created in the first task and add the Node Selector field with the label all leaf nodes have in common. After you added the Node Selector, add the change to the transaction and run the Dry Run to ensure that all three leaf nodes will be targeted with the same banner.</p> <p>Don't know how to use the Dry Run feature? Check out the Declarative Intents exercise first.</p> <ol> <li> <p>EQL stands for EDA Query Language that is resembles other query languages like PromQL, Jira QL and so on.\u00a0\u21a9</p> </li> </ol>"},{"location":"eda/beginner/notifications.html","title":"Notifications","text":""},{"location":"eda/beginner/notifications.html#notifications","title":"Notifications","text":"Short Description Delivering notifications from your EDA system to popular notification systems Difficulty Beginner Tools used EDA UI Topology Nodes  leaf1 References Notifier App documentation <p>Modern day data center management is far from only dealing with configuration provisioning. More so, the day2+ operations are what teams are dealing with most of the time. Things like monitoring, alarm management and notifications come to mind.</p> <p>EDA is not only the powerful configuration management platform, but is also no stranger to operations. It packs a powerful set of applications and integrations to simplify operations and extend the core set of capabilities.</p> <p>This exercise introduces you to the EDA Notifier application that allows an operator to create custom notifications based on the events registered by EDA and deliver them to popular notification and chat systems.</p>"},{"location":"eda/beginner/notifications.html#objective","title":"Objective","text":"<p>Our objective is to configure EDA in such a way that it can emit a notification when a certain event occurs. To be precise, let's have a goal of sending a notification when any physical interface on any switch in our fabric changes its operational status from UP to DOWN. We will work towards sending a message to the Discord group monitored by the operations team.</p> <p>In exercise we will learn the following:</p> <ol> <li>How to extend EDA core capabilities by installing applications from EDA Store</li> <li>What events EDA can filter on and pass over to the Notifier application</li> <li>How to configure different notification systems</li> </ol>"},{"location":"eda/beginner/notifications.html#technology-explanation","title":"Technology explanation","text":"<p>Before jumping into the exercise, let's clarify what we consider an event in EDA.</p> <p>As the name suggests, EDA - Event Driven Automation - is all about events, but what does it really mean? In a nutshell it means that all internal EDA processes are triggered by different kinds of events happening in and outside of the EDA system. EDA is a system of event producers and consumers, where everything is based on event streaming and asynchronous communication.</p> <p>For example, if a transceiver dies and triggers a port to go down, this event will be immediately available in EDA thanks to streaming telemetry. Once the event of a port changing its state from UP to DOWN is available in the EDA system, all the applications that registered themselves as a consumer for such events will start and work on the basis of this event. For example:</p> <ul> <li>an Interface application that is in charge of the interfaces will raise an appropriate alarm</li> <li>the ISL (inter-switch link) application that defines the ISL links will recalculate the health of a corresponding link and will mark it as degraded</li> <li>the Components application that tracks the state of node components will raise an alarm that Transceiver went down</li> <li>and so on and so forth. A single event triggers dozens of applications.</li> </ul> <p>This reactivity to the events in the core of the EDA engine is what makes it a pure event-driven system.</p> <p>With a strong focus on openness, EDA doesn't keep events only to itself, but allows non-core applications to subscribe to the vast majority of these events and react to them.</p> <p>One such application - Notifier - was written by Nokia to unlock notification capabilities for all EDA users. After installing the app, you can configure your notification sources and destinations. You have the option to choose between two sources \u2014 Alarm or Query \u2014 and can send notifications to multiple destinations.</p> <p>When the Notifier app is installed, it extends the EDA API with the new Resources (aka Intents)<sup>1</sup>:</p> <ol> <li> <p>Notifier     Allows an operator to configure which events/sources to use to create notification messages. Can be either a list of alarms, or a list of EQL queries. Notifier resource can act on sources from the namespace it is created in.</p> <p>The <code>ClusterNotifier</code> resource is a cluster-scoped version of the Notifier resource that can act on sources from all namespaces.</p> Notifier resource fields <p>Notifier resource has the following fields: <pre><code>apiVersion: notifiers.eda.nokia.com/v1\nkind: Notifier\nmetadata:\n  name: ''\n  namespace: ''\nspec:\n  description: ''\n  enabled: true\n  providers: []\n  sources:\n    alarms:\n      include: []\n      exclude: []\n    query:\n      table: ''\n      where: ''\n      fields: []\n      title: ''\n      template: ''\n      color: ''\n</code></pre></p> </li> <li> <p>Provider     Allows an operator to configure notification systems (destinations) that notification messages produced by the Notifier resource can be sent to. The <code>Provider</code> resource is namespace scoped and can be referenced by the <code>Notifier</code> resource in the same namespace.</p> <p><code>ClusterProvider</code> resource can be referenced by the <code>ClusterNotifier</code> resource.</p> Provider resource fields <p>Provider resource has the following fields:</p> <pre><code>apiVersion: notifiers.eda.nokia.com/v1\nkind: Provider\nmetadata:\n  name: ''\n  namespace: ''\nspec:\n  description: ''\n  enabled: true\n  uri: ''\n</code></pre> </li> </ol> <p>By configuring these two resources a user can define what events to take in as a source for notifications and where to deliver them.</p> <p>Both <code>Notifier</code> and <code>Provider</code> resources are configured in a user's namespace (in our lab setup the namespace is called <code>eda</code>) as we will consume notifications in the same namespace. For cluster-wide setup one could have used <code>ClusterNotifier</code> and <code>ClusterProvider</code> resources.</p>"},{"location":"eda/beginner/notifications.html#tasks","title":"Tasks","text":"<p>As per this exercises' objective you are tasked with providing your operations team who uses Discord with a notification stream for link up/down events.</p>"},{"location":"eda/beginner/notifications.html#install-notifier-app","title":"Install Notifier App","text":"<p>EDA is an extensible framework where a user is free to choose what application they need to install. To foster extensibility and community involvement, EDA allows everyone to write applications that can be installed on the platform. Of course, many initial applications will come from Nokia. Notifier is an example of an app that doesn't come preinstalled and is available in the Nokia App Catalog that is configured in your EDA system.</p> <p>Login to the EDA UI using the assigned Group ID and EDA credentials provided to you.</p> <p>Install the Notifier application by switching to the System Administration view and choosing the Notifier application from the list of applications.</p> <p></p> <p>Once the application is installed, switch back to the Main view where you will see the Notifier menu group in the left sidebar with the Notifier and Provider resources in it.</p>"},{"location":"eda/beginner/notifications.html#send-interface-alarms-to-discord","title":"Send Interface Alarms to Discord","text":"<p>You are tasked with configuring the Notifier app to send Interface Up/Down alarms to a Discord server that we created for you. To accomplish this task you will need to perform the following steps:</p> <ol> <li>Configure the Discord Provider resource that will receive the notifications about interface state changes.</li> <li>Identify the alarm type raised by the system when an interface changes its state.</li> <li>Create an instance of the Notifier resource that matches the identified alarm type and directs the notifications to the Discord Provider.</li> </ol>"},{"location":"eda/beginner/notifications.html#configuring-the-discord-provider","title":"Configuring the Discord Provider","text":"<p>Start with configuring the Discord Provider. In the context of the Notifier app, a Provider resource configures the destination where alarms can be sent. You can configure many different providers in the Notifier app such as Discord, Teams, Telegram, etc., but for this task we will use Discord, as it is easy and quick to set it up.</p>"},{"location":"eda/beginner/notifications.html#logging-in-to-discord","title":"Logging in to Discord","text":"<p>Naturally, you will need to log in to Discord to see the notifications popping up when you are done with the configuration task. To login to Discord server where we created a channel for this exercise you can either install the Discord app or use the web interface.</p> <p>To join the EDA Discord server follow this link - https://eda.dev/discord</p> <p>After choosing the username, you should see a list of channels with one of them being named # srx-hackathon-notifier. This is where we will send our notifications.</p>"},{"location":"eda/beginner/notifications.html#create-provider-resource","title":"Create Provider resource","text":"<p>As part of this exercise, no matter what group you're assigned to, you get a Discord webhook link from us that is associated with the channel <code>srx-hackathon-notifier</code>.</p> <pre><code>https://discord.com/api/webhooks/1405656591650394193/qfNUUL1rN39szP608GDPMUPqBmhmwWTMRasWY36mS9QmWY24j118CFuyWA7xfArAmKfF\n</code></pre> <p>In the EDA UI sidebar find the Notifier group and choose the Provider menu item. Next open the Provider resource form by clicking on the Create button:</p> <p></p> <p>Edit the resource by giving your provider a name, for example <code>discord</code>, and paste the Discord URL in the <code>uri</code> field.</p> <p>Warning</p> <p>When pasting the discord webhook link you should replace the <code>https://</code> schema with <code>discord://</code> to indicate to the Notifier that it is a Discord webhook.</p> <p>Commit the transaction.</p> Solution <p>The Provider resource should look like this:</p> <pre><code>apiVersion: notifiers.eda.nokia.com/v1\nkind: Provider\nmetadata:\n  name: discord\n  namespace: eda\nspec:\n  enabled: true\n  uri: &gt;-\n    discord://discord.com/api/webhooks/1405656591650394193/qfNUUL1rN39szP608GDPMUPqBmhmwWTMRasWY36mS9QmWY24j118CFuyWA7xfArAmKfF\n</code></pre>"},{"location":"eda/beginner/notifications.html#identifying-alarm-types","title":"Identifying Alarm Types","text":"<p>Let's have another look at the specification of the Provider resource that we should use to tell EDA what notifications to send to the configured Provider:</p> <pre><code>apiVersion: notifiers.eda.nokia.com/v1\nkind: Notifier\nmetadata:\n  name: ''\n  namespace: ''\nspec:\n  description: ''\n  enabled: true\n  providers: []\n  sources:\n    alarms:\n      include: []\n      exclude: []\n    query:\n      table: ''\n      where: ''\n      fields: []\n      title: ''\n      template: ''\n      color: ''\n</code></pre> <p>As we are tasked with notifying our ops team with Interface alarms, you might have guessed that we will focus on the following bit of the Notifier specification:</p> portion of the Notifier spec<pre><code>spec:\n  enabled: true\n  providers: []\n  sources:\n    alarms:\n      namespaces: []\n      include: []\n      exclude: []\n</code></pre> <p>As the field's name suggest, we might want to include some alarms in the <code>include</code> list, but what exactly we need to type there?</p> <p>To answer this question, we have to look at the Alarms page in the EDA UI. In the side menu select Alarms from the SYSTEM category and in the Alarms dashboard click on the View link in the Active Application Alarms panel.</p> <p></p> <p>What you see in the Type column is the Alarm Type, and the Notifier app expects you to provide this value in the <code>.spec.alarms.include</code> field. Great, one piece of a puzzle solved. But there may be many alarm types in your list, and none of them may be relevant to the interface state we are after.</p> <p>We need to find the relevant Alarm Type that is raised when an interface goes Up-&gt;Down or Down-&gt;Up. In future, EDA docs will have a list of alarms published, but until then, let's shut one interface down and monitor the list of alarms.</p>"},{"location":"eda/beginner/notifications.html#generating-interface-down-event","title":"Generating Interface Down Event","text":"<p>To generate the relevant alarm we need to connect to the server hosting the network topology using the credentials provided.</p> <p>Once logged in, paste this script that shuts down the <code>ethernet-1/1</code> on <code>leaf11</code> node:</p> Run commandExpected output <p>Run in the bash shell of the server:</p> bring down leaf1:ethernet-1/1<pre><code>docker exec clab-srexperts-leaf11 \\\nsr_cli -ec \"/interface ethernet-1/1 admin-state disable\"\n</code></pre> <p>After running the command, you should see</p> <pre><code>All changes have been committed. Leaving candidate mode.\n</code></pre> <p>Now have a look at the alarm list again and filter on the Last Changed column to have most recent events appear on top. You will</p> <p></p> <p>Write down the Alarm Type that was raised when we shut down the interface.</p> Hint <p>Alarm Type: <code>InterfaceDown</code></p> <p>Restore Interface State</p> <p>Bring back up the interface by running the following command in the bash shell of the server:</p> <pre><code>docker exec clab-srexperts-leaf11 \\\nsr_cli -ec \"/interface ethernet-1/1 admin-state enable\"\n</code></pre> <p>By bringing the interface up, the alarms will be automatically change their state to Cleared = True.</p>"},{"location":"eda/beginner/notifications.html#configuring-notifier","title":"Configuring Notifier","text":"<p>Knowing the Alarm Type, you can proceed with creating the Notifier resource:</p> <p></p> <p>Add the Alarm Type to the <code>.spec.sources.include</code> list and bind the Notifier resource to the Provider we created earlier.</p> Solution <pre><code>apiVersion: notifiers.eda.nokia.com/v1\nkind: Notifier\nmetadata:\n  name: interface-alarm\n  namespace: eda\nspec:\n  enabled: true\n  providers:\n    - discord\n  sources:\n    alarms:\n      include:\n        - InterfaceDown\n</code></pre>"},{"location":"eda/beginner/notifications.html#testing-notifications","title":"Testing notifications","text":"<p>With both Notifier and Provider resources configured you should be able to test the Notifier app in action.</p> <p>We will use the familiar interface down command that we used to find the Alarm type. You should execute this command in the bash shell of the server that runs your topology:</p> Disable interfaceEnable interface bring down leaf1:ethernet-1/1<pre><code>docker exec clab-srexperts-leaf11 \\\nsr_cli -ec \"/interface ethernet-1/1 admin-state disable\"\n</code></pre> bring up leaf1:ethernet-1/1<pre><code>docker exec clab-srexperts-leaf11 \\\nsr_cli -ec \"/interface ethernet-1/1 admin-state enable\"\n</code></pre> <p>Triggering the interface admin state should raise the Alarm in the EDA UI as well as send a notification to the configured Provider. Watch the Discord channel for new messages to appear when the alarm is raised and cleared.</p>"},{"location":"eda/beginner/notifications.html#try-other-providers","title":"Try other providers","text":"<p>For an extra challenge, try configuring another provider (slack, email, teams) and add it to the same Notifier resource as an additional provider. This should deliver the alarm notification to all configured providers at once.</p> <ol> <li> <p>If this a new term for you, check out the Declarative Intents exercise first.\u00a0\u21a9</p> </li> </ol>"},{"location":"eda/beginner/routers.html","title":"Routers","text":"Short Description Creating a router with EDA to achieve layer 3 connectivity Difficulty Beginner Resources used Virtual Networks \u2192 Routers / Routed Interfaces Topology Nodes  client11,  client13,  leaf11,  leaf13 <p>This is the second exercise in a 4-part series about using EDA to achieve connectivity to, from, and within your datacenter. In this exercise, we will achieve layer-3 connectivity between two hosts in different broadcast domains.</p> <ul> <li>Part 1: achieve layer-2 connectivity using bridge domains</li> <li>Part 2 (this activity): achieve layer-3 connectivity using routers</li> <li>Part 3: combine layer-2 and layer-3 connectivity through a single EDA object: the Virtual Network</li> <li>Part 4: automate parts 1 through 3 of this exercise with Python</li> </ul>"},{"location":"eda/beginner/routers.html#objective","title":"Objective","text":"<p>In this exercise, we enable two linux hosts to talk to each other, but in contrast to the Part 1 exercise the two hosts reside in different subnets and have IP addresses from different subnets. Therefore, traffic must be routed instead of switched over the datacenter fabric using a dedicated and isolated service: the IP-VRF.</p> <p>We will have to configure the overlay services in such a way that traffic between these client interfaces is successfully routed, without creating any layer-2 subnets in the overlay, pure L3.</p> Target connectivity model: Layer 3 only"},{"location":"eda/beginner/routers.html#technology-explanation","title":"Technology explanation","text":"<p>While EVPN originally emerged as a Layer 2 VPN technology to overcome VPLS limitations, it has since evolved to become a unified control plane for many services, Layer 3 VPN included. Founded upon the BGP protocol, EVPN has lots of flexibility and features to become a one-stop-shop for all VPN services in various network deployments, but especially fit for the IP fabrics.</p> <p>In the Part 1 we learned how to use EDA to provide layer 2 services across an IP fabric. The focus of this part is on deploying a Layer 3 Ethernet VPN (EVPN) overlay service in the EDA-managed DC fabric.</p> <p>We will instantiate an interface-less flavor of an L3 EVPN service that does not require the use of Integrated Routing and Bridging (IRB) interfaces, and as such has no need MAC VRF instances, ARP/ND entries synchronization, MAC/IP (RT2) and IMET routes.</p> <p>As you might expect, the Layer 3 EVPN is designed to provide Layer 3 services across the fabric. As such, there are no stretched broadcast domains across the fabric and the customer equipment is directly connected via L3 interfaces to the leafs and often runs a PE-CE routing protocol to exchange IP prefixes.</p> <p>Layer-3 or routed services enables a datacenter infrastructure team to:</p> <ol> <li>reduce the size of Layer-2 broadcast domains and segment the network into smaller subnets interconnected by routers</li> <li>force the traffic path of certain flows over specific paths.     For example: you may want to add a firewall between computes, so only traffic to and from the HTTPS port is allowed to go to a web farm. This is not possible with bridge domains, as traffic can be broadcasted for everyone to hear: this is not the case for routed traffic.</li> </ol> <p>We'll look at how this connectivity can be achieved in EDA using declarative abstracted resources such as Routers and Routed Interfaces. A router is another word for Virtual Private Routed Network (or VPRN) in SR OS terms or IP-VRF in SR Linux. And a routed interface is an L3 interface that is part of a router.</p> <p>The Router resource declaratively defines the virtual router (VRF) on the supported network OSes, whereas the Routed Interface resource defines the L3 interface that is part of virtual router.</p>"},{"location":"eda/beginner/routers.html#tasks","title":"Tasks","text":"<p>See Access Details if you need a reminder on how to access the nodes in the topology.</p> <p>The tasks ahead of you require you to enable the layer-3 connectivity between <code>clients11</code> and <code>client13</code>. You start from a clean slate where clients have IP addresses configured, and they are physically connected to the datacenter fabric, but there is no relevant config present on the leaf switches to enable this connectivity as shown on the diagram below:</p> Starting state <p>For this exercise, the clients have been configured with the following IP addresses:</p> Client Interface IP address VLAN client11 eth1.311 10.30.1.11/24  fd00:fdfd:0:3001::11/64 311 client13 eth1.313 10.30.3.13/24  fd00:fdfd:0:3003::13/64 313"},{"location":"eda/beginner/routers.html#inspect-the-ip-configuration-of-both-clients","title":"Inspect the IP configuration of both clients","text":"<p>Before we start, we need to verify the IP configuration on both clients. We're interested in two things:</p> <ol> <li>the IP address of each client's interface so we can test later whether the connectivity is in place.  </li> <li>the VLAN this interface is configured with</li> </ol> <p>Using the IP configuration provided in the Objective section, verify the acting configuration on the clients by connecting to the shell.</p> <p>To connect to the shell of the client nodes, you should connect to the server running your lab and then ssh to each node, for example, for <code>client11</code>:</p> execute from the lab server<pre><code>ssh admin@clab-srexperts-client11\n</code></pre> <pre><code>[*]\u2500[client11]\u2500[~]\n\u2514\u2500\u2500&gt;\n</code></pre> <p>When in the client shell, use your linux skills to inspect the IP configuration of the client and match it with the IP plan provided in the Objective section.</p> Hint: the relevant IP interfaces on the clients client-11client-13 <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ip a | grep \"10.30.1\" -A 5 -B 2\n6: eth1.311@eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9500 qdisc noqueue state UP group default qlen 1000\n    link/ether aa:c1:ab:2f:4b:67 brd ff:ff:ff:ff:ff:ff\n    inet 10.30.1.11/24 scope global eth1.311\n       valid_lft forever preferred_lft forever\n    inet6 fd00:fdfd:0:3001::11/64 scope global\n       valid_lft forever preferred_lft forever\n    inet6 fe80::a8c1:abff:fe2f:4b67/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <pre><code>[*]\u2500[client13]\u2500[/]\n\u2514\u2500\u2500&gt; ip a | grep \"10.30.3\" -A 5 -B 2\n7: eth1.313@eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9500 qdisc noqueue state UP group default qlen 1000\n    link/ether aa:c1:ab:b9:1b:9e brd ff:ff:ff:ff:ff:ff\n    inet 10.30.3.13/24 scope global eth1.313\n       valid_lft forever preferred_lft forever\n    inet6 fd00:fdfd:0:3003::13/64 scope global\n       valid_lft forever preferred_lft forever\n    inet6 fe80::a8c1:abff:feb9:1b9e/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>To test the connectivity, ping client13 interface from client11:</p> IPv4IPv6 <pre><code>[x]\u2500[client11]\u2500[~]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.3.13\nPING 10.30.3.13 (10.30.3.13) 56(84) bytes of data.\nFrom 10.30.1.11 icmp_seq=1 Destination Host Unreachable\n\n--- 10.30.3.13 ping statistics ---\n1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms\n</code></pre> <pre><code>[x]\u2500[client11]\u2500[~]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3003::13\nPING fd00:fdfd:0:3003::13(fd00:fdfd:0:3003::13) 56 data bytes\nFrom fd00:fdfd:0:3001::11 icmp_seq=1 Destination unreachable: Address unreachable\n\n--- fd00:fdfd:0:3003::13 ping statistics ---\n1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms\n</code></pre> <p>There is no connectivity, as the overlay services are not configured. There is no virtual router (VRF) in the fabric that would route the traffic between the clients.</p>"},{"location":"eda/beginner/routers.html#list-routers","title":"List Routers","text":"<p>We just established that the connectivity between our clients is not working, and assumed that this is due to the network not being configured to support this service.</p> <p>In EDA, the Routers resources declaratively define the VRFs on the network elements. Let's check if there are any Routers already configured.</p> <p>Login to the EDA UI using the assigned Group ID and EDA credentials provided to you.</p> <p>EDA Core and the Apps</p> <p>The EDA platform consists of the core and the apps that extend it and provide the resources for declarative network management. Although you can make your own apps, Nokia already provides an extensive library of pre-installed apps that can handle a lot of configuration tasks. Programming your own app is beyond the scope of this exercise.</p> <p>Look at the app menu in the left sidebar for RRouters, which is located in the   VIRTUAL NETWORK category.</p> <p></p> <p>When you click on the RRouters menu element, you get the list of existing Router resources. A few of them may already be there to power up other exercises, but none of them enable Layer-3 connectivity for our clients as your pings indicated. Time to create your first Router and see what it gets you.</p>"},{"location":"eda/beginner/routers.html#create-a-router","title":"Create a Router","text":"<p>Using the \"Create\" button in the top-right, you can create a new Router. In the center of the screen you can see all configuration options for the new Router, and on the right is a YAML representation that could be used for automation.</p> <p></p> <p>By creating a new Router resource we intend our network elements to have a VRF that will serve as a virtual routing instance for the two clients.</p> <p>The Router resource provides Network OS agnostic fields to define a virtual routing instance. The form and its YAML representation will have some fields set to their default values, and some fields will be set to <code>null</code> to indicate that they were not set. The most important Router properties you have to pay attention to are:</p> <ul> <li>A name so you can reference this Router later</li> <li>The type should be left as \"EVPNVXLAN\", as the Router is intended to provide overlay services and be used in the EVPN VXLAN fabric that you have at hand.</li> </ul> A note about namespaces <p>Namespaces in EDA are used to separate resources into any way you see fit: in a real-life network, you may want to split your fabric resources into regions or functions, for example. In the hackathon we have only one namespace -  <code>eda</code> - which has been pre-configured in your lab topology.</p> <p>When you are finished, you can press the Commit button to commit the transaction<sup>1</sup> right away which will result in EDA verifying the correctness of the Router configuration and... It will store the Router resource in the EDA database, but no config will be pushed to the nodes. Why, you ask? The Router configuration is only pushed to nodes when Routed Interface resources are created that refer a Router; And since we don't have them yet - EDA does not push anything to the nodes. We'll add them in the next step.</p> <p>When you configured and committed the Router configuration, your logical topology started to look like this:</p> Created a Router <p>The virtual router is created, but we did not create the interfaces that would connect to it, to satisfy the connectivity requirement.</p> <p>The solution can be found below in YAML format, if you want to refer to it. You can copy this yaml object into the right column in the GUI to change your current config.</p> Solution <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: Router\nmetadata:\n  name: router\n  namespace: eda\nspec:\n  eviPool: evi-pool\n  tunnelIndexPool: tunnel-index-pool\n  type: EVPNVXLAN\n  vniPool: vni-pool\n</code></pre> <p>The key pieces here are the pools used for the VNI, EVI and tunnel index allocation. Want to know more about pools and how EDA presents itself as a source of truth and IPAM? Read about Allocation Pools first.</p>"},{"location":"eda/beginner/routers.html#create-routed-interfaces","title":"Create Routed Interfaces","text":"<p>The RoutedInterface enables the configuration and management of Layer 3 interfaces for routing traffic between different networks. This resource allows for specifying an underlying Interface and Router, configuring VLAN IDs, and setting the IP MTU. Routed Interfaces are similar to Bridge Interfaces, but they define a routed interface, instead of a bridged/switch one.</p> <p>You will find the RIRouted Interface resource under the   VIRTUAL NETWORK category. Your goal is two create two routed interface, one for each client. These interfaces should reference the physical network interfaces that are part of your topology as well reference the Router you created in the previous step.</p> <p>The physical interfaces were already modeled in EDA with the IInterface resource during the topology onboarding process, their names are:</p> <ul> <li><code>leaf11-client11</code></li> <li><code>leaf13-client13</code></li> </ul> <p>When defining the Routed Interfaces, make sure to set the VLAN ID to match the one used by the associated client interface.</p> <p>Additionally, you want to give the routed interface both an IPv4 and an IPv6 address that your clients will use as the gateway for the subnet.</p> <p>Before you commit, do a dry-run first, just like in the previous exercise! This will allow you to inspect the configuration pushed to the nodes. After you commit this change to the fabric, you should be able to see the routed interface status reflected in the GUI. You can also navigate to your router, and find out which leaf nodes are now participating in the service.</p> <p></p> Solution interface for client11interface for client13 <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: RoutedInterface\nmetadata:\n  name: router-client11\n  namespace: eda\nspec:\n  interface: leaf11-client11\n  ipMTU: 1500\n  ipv4Addresses:\n    - ipPrefix: 10.30.1.1/24\n      primary: true\n  ipv6Addresses:\n    - ipPrefix: fd00:fdfd:0:3001::1/64\n  router: router\n  vlanID: '311'\n  vlanPool: vlan-pool\n</code></pre> <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: RoutedInterface\nmetadata:\n  name: router-client13\n  namespace: eda\nspec:\n  interface: leaf13-client13\n  ipMTU: 1500\n  ipv4Addresses:\n    - ipPrefix: 10.30.3.1/24\n      primary: true\n  ipv6Addresses:\n    - ipPrefix: fd00:fdfd:0:3003::1/64\n  router: router\n  vlanID: '313'\n  vlanPool: vlan-pool\n</code></pre> <p>Once this is done, you should be able to ping the gateway IP that you assigned in the Routed Interface resource from the client's shell. The examples are provided for <code>client11</code>.</p> IPv4IPv6 <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.1.1\nPING 10.30.1.1 (10.30.1.1) 56(84) bytes of data.\n64 bytes from 10.30.1.1: icmp_seq=1 ttl=64 time=3.55 ms\n\n--- 10.30.1.1 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 3.553/3.553/3.553/0.000 ms\n</code></pre> <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3001::1\nPING fd00:fdfd:0:3001::1(fd00:fdfd:0:3001::1) 56 data bytes\n64 bytes from fd00:fdfd:0:3001::1: icmp_seq=1 ttl=64 time=4.00 ms\n\n--- fd00:fdfd:0:3001::1 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 3.997/3.997/3.997/0.000 ms\n</code></pre> <p>With these changes committed, your logical connectivity diagram completes, as client interfaces are now connected to the virtual router, via the routed interfaces:</p> Routed Interfaces connected"},{"location":"eda/beginner/routers.html#enabling-inter-client-connectivity","title":"Enabling inter-client connectivity","text":"<p>So far, we've only pinged the router from each client, but in a real-world scenario we want to ping the other clients instead. On the clients, a static route has been pre-configured so that the subnet <code>10.30.0.0/16</code> is routed via each client's gateway, which includes the subnets of the other clients.</p> <p>Give it a try!</p> client-11client-13 <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.3.13\nPING 10.30.3.13 (10.30.3.13) 56(84) bytes of data.\n64 bytes from 10.30.3.13: icmp_seq=1 ttl=253 time=4.93 ms\n\n--- 10.30.3.13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 4.933/4.933/4.933/0.000 ms\n\n[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3003::13\nPING fd00:fdfd:0:3003::13(fd00:fdfd:0:3003::13) 56 data bytes\n64 bytes from fd00:fdfd:0:3003::13: icmp_seq=1 ttl=253 time=6.04 ms\n\n--- fd00:fdfd:0:3003::13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 6.039/6.039/6.039/0.000 ms\n</code></pre> <pre><code>[*]\u2500[client13]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.1.11\nPING 10.30.1.11 (10.30.1.11) 56(84) bytes of data.\n64 bytes from 10.30.1.11: icmp_seq=1 ttl=253 time=4.56 ms\n\n--- 10.30.1.11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 4.559/4.559/4.559/0.000 ms\n\n[*]\u2500[client13]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3001::11\nPING fd00:fdfd:0:3001::11(fd00:fdfd:0:3001::11) 56 data bytes\n64 bytes from fd00:fdfd:0:3001::11: icmp_seq=1 ttl=253 time=5.09 ms\n\n--- fd00:fdfd:0:3001::11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 5.087/5.087/5.087/0.000 ms\n</code></pre>"},{"location":"eda/beginner/routers.html#summary","title":"Summary","text":"<p>In this exercise, you successfully established layer-3 connectivity between two clients (<code>client11</code> and <code>client13</code>) residing in different subnets leveraging EDA's Router and Routed Interface resources. Specifically:</p> <ul> <li>You created a Router resource that defined a virtual routing instance (VRF) in the datacenter fabric</li> <li>You configured Routed Interfaces that connected the physical interfaces to the Router resource</li> <li>You established proper IP addressing for both IPv4 and IPv6 on the Routed Interfaces</li> <li>You verified connectivity between clients across different subnets through successful ping tests</li> </ul> <p>Now that you mastered Layer-2 and Layer-3 basic buildings blocks represented by Bridge Domains and Routers, it is time to see how they can be combined in a single unit of abstraction that we call a Virtual Network, or VNET for short. On to the next exercise!</p> <ol> <li> <p>If you want to learn more about transactions, checkout transactions section of the Declarative Intents exercise.\u00a0\u21a9</p> </li> </ol>"},{"location":"eda/beginner/virtual-networks.html","title":"Virtual Networks","text":"Short Description Creating a virtual network with EDA to combine layer-2 and layer-3 connectivity Difficulty Beginner Topology Nodes  client11,  client12,  client13,  leaf11,  leaf12,  leaf13 <p>This is the third exercise in a 4-part series around using EDA to achieve connectivity within your datacenter. In this exercise, we will leverage the knowledge gained in the previous two parts and deploy both layer-2 and layer-3 overlay services. Thanks to the power of abstracted and derived intents, under the hood the virtual network will create the individual resources we created manually in parts 1 &amp; 2.</p> <ul> <li>Part 1: achieve layer-2 connectivity using bridge domains</li> <li>Part 2: achieve layer-3 connectivity using routers</li> <li>Part 3 (this activity): combine layer-2 and layer-3 connectivity through a single EDA object: the Virtual Network</li> <li>Part 4: automate parts 1 through 3 of this exercise with Python</li> </ul>"},{"location":"eda/beginner/virtual-networks.html#objective","title":"Objective","text":"<p>Through the past two exercises, you have learned how to deploy pure layer-2 and pure layer-3 overlay services using EDA abstracted intents. In particular, for layer-2 services you have used the Bridge Domain/Bridge Interface/VLAN resources, and for layer-3 services you used the Router/Routed Interface.</p> <p>However, both these designs have their own challenges and limitations. A layer-2 overlay service does not allow inter-subnet routing and has all the challenges of a big broadcast domain. A pure layer-3<sup>1</sup> design with clients using the layer-3 interfaces not only does not support applications that require L2 connectivity, but would also require each leaf to have a distinct and dedicated routed interface with a unique gateway IP, which makes host migration difficult.</p> <p>This is why many datacenters are built using the hybrid approach of combining small layer-2 overlay services with the inter-subnet overlay routing. This design allows clients to use a simple LAG interface towards the leaf switches, while achieving multihoming, workload migration and layer-2 connectivity, when required.</p> <p>In this exercise your focus will be on building a composite overlay service that will enable three linux hosts to talk to each other, both within their own subnet (switched traffic) and between the subnets (routed traffic).</p>"},{"location":"eda/beginner/virtual-networks.html#technology-explanation","title":"Technology explanation","text":"<p>We have covered the scenario where hosts can talk to each other in a layer-2 domain (via a Bridge Domain), and the scenario where hosts in different subnets can be interconnected (via a Router). We did not cover perhaps the most frequent scenario: a combination of the layer-2 inter-subnet bridging and layer-3 routing to interconnected different subnets.</p> <p>Because of the popularity of this design, EDA provides a dedicated abstraction for it: the VNVirtual Networks resource that you can find in   VIRTUAL NETWORK category.</p> <p>A Virtual Network combines multiple bridge domains, routers, routed interfaces and protocols in a single resource. A typical Virtual Network might for example contain:</p> <ul> <li>A bridge domain for storage computes</li> <li>A bridge domain for GPU clusters</li> <li>A bridge domain for in-band management access to all computes</li> <li>Redundant routed interfaces, each towards a datacenter gateway (DCGW)</li> <li>BGP sessions with the DCGWs, so the internal routes can be advertised to the Wide-Area Network (WAN) and external routes can be imported to provide internet connectivity</li> </ul> <p>In this exercise, we'll create a mix of bridge domains and routed interfaces that can all communicate with each other, regardless of whether their IP addresses are in the same subnet or not. The whole network connectivity design will be driven off of a single abstracted intent - Virtual Network - that will emit multiple sub-resources that we previously covered in parts 1 and 2.</p> <p>The diagram below depicts how a single high-level Virtual Network resource emits multiple sub-resources and through this orchestrates a creation of a composite service topology.</p> <pre><code>graph TB\n    X[\"Virtual Network\"]--&gt;A[\"Router\"]\n    A--&gt;B[\"Bridge Domain A\"]\n    A--&gt;C[\"Bridge Domain B\"]\n    A--&gt;D[\"Routed Interface 1\"]\n    A--&gt;E[\"Routed Interface 2\"]\n    B--&gt;F[\"VLAN 300\"]\n    C--&gt;G[\"VLAN 311\"]</code></pre>"},{"location":"eda/beginner/virtual-networks.html#irb-interfaces","title":"IRB interfaces","text":"<p>So far, we've seen two types of interfaces:</p> <ul> <li>A bridged interface, which connects a (physical port, VLAN) combination to a MAC-VRF</li> <li>A routed interface, which connects a (physical port, VLAN) combination to an IP-VRF</li> </ul> <p>With a bridged interface, we can interconnect many hosts with an IP in the same subnet, whereas with a routed interface we can allow a single host to communicate with IPs outside of their subnet. We're missing one piece of the puzzle: what if we want many hosts with IPs in the same subnet, to all be able to communicate with IP addresses in the other subnets?</p> <p>That's where the Integrated Routing and Bridging (IRB) comes in: an IRB is a logical interface that connects a MAC-VRF to an IP-VRF. The IRB needs to have an IP address assigned to it that the bridged interfaces will use to reach addresses outside of their subnet. Usually, the first host in the subnet is assigned to the IRB and is called the \"anycast gateway\", or simply \"gateway\".</p> <pre><code>graph TB\n    A[\"IP VRF\"]--&gt;B[\"IRB 1 (10.100.100.1/24)\"]\n    A--&gt;C[\"IRB 2 (10.200.200.129/26)\"]\n    B--&gt;D[\"MAC-VRF 1\"]\n    C--&gt;E[\"MAC-VRF 2\"]\n    D---&gt;F[\"Host 1 (10.100.100.10)\"]\n    D--&gt;G[\"Host 2 (10.100.100.11)\"]\n    D---&gt;H[\"Host 3 (10.100.100.15)\"]\n    E--&gt;I[\"Host 4 (10.200.200.135)\"]\n    E---&gt;J[\"Host 5 (10.200.200.136)\"]\n    E--&gt;K[\"Host 6 (10.200.200.137)\"]</code></pre> <p>The IRB interfaces depicted above \"connect\" a MAC-VRF to an IP-VRF and make the inter-subnet routing possible.</p>"},{"location":"eda/beginner/virtual-networks.html#tasks","title":"Tasks","text":"<p>See Access Details if you need a reminder on how to access the nodes in the topology.</p> <p>For this exercise the relevant IP configuration on the clients is presented below:</p> Client Interface IP address VLAN client11 eth1.300 10.30.0.11/24  fd00:fdfd:0:3000::11/64 300 eth1.311 10.30.1.11/24  fd00:fdfd:0:3001::11/64 311 client12 eth1.300 10.30.0.12/24  fd00:fdfd:0:3000::12/64 300 eth1.312 10.30.2.12/24  fd00:fdfd:0:3002::12/64 312 client13 eth1.300 10.30.0.13/24  fd00:fdfd:0:3000::13/64 300 eth1.313 10.30.3.13/24  fd00:fdfd:0:3003::13/64 313 <p>And your task is to create a service that has the following connectivity matrix:</p> Target connectivity <p>IMPORTANT</p> <p>Remove any Bridge Domains, Bridge Interfaces, VLANs and Routed Interfaces that you may have created in the Bridge Domains/Part 1 and the Routers/Part 2 as our Virtual Network will create them or simply reset EDA using the git time machine.</p> <p>Be careful when removing these resources and do not remove resources that have <code>role=hackathon-infra</code> tag as they are infrastructure related. But if you messed it up, don't worry, you can always reset EDA.</p> <p>You should expect that clients can't reach each other in any direction, due to no overlay services being configured.</p>"},{"location":"eda/beginner/virtual-networks.html#list-virtual-networks","title":"List Virtual Networks","text":"<p>Login to the EDA UI using the assigned Group ID and EDA credentials provided to you.</p> <p>EDA Core and the Apps</p> <p>The EDA platform consists of the core and the apps that extend it and provide the resources for declarative network management. Although you can make your own apps, Nokia already provides an extensive library of pre-installed apps that can handle a lot of configuration tasks. Programming your own app is beyond the scope of this exercise.</p> <p>Look at the app menu in the left sidebar for VNVirtual Networks, which is located in the   VIRTUAL NETWORK category.</p> <p></p> <p>When you click on the VNVirtual Networks menu element, you get the list of existing Virtual Network resources. There will be one VNET already that powers up the hackathon infrastructure, but it does not interfere with the goal of this exercise. Time to create your first Virtual Network and make your clients talk to each other.</p>"},{"location":"eda/beginner/virtual-networks.html#create-a-virtual-network","title":"Create a Virtual Network","text":"<p>Use the knowledge of the previous two exercises (Bridge Domains and Routers) to achieve the connectivity as shown on the diagram above. A single virtual network resource would be able to define the following:</p> <ul> <li>a Router to create the IP-VRF of the EVPNVXLAN type</li> <li>two Routed Interfaces to connect the Router to the <code>client11</code> and <code>client13</code> over the respective VLANs 311 and 313</li> <li>two Bridge Domains to create subnets for VLAN 300 and 312 respectively</li> <li>two VLAN resources to create Bridge Interfaces for the respective VLANs 300 and 312</li> <li>two IRB Interfaces to connect the Bridge Domains to the Router</li> </ul> <p>Yes, a single Virtual Network resource can define all of these objects, and it will emit the necessary sub resources, and each sub resource can emit its own sub resources, and so on, until the configuration is complete.</p> <p>Note</p> <p>Hosts <code>client11</code> and <code>client13</code> are both single-homed clients, meaning that they physically connect to only one leaf switch.</p> <p>Host <code>client12</code> is different: it is multihomed to 3 leaf switches in an all-active configuration, and its EDA interface is called <code>lag1</code>. Can you find this special interface in EDA? Which physical ports are connected to <code>client12</code>?</p> <p>Auto-completion for non-committed objects</p> <p>When creating an IRB for example, you must specify references to both a Router and a Bridge Domain. The autocomplete suggestions of these fields only show created objects. Therefore, you will not see suggestions for Routers and Bridge Domains that have not been committed yet. Specify the name without the auto-completion, as you provide it in the same resource.</p> Solution <p>It might be tricky to solve this challenge if you see EDA for the first time, so here is a solution:</p> <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: VirtualNetwork\nmetadata:\n  name: virtual-network\n  namespace: eda\n  labels:\n    role: exercise\nspec:\n  routers:\n    - name: vnet-router\n      spec:\n        eviPool: evi-pool\n        tunnelIndexPool: tunnel-index-pool\n        type: EVPNVXLAN\n        vniPool: vni-pool\n\n  routedInterfaces:\n    - name: vnet-routed-interface-client11\n      spec:\n        interface: leaf11-client11\n        ipv4Addresses:\n          - ipPrefix: 10.30.1.1/24\n            primary: true\n        ipv6Addresses:\n          - ipPrefix: fd00:fdfd:0:3001::1/64\n            primary: true\n        router: vnet-router\n        vlanID: '311'\n    - name: vnet-routed-interface-client13\n      spec:\n        interface: leaf13-client13\n        ipv4Addresses:\n          - ipPrefix: 10.30.3.1/24\n            primary: true\n        ipv6Addresses:\n          - ipPrefix: fd00:fdfd:0:3003::1/64\n            primary: true\n        router: vnet-router\n        vlanID: '313'\n\n  bridgeDomains:\n    - name: vnet-bridge-domain-300\n      spec:\n        eviPool: evi-pool\n        tunnelIndexPool: tunnel-index-pool\n        type: EVPNVXLAN\n        vniPool: vni-pool\n    - name: vnet-bridge-domain-312\n      spec:\n        eviPool: evi-pool\n        tunnelIndexPool: tunnel-index-pool\n        type: EVPNVXLAN\n        vniPool: vni-pool\n\n  vlans:\n    - name: vnet-vlan-300\n      spec:\n        bridgeDomain: vnet-bridge-domain-300\n        interfaceSelector:\n          - edge-type=compute\n        uplink:\n          uplinkVLANID: pool\n        vlanID: '300'\n    - name: vnet-vlan-312\n      spec:\n        bridgeDomain: vnet-bridge-domain-312\n        interfaceSelector:\n          - edge-type=compute\n        uplink:\n          uplinkVLANID: pool\n        vlanID: '312'\n\n  irbInterfaces:\n    - name: vnet-irb-300\n      spec:\n        bridgeDomain: vnet-bridge-domain-300\n        ipAddresses:\n          - ipv4Address:\n              ipPrefix: 10.30.0.1/24\n              primary: true\n            ipv6Address:\n              ipPrefix: fd00:fdfd:0:3000::1/64\n              primary: true\n        hostRoutePopulate:\n          dynamic: true\n          static: true\n        router: vnet-router\n    - name: vnet-irb-312\n      spec:\n        bridgeDomain: vnet-bridge-domain-312\n        ipAddresses:\n          - ipv4Address:\n              ipPrefix: 10.30.2.1/24\n              primary: true\n            ipv6Address:\n              ipPrefix: fd00:fdfd:0:3002::1/64\n              primary: true\n        hostRoutePopulate:\n          dynamic: true\n          static: true\n        router: vnet-router\n</code></pre> <p>We recommend you do a Dry Run first, and see the node configuration diff to see how much stuff gets created on the node when you commit it. Overlay services is not a small feat, and configuring this manually would be a lot of work. With EDA, you get a lot for free, with reliable and fast transaction model to ensure consistency and reliability.</p> <p>When the Virtual Network resource is successfully created, test the connectivity between the clients. Try to understand what the ping command is doing, and which components you created in EDA are responsible for routing/switching the traffic to the correct destination. The activity has been successfully completed if all these ping commands succeed.</p> Ping &amp; traceroute command syntax <p>You can use the <code>-I</code> flat to force a ping request to exit through a particular interface. This is used in the commands below to force the traffic to either be switched or routed.</p> <p>Similarly, you can use the <code>-i</code> flag with traceroute to see the difference between switched and routed traffic:</p> <pre><code>[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; traceroute -i eth1.300 10.30.0.12\ntraceroute to 10.30.0.12 (10.30.0.12), 30 hops max, 46 byte packets\n 1  10.30.0.12 (10.30.0.12)  0.826 ms  0.733 ms  0.510 ms\n\n[*]\u2500[client11]\u2500[/]\n\u2514\u2500\u2500&gt; traceroute -i eth1.311 10.30.0.12\ntraceroute to 10.30.0.12 (10.30.0.12), 30 hops max, 46 byte packets\n 1  10.30.1.1 (10.30.1.1)  1.156 ms  1.262 ms  0.769 ms\n 2  10.30.0.12 (10.30.0.12)  0.978 ms  0.777 ms  0.777 ms\n</code></pre> Client11Client12Client13 <ul> <li><code>ping -I eth1.300 10.30.0.12</code></li> <li><code>ping -I eth1.311 10.30.2.12</code></li> <li><code>ping -I eth1.311 10.30.3.13</code></li> </ul> <ul> <li><code>ping -I bond0.300 10.30.0.13</code></li> <li><code>ping -I bond0.312 10.30.1.11</code></li> <li><code>ping -I bond0.312 10.30.3.13</code></li> </ul> <ul> <li><code>ping -I eth1.300 10.30.0.11</code></li> <li><code>ping -I eth1.313 10.30.1.11</code></li> <li><code>ping -I eth1.313 10.30.2.12</code></li> </ul>"},{"location":"eda/beginner/virtual-networks.html#summary","title":"Summary","text":"<p>In this exercise, you successfully created a Virtual Network that combines both layer-2 and layer-3 connectivity in a single abstracted intent. Specifically:</p> <ul> <li>You created a Virtual Network resource that defined multiple components in one declaration:<ul> <li>A Router to create an IP-VRF for layer-3 routing</li> <li>Routed Interfaces to connect clients directly to the Router over specific VLANs</li> <li>Bridge Domains to create layer-2 connectivity for specific VLANs</li> <li>VLAN resources to create Bridge Interfaces for the respective VLANs</li> <li>IRB Interfaces to connect the Bridge Domains to the Router, enabling inter-subnet routing</li> </ul> </li> </ul> <p>This exercise demonstrated the power of abstraction in EDA, where a single high-level Virtual Network resource can emit multiple sub-resources to orchestrate a complete connectivity solution. By combining layer-2 and layer-3 services, you've created a more flexible network design that supports both applications requiring direct layer-2 connectivity and the scalability benefits of layer-3 routing between subnets.</p> <p>Now that you've mastered the basics of creating overlay services with EDA using both manual configuration and the Virtual Network abstraction, you're ready to move on to Part 4 where you'll switch from UI to the code editor and will automate the service provisioning with EDA REST API!</p> <ol> <li> <p>You can check an in-depth lab where we covered this type of design at Learn SR Linux blog.\u00a0\u21a9</p> </li> </ol>"},{"location":"eda/intermediate/api.html","title":"EDA REST API","text":"Short Description Get to know EDA REST API Difficulty Intermediate Tools Used Postman Topology Nodes leaf11, leaf12, leaf13, spine11, spine12 References EDA API Guide, EDA OpenAPI Swagger spec<sup>1</sup> <p>EDA is an API-first platform where every client, be it the EDA UI, a CLI tool or a higher-level orchestrator talks to EDA via one of its APIs.</p> <p>The two main north-bound APIs that EDA exposes are EDA REST API and EDA Kubernetes API. With EDA REST API you can write your own automation software or integrate the platform with another system; the API allows to configure all EDA features and components.</p> <p>In this exercise we will focus on EDA's REST API and use Postman API client to interact with it.</p>"},{"location":"eda/intermediate/api.html#objective","title":"Objective","text":"<p>The objectives of this challenge are:</p> <ul> <li>Get to the grips of EDA REST API.</li> <li>Find out where API documentation is located and how to use it</li> <li>Learn the API authentication process</li> <li>Learn how to make API calls using a REST client (Postman in this example)</li> </ul>"},{"location":"eda/intermediate/api.html#technology-explanation","title":"Technology Explanation","text":"<p>EDA API is extensible. Every EDA resource that gets added when a user installs the application, becomes extends the EDA API surface in a similar way as custom resources in Kubernetes become available through the Kubernetes API. This model provides that powerful extensibility where a system can be customized on-the-fly, by simply installing the EDA App via the EDA Store, and the app will plug its API to the common API layer of the system.</p> <p>EDA's API have two API sets that users typically interact with:</p> <ol> <li>Core API     This is the EDA Core system API. Things like Transactions, Alarms, and User management are all part of the this API set.     It extends with installing a new version of the EDA platform.</li> <li>Apps API     Every applications onboarded to the EDA platform (both provided by Nokia or anyone else) will extend the Apps API by adding the applications API to the common API layer.     This is how extensibility of the API is achieved in EDA.</li> </ol>"},{"location":"eda/intermediate/api.html#api-server","title":"API Server","text":"<p>Both Core and Apps API are served by the EDA's API Server implemented as a horizontally scalable <code>eda-api</code> deployment running in the EDA's Kubernetes cluster. The API server deployment is exposed via <code>eda-api</code> Kubernetes service.</p>"},{"location":"eda/intermediate/api.html#api-documentation","title":"API Documentation","text":"<p>Detailed information about all of the individual API endpoints and their parameters is available in the OpenAPI (v3) format. The API documentation is provided alongside with your EDA installation and makes is automatically installed with it.</p> <p>You will find OpenAPI documentation for both EDA Core as well as for every application you have installed in your EDA cluster by using the  icon in the top right corner and select API Documentation menu item:</p> <p>When you have the API Documentation UI open, you will find the different applications in the left sidebar. Select an app to browse its API endpoints and the schema for the objects used in the API.</p> <p>The API documentation UI lists all application, their API endpoints and the details about the requests and responses.</p>"},{"location":"eda/intermediate/api.html#authentication","title":"Authentication","text":"<p>As you would expect, only authorized and authenticated users can make use of the EDA API. For authentication and authorization, EDA uses Keycloak as its backend. Keycloak is a proven and secure solution for Identity and Access management.</p> <p>The API client directly authenticates with Keycloak, and uses the token received for further API calls to the EDA API. The API client is also responsible for refreshing or renewing their token.</p> <p>Open a tab with the authentication docs as you will need it later when we get to running our first API call.</p>"},{"location":"eda/intermediate/api.html#sync-async-and-transaction-apis","title":"Sync, Async and Transaction APIs","text":"<p>All REST API endpoints related to the EDA Apps<sup>2</sup> are being processed by the API server as synchronous requests - a single request when received by the API server will be committed as a transaction and the result will be returned when the transaction is completed. The client, therefore, will be locked until the response is sent by the API server.</p> <p>To make asynchronous requests, the API clients can use the transaction mechanism provided by the Core API, we often call this set of endpoints - Transaction API.</p> <p>When using transaction endpoints, a user adds resource/operation objects to the transaction and then commits the transaction. When committing the transaction the client immediately receives the response with the transaction ID, and can proceed doing other work. The client then checks the transaction status by referencing the transaction ID received in the initial response and can react to the status of the transaction.</p>"},{"location":"eda/intermediate/api.html#trying-out-the-api","title":"Trying Out the API","text":"<p>The API documentation web UI does not only provide a reference to the available APIs and endpoints, but also allows you to run the requests for all available endpoints. The video below shows how to run a <code>GET</code> request to fetch configured users in the EDA platform by using the endpoint of the Core API.</p> <p>The request runner in the API documentation web view takes care of the authentication flow on your behalf. You can start running API requests right away.</p>"},{"location":"eda/intermediate/api.html#tasks","title":"Tasks","text":"<p>Now, to turn theory into practice, you will work on a set of tasks that will gradually introduce you to the world of EDA REST API.</p> <p>Solutions</p> <p>When you get stuck, you can always raise your hand and one of our experts will try to help you out. But if you want to have a look at the solution yourself, you will find the solutions for the API requests in the  __Solutions folder of the same Postman collection.</p> <p>The Solutions folder uses the same structure as the root folder.</p>"},{"location":"eda/intermediate/api.html#install-and-setup-postman","title":"Install and Setup Postman","text":"<p>We will use Postman as the API client to fire off the requests. If you don't have it installed, make sure to do so by going to the postman.com/downloads link and selecting the installer for your platform.</p> <p>When installing Postman you will be asked to login to the Postman.com, you can use any of the existing OpenID providers (google, github). The registration is free and you won't be asked to provide any payment details.</p> <p>When Postman is installed, grab the Postman Collection that we prepared for this exercise by clicking on the button below:</p> <p></p> <p>and selecting the \"import a copy\" option.</p> <p></p> <p>Select your Workspace where you want the collection to be imported in. The prepared collection should be copied to your account and you should see it in your postman application.</p>"},{"location":"eda/intermediate/api.html#environment","title":"Environment","text":"<p>In addition to the collection, the environment named \"Hackathon instance\" that contains the <code>API_SERVER</code> variable should appear in the top right corner of the Postman app:</p> <p></p> <p>Make sure to select it.</p> <p>Then edit the imported environment and change the Current Value of the <code>API_SERVER</code> variable to match the EDA Web UI address you have been provided with.</p> <p>This video shows the full process:</p>"},{"location":"eda/intermediate/api.html#authentication_1","title":"Authentication","text":"<p>Now that you have the collection and the environment dialed in, you need to sort the authentication out. Remember, only the authenticated users can leverage the API.</p> <p>The authentication process boils down to acquiring the API token from the Keycloak service that runs as part of the EDA deployment, but to get the access token you first need to get the <code>client_secret</code> from Keycloak. Sounds a bit cryptic? Check out the authentication docs to understand the flow better; there we also explain how to get the <code>client_secret</code> using the Keycloak UI.</p> <p>Once you get the <code>client_secret</code> string from Keycloak, set its value in the Postman Environment as the Current value of the <code>EDA_CLIENT_SECRET</code> variable. Done?</p> <p>Now to test if you got it all right, execute the  Auth \u2192 Issue API Access Token request.</p> <p>The request should execute without errors, and in the postman output panel you should see various tokens received:</p> <pre><code>{\n    \"access_token\": \"somevalue\",\n    \"expires_in\": 300,\n    \"refresh_expires_in\": 1800,\n    \"refresh_token\": \"somevalue\",\n    \"token_type\": \"Bearer\",\n    \"id_token\": \"somevalue\",\n    \"not-before-policy\": 0,\n    \"session_state\": \"75f07837-51b1-4306-995b-11798fc1b802\",\n    \"scope\": \"openid profile email\"\n}\n</code></pre> <p>This is a typical OpenID/OAuth2.0 response with an access token and auxiliary information. What is important, is that the POST request we just executed has a Post-Request script attached to it, that parses the returned payload and stores the <code>.access_token</code> value in the <code>{{TOKEN}}</code> variable. That way, every other request in our collection can make use of the acquired token, without specifying the value directly.</p>"},{"location":"eda/intermediate/api.html#list-users","title":"List Users","text":"<p>First \"real\" task - fetch all users configured in the EDA system.</p> <p>We have prepared for you the canvas, the  Core \u2192  Admin \u2192 Get Users request in your Postman collection. But it looks a bit empty, the API endpoint URL is missing. Can you fill it in?</p> Hint <p>Use API documentation and look for the EDA Core API. One of its endpoints can show you configured users; you can even find it being displayed in the video above.</p> <p>You need to add authentication and the request URL parts.</p> <p>If you entered the data correctly, you should get a list of users, which normally would contain just the <code>admin</code> user, unless you created more:</p> <pre><code>[\n    {\n        \"uuid\": \"f2a75035-56a5-4ba0-be9b-53e1351259be\",\n        \"username\": \"admin\",\n        \"enabled\": true,\n        \"firstName\": \"EDA\",\n        \"lastName\": \"admin user\",\n        \"groups\": [\n            \"5aefa9bb-6459-491e-994a-794c9a04a6e3\"\n        ],\n        \"status\": {\n            \"lastSuccessfulLogin\": \"2025-05-07T15:23:29Z\"\n        }\n    }\n]\n</code></pre> <p>Congratulations, you have completed the first task!</p>"},{"location":"eda/intermediate/api.html#get-interface","title":"Get Interface","text":"<p>In the previous task you listed all objects of the same kind, to be precise - all users. Now the task is to retrieve the details of a particular Interface object from EDA, namely, <code>leaf11-ethernet-1-49</code>.</p> <p>To complete this task you will use the Interface application API, as interfaces are not part of the EDA core, but an extension brought in by the Interface application.</p> <p>Using the knowledge on how to navigate the API documentation, try to complete the  Interface \u2192 Interface request so that the EDA returns everything it knows about the <code>leaf11-ethernet-1-49</code>.</p> Hint <p>Interface is a namespaced resource, hence your URL will contain a namespace element in it to target a resource in the namespace. In our hackathon lab we use the default <code>eda</code> namespace for everything.</p>"},{"location":"eda/intermediate/api.html#create-banner","title":"Create Banner","text":"<p>Next challenge. You need to create a new login banner message across all switches in your fabric that will say the following:</p> <pre><code>This device is used in the best workshop ever - the SReXperts Hackathon 2025.\n</code></pre> <p>A free hint for you - the Banner resource is part of the Site Information application. You will find it under its name in the API docs.</p> <p>In alignment with HTTP verbs adopted by REST, the creation of a new resource is a task for a POST request. Have a look at the API documentation for the Site Information app and focus on the available POST requests. It won't take you long to spot this:</p> <p></p> <p>We have prepared for you a blank POST request under the  Site Information \u2192 Banners POST request, but this request has an empty body. What to put in?</p> <p>Again, the answer can be derived from the API documentation site, if you zoom in the POST request body in the API docs UI, you will see that it lists the full body template:</p> <pre><code>{\n  \"apiVersion\": \"siteinfo.eda.nokia.com/v1alpha1\",\n  \"kind\": \"Banner\",\n  \"metadata\": {\n    \"annotations\": {\n      \"additionalProp1\": \"string\"\n    },\n    \"labels\": {\n      \"additionalProp1\": \"string\"\n    },\n    \"name\": \"somelongname\",\n    \"namespace\": \"string\"\n  },\n  \"spec\": {\n    \"loginBanner\": \"string\",\n    \"motd\": \"string\",\n    \"nodeSelector\": [\n      \"string\"\n    ],\n    \"nodes\": [\n      \"string\"\n    ]\n  }\n}\n</code></pre> <p>This JSON blob is templated by the API documentation engine from the OpenAPI specification for this resource, and it can also be seen in the EDA UI if you open the Site Information \u2192 Banners form and try to create the resource in the UI.</p> <p>Now it is up to you to figure out what to fill in to make the login banner string to be configured on all the switches in our fabric.</p> <p>If you get all the pieces right, the POST request will return the exact body you submitted in HTTP 201 response, but if something goes wrong, you'll get HTTP 400.</p> <p>How to ensure that your banner has been provisioned on all of the nodes? You can connect to them via SSH and see the login banner in the terminal, or you can run this EQL:</p> <pre><code>.namespace.node.srl.system.banner\n</code></pre> <p></p>"},{"location":"eda/intermediate/api.html#create-a-transaction","title":"Create a Transaction","text":"<p>Now, to the real deal. So far we have been working in a synchronous way. Our requests were run-to-completion, with each request getting a response. This works fine for single-shot tasks, but don't sleep on the value the transaction brings to the table.</p> <p>Transactions shine when:</p> <ol> <li>A change set you want to commit spans multiple resources or contains operations of different types (create, update, delete)</li> <li>You want to validate your transaction before trying to apply it</li> <li>Your transaction can take time and you want to make sure the API client can do something else (asynchronous mode)</li> </ol> <p>You are tasked with planning and applying a change that will combine two actions:</p> <ol> <li>remove the banner we just added</li> <li>change the description on <code>leaf11-ethernet-1-49</code> and <code>leaf12-ethernet-1-49</code> interfaces to \"description changed via REST API\"</li> </ol> <p>Instead of firing off two API requests each targeting one action, we will use the transaction API endpoints to achieve change validation (aka dry run) and asynchronous application.</p>"},{"location":"eda/intermediate/api.html#transaction-api","title":"Transaction API","text":"<p>The API endpoints that you are interested in are all part of the EDA Core API set, which you already have looked at when we listed users.</p> <p>The endpoints of interest are:</p> <ul> <li><code>/core/transaction/v2</code> - Run a transaction (with or without Dry Run)</li> <li><code>/core/transaction/v2/result/execution/{transactionId}</code> - Get the execution details of the posted transaction.</li> </ul>"},{"location":"eda/intermediate/api.html#dry-run","title":"Dry Run","text":"<p>The planning part of this change would assume that you want to run a verification step via API to make sure your change set is valid, and only after having a green light from EDA applying the change.</p> <p>Have a look at the <code>/core/transaction/v2</code> API endpoint documentation and its body example:</p> <pre><code>{\n  \"crs\": [\n    {\n      \"type\": {\n        \"create\": {\n          \"value\": {\n            \"apiVersion\": \"string\",\n            \"kind\": \"string\",\n            \"metadata\": {\n              \"annotations\": {\n                \"additionalProp1\": \"string\"\n              },\n              \"labels\": {\n                \"additionalProp1\": \"string\"\n              },\n              \"name\": \"somevalue\",\n              \"namespace\": \"string\"\n            },\n            \"spec\": {}\n          }\n        },\n        \"delete\": {\n          \"gvk\": {\n            \"group\": \"string\",\n            \"kind\": \"string\",\n            \"version\": \"string\"\n          },\n          \"name\": \"string\",\n          \"namespace\": \"string\"\n        },\n        \"modify\": {\n          \"value\": {\n            \"apiVersion\": \"string\",\n            \"kind\": \"string\",\n            \"metadata\": {\n              \"annotations\": {\n                \"additionalProp1\": \"string\"\n              },\n              \"labels\": {\n                \"additionalProp1\": \"string\"\n              },\n              \"name\": \"somevalue\",\n              \"namespace\": \"string\"\n            },\n            \"spec\": {}\n          }\n        },\n        \"patch\": {\n          \"patchOps\": [\n            {\n              \"from\": \"string\",\n              \"op\": \"string\",\n              \"path\": \"string\",\n              \"value\": {},\n              \"x-permissive\": true\n            }\n          ],\n          \"target\": {\n            \"gvk\": {\n              \"group\": \"string\",\n              \"kind\": \"string\",\n              \"version\": \"string\"\n            },\n            \"name\": \"string\",\n            \"namespace\": \"string\"\n          }\n        },\n        \"replace\": {\n          \"value\": {\n            \"apiVersion\": \"string\",\n            \"kind\": \"string\",\n            \"metadata\": {\n              \"annotations\": {\n                \"additionalProp1\": \"string\"\n              },\n              \"labels\": {\n                \"additionalProp1\": \"string\"\n              },\n              \"name\": \"somevalue\",\n              \"namespace\": \"string\"\n            },\n            \"spec\": {}\n          }\n        }\n      }\n    }\n  ],\n  \"description\": \"string\",\n  \"dryRun\": true,\n  \"resultType\": \"string\", // normal | debug | errors only\n  \"retain\": true\n}\n</code></pre> <p>The highlighted lines denote different types that the request can contain, and you can easily see how they are mapped to the operations:</p> <ul> <li><code>create</code></li> <li><code>delete</code></li> <li><code>modify</code></li> <li><code>patch</code></li> <li><code>replace</code></li> </ul> <p>To remove the Banner you created earlier, you would have use the <code>delete</code> operation type and provide group/version/kind of the Banner resource and its name and namespace it is in.</p> <p>And to change the description of the two Interface resources you could use either <code>patch</code>, <code>modify</code> or <code>replace</code>, they all would work, but have slightly different semantics and purposes.</p> Hint <p>If you will opt in using the <code>patch</code> operation type, not that it uses the JSON Patch (RFC 6902) format<sup>3</sup>.</p> <p>When you use the <code>modify</code> operation type, the <code>value</code> should contain all required fields of a resource.</p> <p>The Dry Run mode is enabled with the <code>dryRun</code> field in the request set to the <code>true</code> value; this will result in transaction being synthetically tested by the platform, without touching the network elements.</p> <p>Can you crack this?<sup>4</sup></p>"},{"location":"eda/intermediate/api.html#transaction-results","title":"Transaction results","text":"<p>When you run your transaction with or without the Dry Run flag set, you will immediately receive back... Not much. Just a transaction ID.</p> <p>Why is that? That's the asynchronous pattern and its behavior. You get back the transaction identifier immediately and your client is then free to do whatever, or check the transaction status/results. There are several result providing endpoints, but the one we want you to have a look is:</p> <p><code>/core/transaction/v2/result/execution/{{TX_ID}}</code></p> <p>A call to this endpoint will provide you with the information about the transaction execution results. You will see the changed resources, the nodes that were targeted by this change and much more.</p>"},{"location":"eda/intermediate/api.html#apply","title":"Apply","text":"<p>If your dry run has succeeded, you can flip the switch <code>\"dryRun\": false</code> and apply the transaction. It should be applied to your network in an instant.</p> <p>You can call the transaction results API again or verify it in the EDA UI. You can finish off with checking that the login banner is gone by running the same EQL query we did before.</p>"},{"location":"eda/intermediate/api.html#summary","title":"Summary","text":"<p>EDA's REST API is a fundamental interface for interacting with the EDA platform programmatically. The abstracted declarative intents (EDA Apps) make it easy to automate complex networks with as little input as possible and a close tie-in with the business requirements. Everything your EDA app has to offer becomes available to the API server.</p> <p>By completing this challenge you learned a lot of things about EDA API including:</p> <ol> <li> <p>API-First Architecture: You discovered that EDA is an API-first platform where all clients (UI, CLI tools, orchestrators) interact with EDA through its APIs.</p> </li> <li> <p>API Structure: You learned about the two main components of the EDA API:</p> </li> <li>Core API: The built-in system API for managing transactions, alarms, topology nodes, and users</li> <li> <p>Apps API: Extensible APIs provided by installed applications</p> </li> <li> <p>Kubernetes-like Resource Model: You understood how EDA's API follows a similar model to Kubernetes, where custom resources can be added through applications.</p> </li> <li> <p>Authentication Flow: You learned how EDA uses Keycloak for authentication and how to obtain and use access tokens for API requests.</p> </li> <li> <p>Transaction Types: You explored both synchronous and asynchronous API patterns, including the Transaction API for complex operations.</p> </li> </ol> <ol> <li> <p>The eda-labs/openapi doc site is a community-supported site with the swagger-based web ui for the openapi specs.\u00a0\u21a9</p> </li> <li> <p>These are the ones served under the <code>${EDA_ADDRESS}/apps/</code> URL.\u00a0\u21a9</p> </li> <li> <p>https://spacelift.io/blog/kubectl-patch-command#how-to-use-the-kubectl-patch-command-with-different-types-of-kubernetes-patching-strategies \u21a9</p> </li> <li> <p>If you're stuck, ask for help or have a look at the <code>__Solutions</code> folder in the collection.\u00a0\u21a9</p> </li> </ol>"},{"location":"eda/intermediate/custom-allocations.html","title":"Custom Allocations","text":"Short Description Learn to define custom naming patterns for assigning ASNs and IPs in Nokia EDA. This exercise demonstrates how to override default values using an allocation method that meets customer-specific standards. Difficulty Intermediate Tools Used EDA web UI, kubectl CLI Topology Nodes leaf11, leaf12, leaf13, spine11, spine12 References Allocation Pools documentation <p>Allocation of identifiers such as IP addresses, VLAN IDs, subinterface indexes and so on is a critical aspect of network design and management. Given that EDA acts as an authority for configuration of the managed targets, it automates and controls how resource identifiers are assigned via the concept of Allocation Pools.</p> <p>Note</p> <p>This exercise dives deeper into the allocation methods and specifically in how to make custom allocations to ensure predictable allocations.</p> <p>If you are new to the concept of allocations in EDA, we recommend you to complete the introductory Allocations activity first.</p> <p>By default, EDA assigns the next free resource identifiers from the associated Allocation Pool. Often this is sufficient, as many identifiers have local meaning and do not bear any meaning. Other times, however, it is necessary to assign identifiers in a deterministic manner, such as when the identifier needs to encode a specific role or function.</p> <p>To support this use case, EDA Allocation Pools have notion of Custom Allocations (aka preallocations), that can be used to reserve a specific identifier for a specific target node. The usage of custom allocations is what this exercise focuses on.</p>"},{"location":"eda/intermediate/custom-allocations.html#objective","title":"Objective","text":"<p>In this hands-on lab, you'll customize resource allocations in Nokia's EDA platform, overriding the default ASN, system IP, ISL assignments. This method ensures deterministic, user-provided resource assignments for easier device identification and troubleshooting. You can use both the Kubernetes CLI (via <code>kubectl</code>) and the EDA web UI to:</p> <ol> <li>Customize ASNs for BGP peers</li> <li>Assign system IPs from a user-defined subnet range</li> <li>Configure inter-switch links (ISL) subnets for underlay point-to-point links</li> </ol> <p>The goal is to replace generic, automatically-assigned values with a custom, consistent naming convention across the SReXperts lab topology.</p>"},{"location":"eda/intermediate/custom-allocations.html#technology-explanation","title":"Technology Explanation","text":"<p>For a generic explanation of Allocations, please refer to the Allocations activity.</p> <p>Custom Allocations (aka Preallocations) are a way to mark identifiers in an allocation pool allocatable to only specific resources that requested them. For example, from the pool of AS Numbers we can preallocate the AS Number <code>4200001111</code> to the <code>leaf11</code> specifically by creating the allocation.</p> <pre><code>apiVersion: core.eda.nokia.com/v1\nkind: IndexAllocationPool\nmetadata:\n  name: srexperts-asnpool\n  namespace: eda\nspec:\n  publishAllocations: true\n  segments:\n    - start: 4200001000\n      size: 1000\n      allocations:\n        - name: srexperts-fabric-leaf-leaf11\n          value: 4200001111\n</code></pre> <p>The preallocation is defined in the allocation pool resource by providing the <code>allocations</code> block with the list of the following field pairs:</p> <ol> <li><code>name</code>: the \"allocation key\" that a specific application (fabric in the example above) would provide when requesting an allocation from the pool.</li> <li><code>value</code>: the value that should be allocated to the application.</li> </ol> <p>With the preallocation defined as above, the fabric application can request an allocation from the <code>srexperts-asnpool</code> pool for the <code>leaf11</code> node and the preallocated value <code>4200001111</code> will be returned from the pool as the application would provide a key that matches the <code>name</code> field of the preallocation.</p>"},{"location":"eda/intermediate/custom-allocations.html#allocation-key","title":"Allocation Key","text":"<p>At the center of the custom allocations lies the Allocation Key concept. The Allocation Key is a string that uniquely identifies a target that requires an allocation. Typically it is a node (or group of nodes) that requests a resource identifier (e.g., ASNs, system IPs). An EDA Application, like a Fabric app, Interface app, or BGP Peer app, provides the allocation key as a parameter when requesting an allocation. If an allocation pool contains a matching key in its definition, then the preallocated value will be returned to the calling applications.</p> <p>It is up to a particular application to define the allocation key that it will use to request an allocation. As such, there is no standard allocation key format, and in the future we will document the allocation key formats for each application.</p> <p>If we take the Fabric app as an example, it uses the following allocation keys when requesting AS Numbers from the pool:</p> <ul> <li><code>{fabric_name}-leaf-{node_name}</code> - to assign AS Numbers to leaf nodes</li> <li><code>{fabric_name}-spine</code> - to assign AS Numbers to spines. The node name is not present in the key, since all spines in the fabric share the same ASN as per the app design.</li> </ul> <p>When an allocation resource has its <code>.spec.publishAllocations</code> field set to <code>true</code>, the allocation values are published EDA's in memory Database (EDB), so that it is easy to check the current allocation values and what keys were used by the application.</p> <p>By using the <code>.namespace.allocations.v1.template.instance.allocation</code> EQL query you will see all allocations in the system. One of the tasks will teach you how to do it.</p>"},{"location":"eda/intermediate/custom-allocations.html#tasks","title":"Tasks","text":"<p>Your task is to align the allocation values used in the fabric to match a specific ASN address scheme convention employed by the organization.</p> <p>We'll go step-by-step through the process of reviewing the current ASN assignments and then applying the new custom ASN scheme to the fabric. We'll use both the CLI and the EDA UI to accomplish this, and verify the changes with a EQL query.</p> <p>Danger</p> <p>This set of tasks changes ASN numbering in the data center fabric, impacting the peering sessions with PE devices. While this is expected, when you finish with this exercise you must reset the EDA to its original state to ensure that the service configuration is set to the original state.</p>"},{"location":"eda/intermediate/custom-allocations.html#concepts-naming-conventions","title":"Concepts &amp; Naming Conventions","text":"<p>In this exercise you are tasked with using a specific ASN format in your fabric - 33Xxxxyyyy - where each part of the number encodes specific information:</p> <ul> <li>33: Fixed lab prefix ensuring a private, non-conflicting range.</li> <li>X: Network tier indicator:<ul> <li>1: Leaf</li> <li>2: Spine</li> <li>3: Superspine (if applicable) This digit immediately shows the device role.</li> </ul> </li> <li>xxx: Three-digit site/fabric identifier (e.g., <code>000</code> for a single site).</li> <li>yyyy: Four-digit device identifier (formatted as RRNN: two digits for rack and two for node).</li> </ul> <p>For instance, ASN 3310000101 decodes as:</p> <ul> <li>33: Lab prefix  </li> <li>1: Leaf node  </li> <li>000: Site ID  </li> <li>0101: Rack 01, Node 01</li> </ul> <p>Mapping this design to the SReXperts fabric you are working on, the ASN format translates to:</p> Device Role Custom ASN Breakdown leaf11 Leaf (Rack 01, Node 01) 3310000101 33 (prefix) 1 (leaf) 000 (site) 0101 (rack01-node01) leaf12 Leaf (Rack 01, Node 02) 3310000102 33 (prefix) 1 (leaf) 000 (site) 0102 (rack01-node02) leaf13 Leaf (Rack 01, Node 03) 3310000103 33 (prefix) 1 (leaf) 000 (site) 0103 (rack01-node03) spine1 Spine (ID 01) 3320000101 33 (prefix) 2 (spine) 000 (site) 0101 (spine01) spine2 Spine (ID 02) 3320000101 33 (prefix) 2 (spine) 000 (site) 0101 (spine02)"},{"location":"eda/intermediate/custom-allocations.html#step-1-review-current-asn-assignments","title":"Step 1: Review Current ASN Assignments","text":"<p>First, let's verify what ASNs are currently assigned to the fabric devices before making any changes. We'll use the <code>kubectl</code> CLI to query the EDA system's current ASN allocation records.</p> <ul> <li> <p>List ASN Pools   Run the following command to list the ASN allocation pool resource and see the current allocations:</p> <pre><code>kubectl -n eda get indexallocationpools\n</code></pre> </li> <li> <p>Identify the ASN Pool   Identify the name of the ASN pool being used. For example, if the pool is named <code>srexperts-asnpool</code>, inspect it with:</p> <pre><code>kubectl -n eda get indexallocationpool srexperts-asnpool -o yaml\n</code></pre> </li> <li> <p>Review the Output   The command outputs the YAML definition of the ASN allocation pool, including any pre-defined allocations. For example:</p> <pre><code>apiVersion: core.eda.nokia.com/v1\nkind: IndexAllocationPool\nmetadata:\n  creationTimestamp: \"2025-04-07T14:03:46Z\"\n  generation: 5\n  name: srexperts-asnpool\n  namespace: eda\n  resourceVersion: \"1145904\"\n  uid: 2b1ec70a-3d9d-404b-8493-f87640d43638\nspec:\n  publishAllocations: true\n  segments:\n  - allocations:\n    - name: srexperts-fabric-spine\n      value: 4200001000\n    size: 1000\n    start: 4200001000\n</code></pre> </li> </ul> <p>Keep this information handy, as it will be useful for comparing the before-and-after states. If you prefer a summary, list out each device and its current ASN based on the CLI output for your reference.</p>"},{"location":"eda/intermediate/custom-allocations.html#step-2-confirm-asn-pool-in-eda-ui","title":"Step 2: Confirm ASN Pool in EDA UI","text":"<p>Next, let's confirm which ASN pool is being used by our Fabric via the EDA UI. The EDA web interface provides a visual way to see the configured intents and their state.</p> <p>1. Open the EDA UI </p> <p>Log in to the EDA web interface using the connectivity and credential details provided.</p> <p></p> <p>2. Identify the ASN Pool used by the Leaf nodes </p> <p>Let's find what allocation pool is being used for the leaf switches, by checking the configuration of the Fabric resource as it stands:</p> <ul> <li>Using the left sidebar, find the Fabrics group and click on Fabrics resource.  </li> <li>In the list of configured fabric resources double click on the fabric resource you have.  </li> <li>In the opened configuration view of the fabric resource, use the navigation panel on the left side to find the Leafs section.  </li> <li>Select the Autonomous System Pool in the left nav bar. You should see the right pane to scroll to the position where the ASN allocation pool name is set for the leaf nodes.   <p>For example, it might indicate \u201cAutonomous System Pool: srexperts-asnpool\u201d or display another pool name.</p> </li> </ul> <p></p> <p>3. Verify assigned AS Number After you identified the pool name used for the leafs, check what AS Numbers have been assigned to the actual leaf nodes.</p> <p>Using the nav bar of the Fabric resource, follow the Status -&gt; Leaf Nodes path to see leaf nodes and their AS Numbers that are currently assigned.</p> <p></p> <p>4. Check Pool configuration </p> <p>Using the pool name identified in step 2, find this pool in the Allocation Pools and check its configuration.</p> <p></p> <p>5. For Spine Nodes </p> <ul> <li>Check if there is a similar setting under Spines in the fabric settings.  </li> <li>If a separate pool is in use for spines, take note; if not, spines might also be using srexperts-asnpool.</li> </ul> <p>6. Review Assigned ASNs Verify the current ASN assignments for the fabric to ensure everything is in order.  </p> EDA Managed nodes"},{"location":"eda/intermediate/custom-allocations.html#step-3-cross-check-asn-allocations-with-eql","title":"Step 3: Cross-Check ASN Allocations with EQL","text":"<p>Nokia EDA uses a single persistent database and it is Git. All configuration that must persist \u2014 including all allocations \u2014 is stored in a Git repository. But allocations can also be populated to the EDA's in-memory database - EDB - as driven by the <code>.spec.populateAllocations</code> boolean value that you may have seen in the allocation pool resource definition.</p> <p>All pools that we have defined for this hackathon set this value to <code>true</code>, which means that allocations will be published to the EDB, and everything that is in the EDB can be queried using the EQL query language.</p> <p>Use the below EQL to see existing allocations made from the <code>srexperts-asnpool</code> pool:</p> <pre><code>.namespace.allocations.v1.template.instance.allocation where ( .namespace.allocations.v1.template.name = \"srexperts-asnpool\" )\n</code></pre> <p>You should find the familiar <code>4200001001</code>, <code>4200001002</code>, <code>4200001003</code> ASN numbers allocated to the fabric leafs and <code>4200001000</code> allocated to spines.</p> <p>After completing these steps, you have cross-validated the current state of ASN allocations via both the EDA UI and EQL. This ensures that you are ready to perform the customization by editing the ASN pool.</p>"},{"location":"eda/intermediate/custom-allocations.html#step-4-update-asn-pool-definitions","title":"Step 4: Update ASN Pool Definitions","text":"<p>Once we established the ASN allocation scheme being in place in our topology, we are ready dive into the configuration part of this exercise.</p> <p>This is the critical step where we'll apply our custom ASN scheme by updating the ASN pool definitions in the EDA UI. We'll replace the old ASN values with our new ones (following the 33Xxxxyyyy format).</p> <p>1. Edit the Index Pool resource </p> <ul> <li>Return to the EDA UI and find the Index resource associated with the <code>srexperts-asnpool</code>.  </li> <li>Click the Edit button to enter the editing mode for this pool resource.</li> </ul> <p>2. Modify Leaf ASN Entries </p> <p>When in the Edit mode you will have a chance to add the explicit allocations using either the form, or by directly editing the YAML. What you're looking for is:</p> <ol> <li>Adding the new <code>start</code> value to fit the new addressing scheme</li> <li>Create allocations under the segment block that will list all keys and their explicit ASN values.</li> </ol> <p>Remember, that the allocation key you would use needs to match the key format used by the Fabric app, as this is the app that asks for the allocations from the ASN pool in our topology. For example, keeping our numbering scheme in mind and having the fabric resource named as <code>srexperts-fabric</code>, the allocation key/value pair for <code>leaf11</code> should be:</p> <pre><code>- name: srexperts-fabric-leaf-leaf11\n  value: 3310000101\n</code></pre> <p>Repeat the process of adding the allocations for other leaf nodes.</p> <p>3. Modify Spine ASN Entries </p> <p>Similarly, update the spine entries. The caveat here is that since the spines share the same ASN, their key does not feature the node name, and should be in the format of <code>{fabric_name}-spine</code>.</p> <p>And you would need to define another segment for the spine ASN allocations, since the size of the allocation is limited by 2^24 and we distinct spines vs leafs using the 3<sup>rd</sup> digit in the 4-byte ASN.</p> Solution <p>Here is how your the YAML representation of our intended edits to the <code>srexperts-asnpool</code> resource should look like:</p> <pre><code>apiVersion: core.eda.nokia.com/v1\nkind: IndexAllocationPool\nmetadata:\n  name: srexperts-asnpool\n  namespace: eda\nspec:\n  segments:\n    - start: 3310000000\n      size: 1000000\n      allocations:\n        - name: srexperts-fabric-leaf-leaf11\n          value: 3310000101\n        - name: srexperts-fabric-leaf-leaf12\n          value: 3310000102\n        - name: srexperts-fabric-leaf-leaf13\n          value: 3310000103\n\n    - start: 3320000000\n      size: 1000000\n      allocations:\n        - name: srexperts-fabric-spine\n          value: 3320000101\n</code></pre> <p>You can paste it in the YAML editor to apply.</p> <p>4. Dry Run </p> <p>When iterating over your changes to the Index pool, make your life easier by Dry Running the changes. The Dry Run will flag if you made any errors. If there were no errors, you can check the diffs during the dry run process to verify that the computed ASN values match your intent and they yield the necessary config changes on the expected nodes.</p> <p>5. Commit Changes </p> <ul> <li>After updating all the ASN entries, and ensuring that Dry Run passes over them, you can commit the changes to persist them in the EDA database and provisioned on the nodes.</li> <li>Click the Commit to commit your changes right away or Add to Transaction button if you want to have a dry run once again.</li> <li>The EDA platform will commit the changes to the underlying Git repository.</li> <li>If prompted, enter a commit message (e.g., \u201cUpdate ASN allocations to custom scheme\u201d).</li> <li>Confirm that the commit completes successfully without any errors.</li> </ul> <p></p>"},{"location":"eda/intermediate/custom-allocations.html#step-5-verify-changes","title":"Step 5: Verify Changes","text":"<p>After committing the changes, it's time to confirm that they have been recorded correctly.</p> <p>1. In EDA UI (YAML view) </p> <ul> <li>Reopen the ASN pool YAML (as in Step 2) if the editor closed upon save.  </li> <li>Verify that the allocations lines now contain the new 33X... ASN values.  </li> <li>This confirms that the updated configuration is stored in the system.</li> </ul> <p>2. In EDA UI (Fabric view) </p> <ul> <li>Check the Fabric's summary or device list to see if the ASN information has been updated.  </li> <li>Look for views that list leaf and spine nodes and confirm that their ASN attribute reflects the new values.  </li> </ul> <p>3. With EQL </p> <ul> <li>Run the EQL query you used in step 3 to see the new allocations made from the <code>srexperts-asnpool</code> pool.</li> </ul>"},{"location":"eda/intermediate/custom-allocations.html#step-6-network-level-verification","title":"Step 6: Network-level Verification","text":"<p>Now it's time to verify that the network is indeed using the new ASNs. We'll check this in several ways:</p> <p>Device CLI Verification </p> <p>Log in to the actual Nokia SR Linux devices to confirm each node's local ASN and its BGP neighbor ASNs.</p> <p>For example, connect to leaf11 and check its BGP configuration:</p> Execute on the server hosting the lab topology<pre><code>ssh clab-srexperts-leaf11\n</code></pre> <p>Then, in the SR Linux CLI run:</p> <pre><code>A:leaf11# info network-instance default protocols bgp autonomous-system\nnetwork-instance default {\n    protocols {\n        bgp {\n            autonomous-system 3310000101\n        }\n    }\n}\n</code></pre> <p>This output confirms that leaf11 has a local ASN of 3310000101 (our custom ASN).</p> <p>Next, check the BGP neighbors:</p> <pre><code>A:leaf11# show network-instance default protocols bgp summary\n</code></pre> <p>You should see spine neighbors with remote AS values of 3320000101, 3320000102, etc. (depending on your assignments). If the State is Established, then the BGP sessions are up with the new ASNs.</p>"},{"location":"eda/intermediate/custom-allocations.html#extra-task-system-ip-change","title":"Extra task: System IP Change","text":"<p>Change the system IP addresses for Spine 11 to <code>10.46.16.31</code> and Spine 12 to <code>10.46.16.32</code> to clearly distinguish spine switches (10.46.16.x) from leaf switches (10.46.15.x).</p> <p>Feel free to experiment further:</p> <ul> <li>Try a different numbering scheme.</li> <li>See how EDA behaves when two pools overlap.</li> <li>Pre-allocate specific values to particular nodes using the allocations field.</li> </ul> <p>For deeper insights, consult the EDA documentation.</p> <p>Congratulations! You have successfully implemented custom resource allocations in Nokia EDA and learned how to enforce naming conventions via automated network deployments. This wraps up the lab. Proceed to the next activity or apply these principles to your own network designs. Happy automating!</p> <p>Danger</p> <p>This set of tasks changes ASN numbering in the data center fabric, impacting the peering sessions with PE devices. While this is expected, when you finish with this exercise you must reset the EDA to its original state to ensure that the service configuration is set to the original state.</p>"},{"location":"eda/intermediate/custom-allocations.html#summary","title":"Summary","text":"<p>Custom allocations are useful to ensure the deterministic resource allocation when a certain naming or addressing scheme is enforced by the design. EDA allows applications to reserve values for the given keys and thus ensures the flexible model to ensure predictable allocations.</p> <p>They \"key\" to the pre-allocated values is driven by the requesting application, and is nothing more than a string value. Therefore, knowing the key that each application uses to request allocation is important for the service designer. You learned how to easily find the key each app uses through the EQL query.</p>"},{"location":"eda/intermediate/install-eda.html","title":"Install Your Own EDA","text":"Short Description The full power of EDA with a simulated network topology. All on your laptop Difficulty Intermediate Topology Nodes N/A Tools used make, KinD, macOS/Linux/Windows <p>In the modern cloud-native world of infrastructure automation it is common to offer an open source/freemium version for people to get familiar with the platform/software and try things out before they invest in the enterprise offering.</p> <p>With Nokia EDA we give you a way to install the platform with all its features and without:</p> <ul> <li>asking for a license</li> <li>forcing you to register</li> <li>limiting you with a time-based trial</li> </ul> <p>We are happy to offer this flexibility and openness of the platform to everyone who wants to try EDA.</p>"},{"location":"eda/intermediate/install-eda.html#objective","title":"Objective","text":"<p>By completing this exercise you will get familiar with EDA's installation process, hardware requirements and packaging for non-production/lab environments. We will solely focus on setting up EDA for lab and demo purposes where the whole system is brought up in a development Kubernetes cluster with a small virtual network topology to try out the platform.</p>"},{"location":"eda/intermediate/install-eda.html#technology-explanation","title":"Technology Explanation","text":"<p>EDA is a cloud-native platform for infrastructure automation. It is deployed on top of a Kubernetes cluster and consists of a set of microservices responsible for various tasks such as:</p> <ul> <li>configuration provisioning</li> <li>state synchronization and reconciliation</li> <li>node bootstrap</li> <li>workflow orchestration</li> <li>artifact management</li> <li>and so on...</li> </ul> <p>If microservices and Kubernetes concepts are new to you, fear not, you don't have to be a PhD in cloud-native to install EDA in the lab environment, let alone to use it. We call the process of installing a lab instance of EDA - Try EDA - and it is documented on docs.eda.dev.</p> <p>The Try EDA installation installs the EDA Playground - a lab environment that consists of a KinD k8s cluster with EDA platform and a small virtual network topology with SR Linux nodes running on top of it.</p> <p>By leveraging EDA's deployment model that uses Kubernetes, we can install EDA Playground on any compute that runs Kubernetes or KinD:</p> <ul> <li> <p> Linux</p> <p>Of course, you can install EDA on any compute powered by Linux. Just use the Try EDA installation guide to get started.</p> <p> Try EDA on Linux</p> </li> <li> <p> Windows</p> <p>You can install EDA on Windows as well! Leveraging the Windows Subsystem for Linux (WSL) you can install EDA on top of it. Check out our guide.</p> <p> Try EDA on Windows</p> </li> <li> <p> MacOS</p> <p>Ever wanted to make your expensive MacBook actually do something useful? Install EDA on it!</p> <p>By setting up Docker on your Mac you can install EDA on top of it. Check out our guide.</p> <p> Try EDA on macOS</p> </li> <li> <p> Existing Kubernetes cluster</p> <p>If you happen to have access to an existing Kubernetes cluster, you can install EDA on it as well. You will have dive into the installation bits we packaged in the Makefile of the EDA Playground to understand what sub-targets to call and in what order.</p> <p>This is a more advanced path, as you will need to understand basic Kubernetes concepts and EDA installation process to get it running.</p> <p> Playground on an existing Kubernetes cluster</p> </li> </ul> <p>Did you know that</p> <p>Everyone can install EDA whenever they like. EDA software components are distributed as a set of container images that can be pulled by anyone, whenever they like.</p> <p>You can create an infinite number of virtual SR Linux nodes in the free version of EDA. The only time you need a license is when you want to manage hardware devices.</p>"},{"location":"eda/intermediate/install-eda.html#tasks","title":"Tasks","text":"<p>As you may have guessed, we invite you to Try EDA on your own compute - be it your laptop, or a server in your lab.</p> <p>System requirements</p> <p>Regardless of the platform you choose, you will have to ensure that the following system requirements are met:</p> <ul> <li>10 CPU cores</li> <li>16 GB RAM</li> <li>30 GB disk space</li> </ul> <p>This is the amount of resources that your kubernetes cluster implemented by the KinD should have available. Or simply put, your VM that you use to run the playground should be provisioned with these amount of resources.</p> <p>Choose your deployment option and equip yourself with the following documentation articles to help you get going:</p> <ul> <li>Try EDA process explained - to install EDA on a Linux server.</li> <li>macOS install instructions - to install EDA Playground on a macOS.</li> <li>Windows install instructions - to install EDA Playground on a Windows machine.</li> <li><code>Makefile</code> from the EDA Playground repository - to see what actually being installed and how when you run <code>make try-eda</code> command.</li> <li>Installation process explained - to have a deeper dive on how EDA is installed on a Linux server.</li> </ul>"},{"location":"intro/index.html","title":"EDA","text":"<p>Event Driven Automation (EDA) is the state of the art automation platform that completes Nokia's Data Center portfolio:</p> <p></p> <p>The design goals behind EDA were lofty and our ambitions were to create an infrastructure automation platform that addresses many challenges seen in the data center networking.</p> <p>In the configuration management domain EDA breaks the status quo of imperative, box-by-box configuration and leverages declarative and abstracted configuration model. In this mode a user declares what services or components they want to get deployed by providing its desired state in the form of an input that abstracts the complexities and implementation details.</p> <p>What is more important than the configuration intent - is the state the system is in. EDA takes a unique stance on state handling by coupling the configuration intent with its actual state and presenting it to the users. Having the state of the system aligned with the configuration inputs is crucial to operations.</p> <p>For operations domain EDA provides a unified, instant network-wide view of the running configuration and state via its EDA Query Language (EQL) capabilities. Having a way to create a query that runs over your whole network and provides instant and live results is table stakes for auditing, troubleshooting and state correlation.</p> <p>While the concept of declarative intents or blueprints is not new, in EDA made sure our users can extend and program almost every aspect of the platform. Do not agree how we modeled a DC fabric inputs? You have all the instruments to change it or even create your own implementation of it.</p> <p>And it would be a miss to keep EDA anchored to Nokia-only devices, that is why we ensured that EDA core is multivendor and users can leverage EDA superpowers with other vendors and their devices and APIs<sup>1</sup>.</p> <p>At this hackathon, you get a unique chance to spend a day with EDA by venturing into the exercises meticulously crafted by the EDA team and be the judge of its capabilities.</p>"},{"location":"intro/index.html#how-to-get-through-the-exercises","title":"How to get through the exercises?","text":"<p>As EDA is likely a new system for you, we recommend you to start from the intro exercises in the order they are presented, unless you feel adventurous and want to hit the ground running.</p> <p>When inside a particular exercise, you should complete the tasks in the order they are presented. It might be tempting to skip ahead but a task may have a dependency on the previous step, so do tackle them in order.</p>"},{"location":"intro/index.html#access-details","title":"Access details","text":"<p>The lab environment you work on features a DC network topology with EDA already installed and a number of SR Linux datacenter switches already onboarded onto the platform. In particular, EDA manages seven switches in total: <code>leaf1</code>, <code>leaf2</code>, <code>leaf3</code>, <code>borderleaf1</code>, <code>borderleaf2</code>, <code>spine1</code>, <code>spine2</code>.</p> EDA Managed nodes <p>As you go through the exercise, you might connect to the EDA UI, one of the switches or clients connected to them.</p> UILab serverSR Linux switchesClientsGrafana <p>Most of the exercises can be completed by using EDA Web UI. The UI is accessible over <code>https://{your-IP}:9443</code>.</p> <p>The login credentials will be provided to you by the team.</p> <p>The lab server runs the EDA platform and the whole lab topology. You will need to login to the topology server when you want to SSH further into one of the switches or clients.</p> <pre><code>ssh workshop@{your-IP}\n</code></pre> <p>The login credentials will be provided to you by the team.</p> <p>While you will mostly work with EDA UI, you would want to SSH into the switches to verify the configuration you made in EDA. To access the switches you first need to login to the lab server, and then from the server's shell you SSH further to the desired switch.</p> run from the lab server<pre><code>ssh admin@{switch-hostname}\n</code></pre> <p>The switch hostnames are:</p> <ul> <li><code>leaf1</code></li> <li><code>leaf2</code></li> <li><code>leaf3</code></li> <li><code>borderleaf1</code></li> <li><code>borderleaf2</code></li> <li><code>spine1</code></li> <li><code>spine2</code></li> </ul> <p>The login credentials will be provided to you by the team.</p> <p>Clients are the Linux containers connected to the switches that you would need to configure to perform end-to-end ping tests between the hosts.</p> <p>To access the clients you first need to login to the lab server, and then from the server's shell you SSH further to the desired client.</p> run from the lab server<pre><code>ssh admin@{client-hostname}\n</code></pre> <p>The switch hostnames are:</p> <ul> <li><code>client1</code></li> <li><code>client2</code></li> <li><code>client3</code></li> <li><code>client4</code></li> <li><code>client5</code></li> </ul> <p>The login credentials will be provided to you by the team.</p> <p>The lab setup also includes a Grafana dashboard. This is accessible at <code>https://&lt;your-IP&gt;:9443/core/httpproxy/v1/grafana/dashboards</code>.</p>"},{"location":"intro/index.html#eda-ui","title":"EDA UI","text":"<p>Most exercises can be completed using EDA's Web UI. As any modern platform, EDA's UI is an API client of the backend API server and uses the same endpoints as any automation system would use, which means that technically every exercise can be solved using any automation interface that consumes EDA API.</p> <p>Still, for the most part we expect you to follow the lead and use the UI to complete the majority of the tasks. Chances are high that this will be your first time seeing and using the EDA UI, so let us give you a quick introduction.</p>"},{"location":"intro/index.html#main-page","title":"Main page","text":"<p>When you log in to the EDA UI you land on the Main page, here are the main areas of interest:</p> <p></p> <p> The home page features a dashboard that provides some key information about the managed nodes and their interfaces.</p> <p> The home page has two dashboards to select from. The page picker lets you do this. The picker will be available on other pages as well.</p> <p> Namespace selector. When you have more than one namespace (<code>eda</code> is the default namespace) you will be able to switch between them.</p> <p> Transaction basket. This is where your uncommitted transactions will be stored. Clicking on the basket icon also lets you do operations on the transactions.</p> <p> Workflows. This menu icon lists the recently run workflows.</p> <p> User menu. This is where you can change your password, log out, and access the help and about pages.</p> <p> Side menu toggle. Expands/collapses the left side menu where all EDA apps and menu items are.</p> <p> Panel selector. EDA provides two default panels - Main and System Administration. The panels control what apps are visible in the side menu. Users can create their own panels and switch between them based on the use case.</p> <p> Application icon. Clicking on the icon in the collapsed view opens up the application page.</p> <p> Application category toggle. Can be used to hide/show the application category.</p>"},{"location":"intro/index.html#app-page","title":"App page","text":"<p>When you select an app from the list  you get a page that lists all instances of this particular app/resource created. In the screenshot below we selected the Nodes from the menu and get a list of Node resources that EDA manages.</p> <p></p> <p>The important elements on this view are:</p> <p> Context menu button. Opens up a menu with commands like edit, duplicate, delete.</p> <p> Click on this icon to display the status bar for the selected resource.</p>"},{"location":"intro/index.html#status-bar","title":"Status bar","text":"<p>When the status bar is expanded, it shows the current information about the selected  resource.</p> <p></p> <p>Every bit of the information about the resource will be available in the sidebar, starting with Metadata , then Status  and continuing with specification of the selected resource.</p>"},{"location":"intro/index.html#edit-page","title":"Edit page","text":"<p>Naturally, you will spend quite some time creating and editing resources. When you click Create button from the App page listing the resources or double click on the row in the grid, or choose Edit from the context menu, you will be presented with an Edit page:</p> <p></p> <p>This form has three main areas (from left to right):</p> <ol> <li>Navigation bar, aka Form fields</li> <li>Form view</li> <li>YAML view</li> </ol> <p>When editing or creating a resource, you would use either the Form view where every resource field is represented as a form field, or the YAML view where you can edit the resource in YAML format. You can start with a form view and continue in YAML editor, the changes are always synchronized.</p> <p>At the left bottom of this page you will find two buttons that allow you to either commit the resource straight away, or add it to a transaction basket.</p>"},{"location":"intro/index.html#transaction-basket","title":"Transaction basket","text":"<p>The transaction basket allows you to group resources together and commit them as a single transaction in an all-or-nothing fashion. Transactions are the key ingredient in EDA's mission to drive human error to zero.</p> <p>By adding resources to the transaction basket you can commit them all together or perform a Dry Run to ensure that the changes pass all sorts of validations before touching the network elements.</p> <p>The workflow below demonstrates how a VLAN resource gets added to the transaction basket, after which a dry run is performed to validate the transaction and then the diffs are browsed to understand the scope of the changes this transaction would result in should we have proceeded with the commit.</p>"},{"location":"intro/index.html#namespace-selector","title":"Namespace selector","text":"<p>When you first login to EDA as administrator, you have access to all available EDA namespaces. Since in this event you will only work in the default <code>eda</code> namespace, you can select it using the namespace selector as shown below:</p> <p></p> <p>By switching from All Namespaces to the <code>eda</code> namespace the UI will fill in the namespace name in the Edit Page when you will create new EDA resources.</p>"},{"location":"intro/index.html#reset-eda","title":"Reset EDA","text":"<p>As you go through the exercises, you will create and modify quite a few resources in EDA. It might happen that the resources from one unfinished challenge will interfere with the tasks you attempt next.</p> <p>In such cases you can manually delete conflicting resources, but if you want to reset EDA to a state as it was at the beginning of the event, you can easily do this by running the following command from the lab server:</p> <pre><code>TX_HASH=$(cat ~/kpn-mini-srx-hackathon/eda/eda-init-tx)\nedactl git restore $TX_HASH\n</code></pre> <p>This command will immediately revert all changes happened in EDA since you first logged in so you can start fresh.</p>"},{"location":"intro/index.html#where-to-next","title":"Where to next?","text":"<p>After this brief introduction to the EDA UI you are ready to start exploring the next generation of network automation by either starting \"The tour of EDA\" that we have prepared for you, or venturing into self-paced exploration.</p> <ol> <li> <p>Pending vendors' support for YANG and modern management interfaces.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/declarative-intents.html","title":"Declarative Intents","text":""},{"location":"intro/declarative-intents.html#declarative-abstracted-intents","title":"Declarative Abstracted Intents","text":"Short Description Declarative Abstracted Intents is the main EDA concept and it is used to define the behavior of a resource. Difficulty Beginner Topology Nodes  leaf1,  leaf2,  leaf3 Tools used EDA UI <p>The EDA framework was built around the core concepts of the declarative abstracted intents, event sourcing, loose coupling and transactions which set EDA aside from other traditional network automation systems.</p> <p>While many existing network automation frameworks still leverage the imperative configuration paradigm and state polling, we believe that the future of a reliable network automation lies in the event-based, declarative space.</p>"},{"location":"intro/declarative-intents.html#objective","title":"Objective","text":"<p>The goal of this exercise is to introduce you to the main EDA concepts such as declarative resource model, label-based coupling and transactions. By completing the set of tasks you will get a good understanding of the base EDA principles and explore the novel features of configuration management with declarative abstracted intents.</p> <p>No matter if you're coming from a traditional network engineering background, or you're a seasoned network automation engineer, we believe you will find something new in the way EDA-based network automation is done.</p>"},{"location":"intro/declarative-intents.html#technology-explanation","title":"Technology explanation","text":"<p>This exercise is titled Declarative Abstracted Intents as it is one of the main EDA concepts that enables the next-gen network automation. Let's dissect this term and explore what it means:</p> <ul> <li>The somewhat overloaded intent term refers to a user's input to the EDA automation system. Typically it is provided in the form of a configuration snippet done in one of the serializable data formats such as YAML, JSON, XML, etc.</li> <li> <p>The declarative part of the intent refers to a declarative configuration paradigm that prescribes that the input to the system should say what should be done, not how to do it.</p> <p>For example, compare the declarative and imperative forms of the same intent of configuring two interfaces on a network device:</p> declarativeimperative <pre><code>interfaces:\n  ethernet-1-1:\n    description: \"First interface\"\n  ethernet-1-2:\n    description: \"Second interface\"\n</code></pre> <pre><code>enter candidate\nset / interface ethernet-1/1 description \"First interface\"\nset / interface ethernet-1/2 description \"Second interface\"\ncommit now\n</code></pre> <p>The declarative form says what needs to be configured and leaving the \"how\" to the system, while the imperative form also needs to specify how to do it.</p> </li> <li> <p>The abstracted part of the intent serves two main purposes:</p> <ul> <li>simplify the intent by abstracting away the details of the network device or technology.</li> <li>make the intent vendor-agnostic, so that the same input can be used with many vendor devices.</li> </ul> </li> </ul>"},{"location":"intro/declarative-intents.html#eda-resources","title":"EDA Resources","text":"<p>In EDA, the declarative abstracted intents are implemented as Resources. Here is an example of the EDA Interface Resource that captures the declarative abstracted intent of configuring a physical interface on a network device:</p> <pre><code>apiVersion: interfaces.eda.nokia.com/v1alpha1\nkind: Interface\nmetadata:\n  name: leaf1-ethernet-1-31\n  namespace: eda\nspec:\n  description: inter-switch link to spine1\n  enabled: true\n</code></pre> <p>Observant readers will immediately notice that this EDA Resource is modeled after the Kubernetes Resource Model, which is a declarative model that describes the interfaces in Kubernetes.</p> <p>You see how this resource has the declarative and abstracted parts of the intent?</p>"},{"location":"intro/declarative-intents.html#loose-coupling","title":"Loose Coupling","text":"<p>Another important concept in EDA is loose coupling that is enabled by the use of Labels.</p> <p>The concept of a loose coupling says that the resources may be loosely coupled between each other. Instead of explicitly saying that the Resource-A depends on Resource-B and Resource-C, we can label the Resource-B and Resource-C with a label <code>BC</code> and in the Resource-A we can use the <code>BC</code> label to find the resources to act upon.</p> <p>The power of the loose coupling is that it allows for dynamic dependencies between the resources. If we suddenly add another resource labeled with <code>BC</code> label, the Resource-A will automatically pick up the new resource and act on it. Through the hackathon exercise you will see how this concept is used to a great effect.</p>"},{"location":"intro/declarative-intents.html#transactions","title":"Transactions","text":"<p>The holy grail of worry-free operations is atomic transactions. The worst thing that can happen during the automated configuration provisioning is a partially applied configuration due to not all nodes accepting the configuration.</p> <p>EDA solves this problem by adding a concept of Transactions. The user-submitted declarative intents are all transacted together and either all of them are applied by the nodes or all of them will be rolled back.</p> <p>The transaction-based model also allows for Dry Runs - seeing what changes will be rolled out to your network before actually applying them.</p>"},{"location":"intro/declarative-intents.html#eda-ui","title":"EDA UI","text":"<p>Every hackathon participant has access to an EDA instance and its interfaces. In this exercise you will be using EDA Web UI that you can reach over public Internet by navigating your browser to <code>https://{your-IP}:9443</code></p> <p>After a successful login you will see the main EDA UI page:</p> <p></p> <p>Clicking on the Menu icon toggles the side menu:</p> <p></p> <p>While you don't have a visual memory of the resource groups icons, using the side menu in the expanded view will help you navigate the UI. Also you will find the search bar at the top quite handy.</p>"},{"location":"intro/declarative-intents.html#tasks","title":"Tasks","text":"<p>Tired of theory? Time to back it up with practical challenges and learn the details by doing.</p>"},{"location":"intro/declarative-intents.html#adding-an-interface","title":"Adding an Interface","text":"<p>As a warmup, you are tasked with enabling additional interfaces on the leaf switches.</p> <p>These nodes already have a number of interfaces configured, let's find out what they are. Since EDA acts as a source of truth for all configuration on the managed nodes, we should see the list of already configured interfaces in the UI.</p> <p>In the left sidebar scroll down to the Topology resource group and select Interfaces resource. A table view with the list of interfaces configured in the system will appear, where we can filter the interfaces which name starts with <code>l</code> character that will narrow down the list to the interfaces.</p> <p></p> <p>We have selected the Interface resources on leaf switches that point to the client devices, and you can match these resources to the topology information:</p> EDA Managed nodes <p>Based on this information we can see that our leaf switches have interfaces <code>1</code>, <code>2</code>, <code>31</code> and <code>32</code> already configured either in the direction to the client or spine devices. So let's configure some non-connected interface on the leaf switches - for example, interface <code>ethernet-1/5</code>.</p>"},{"location":"intro/declarative-intents.html#query-interfaces-with-eql","title":"Query Interfaces with EQL","text":"<p>Before you proceed with creating the <code>ethernet-1/5</code> interface, let's query the interfaces on the leaf switches to make sure that there are no interfaces with the same name already configured.</p> <p>Typically you would connect to the leaf switches and run <code>show</code> commands, or use a custom script that does the same in a more automated way. But there is a better way to interrogate the network devices...</p> <p>EDA comes with a built-in network-wide query engine that allows you to query the network devices in a performant and scalable way. Using the sidebar navigation, go to the Queries page:</p> <p></p> <p>And paste the following in the EQL<sup>1</sup> Query input field:</p> <pre><code>.namespace.node.srl.interface fields [admin-state] where (.namespace.node.name in [ \"leaf1\",\"leaf2\",\"leaf3\" ] and .namespace.node.srl.interface.name = \"ethernet-1/5\")\n</code></pre> <p></p> <p>While this exercise is not about EQL specifically, it is a good opportunity to leverage the power of the query engine to understand the state of the network.</p> <p>You can see that all three leaves have interfaces <code>ethernet-1/5</code> in <code>admin-state=disable</code>. So you are clear to configure those interfaces!</p>"},{"location":"intro/declarative-intents.html#interface-resource-form","title":"Interface Resource Form","text":"<p>Go to the Topology -&gt; Interfaces menu item where before we looked at the configured interfaces and click the Create button to open the resource creation form. You can also use the search bar and filter for Interface:</p> <p></p> <p>The creation form has the following important panels:</p> <p></p> <p>The form has three distinct sections, as per the screenshot above, and as a user you will be using the form or YAML view to configure the resource and use the navigation to quickly navigate to the relevant fields.</p> <p>You can use the form and YAML views interchangeably, as every change made in one view will be reflected in the other.</p>"},{"location":"intro/declarative-intents.html#choosing-the-fields","title":"Choosing the Fields","text":"<p>The form has quite some number of fields, but not all of them are relevant to our task or required to be filled in. You must provide the following fields:</p> <ol> <li>Metadata \u2192 Name: the name of the interface resource.     This is not the name of the interface that you will see in the node's configuration, but a name of the Interface resource that will be created in EDA.     For example, since we are tasked to create an interface ethernet-1/5 on all leaf switches, for leaf1 we might want to name the interface resource as <code>leaf1-ethernet-1-5</code>.</li> <li>Specification \u2192 Members: a list of the port name + node name combinations that identify what ports to configure on which nodes</li> </ol>"},{"location":"intro/declarative-intents.html#interface-members","title":"Interface Members","text":"<p>If you chose to configure the interface via the form view, you have to click + Add button to invoke another modal window where interface members are configured.</p> <p>You will have to provide the Interface name in the normalized format, where spaces and <code>/</code> are replaced with <code>-</code>. For instance, <code>ethernet-1/5</code> should become <code>ethernet-1-5</code>.</p> <p>And after the interface name is sorted, you should provide the node name using the drop down menu.</p> <p></p> <p>When to use multiple members?</p> <p>You might have an urge to configure ethernet-1/5 port on multiple nodes by adding them as members, but this would be a mistake.</p> <p>The members interface list is used for LAG interfaces, the distinct interfaces should be configured with separate Interface resources.</p> <p>This means, that if you are configuring <code>interface-1/5</code> on <code>leaf1</code>, then your Interface resource may be named as <code>leaf1-ethernet-1-5</code>.</p> <p>When you fill in the required fields (name and members), you will see that the two buttons in the bottom right corner of the form will become active, allowing you to directly commit the changes or to add them to a transaction.</p> <p>Feel free to choose your path, but adding all the Interface resources you want to create to a single transaction is a good idea, since we want all the resources to be created in a single transaction.</p> <p>Continue adding other interfaces to the transaction bucket, you should have three interface resources in total.</p>"},{"location":"intro/declarative-intents.html#dry-run","title":"Dry Run","text":"<p>Once you added three interfaces to the transaction bucket you can Dry Run the transaction and see what your intended changes would look like.</p> <p></p> <p>Executing the Dry Run will either succeed or fail, with an icon indicating the result. The interesting part is checking the diffs</p> <p></p> <p>Looking at the diffs view should give you a precise idea of what changes will be made to the configuration:</p> <p></p> <p>The top three menu items in the left side bar will display configuration diff in the native config of the Network OS the changes will be applied to. In our case, it is SR Linux config that we are looking at and we see how all three nodes get additions of the <code>ethernet-1/5</code> interface!</p>"},{"location":"intro/declarative-intents.html#commit-transaction","title":"Commit Transaction","text":"<p>Remember, that we are browsing the diff of the Dry Run operations, none of the proposed changes have been applied to the nodes yet, they all have been deduced based on the known state kept in the EDA database.</p> <p>Since the change is looking good you can proceed with committing the configuration and applying the changes to the nodes by closing the Diff view and clicking on the Commit button.</p> <p>In a moment you will see a confirmation that the transaction was committed successfully. Now you can repeat the EQL query and check the admin state of the <code>ethernet-1/5</code> interface on all three nodes. They all should be <code>enabled</code> now.</p> <ol> <li> <p>EQL stands for EDA Query Language that is resembles other query languages like PromQL, Jira QL and so on.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/eda-query-language.html","title":"EDA Query Language","text":""},{"location":"intro/eda-query-language.html#eda-query-language","title":"EDA Query Language","text":"Short Description The EDA Query Language (EQL) enables real-time querying across the entire fleet of the managed nodes and EDB data. Estimated Time 30 minutes Topology Nodes  spine1,  spine2,  leaf1,  leaf2,  leaf3,  borderleaf1,  borderleaf2 Tools used EDA UI <p>The EDA Query Language (EQL) allows real-time access to any YANG path on any managed elements network-wide, or any resource published in the EDA in-memory Database (EDB). It delivers instant, streaming results ideal for troubleshooting and observability and can feed data to the EDA visualization dashboards or be streamed out to external consumers.</p>"},{"location":"intro/eda-query-language.html#objective","title":"Objective","text":"<p>The goal of this exercise is to introduce you to the The EDA Query Language (EQL) in which we will review the EQL concepts such as <code>Tables</code>, <code>Selectors</code> or <code>Filters</code>, and solve some real-world troubleshooting challenges. By completing a series of tasks, you\u2019ll gain a solid understanding of how to use EQL in your operations.</p>"},{"location":"intro/eda-query-language.html#technology-explanation","title":"Technology Explanation","text":""},{"location":"intro/eda-query-language.html#queries-page","title":"Queries page","text":"<p>The easiest way to run queries is right from the UI, in the Tools section, simply click <code>Queries</code>. You can also use the REST API or <code>edactl</code> command if you prefer.</p> <p></p> <p>The Queries UI consists of a query language selector and the query input fields. The query language selector allows to switch between the Natural Language and the EQL query language.</p> <p>As you might have guessed the Natural Language allows you to form a query using natural language, like \"How many BGP peers I have in my fabric?\". And if you prefer structured queries, EQL is your friend. It is a query language that supports operands, filters and selectors to create complex but precise queries.</p> <p>You will use both languages in the tasks we prepared for you.</p>"},{"location":"intro/eda-query-language.html#what-makes-up-a-query","title":"What Makes Up a Query?","text":"<p>A query in EQL is composed of several optional components, with only the first one being required:</p> <ul> <li> <p><code>Table</code> (required): The data source you're querying. Example: <code>.namespace.node.srl.interface</code></p> </li> <li> <p><code>Selector</code> (<code>fields</code> keyword): Specifies which fields to return, optionally applying functions to them. Example: <code>.namespace.node.srl.interface fields [oper-state, admin-state]</code></p> </li> <li> <p><code>Filter</code> (<code>where</code> keyword): Defines conditions for filtering results, using expressions within parentheses. Example: <code>.namespace.node.srl.interface where (admin-state = \"disable\" and .namespace.node.name = \"leaf1\")</code></p> </li> <li> <p><code>Sort</code> (<code>order by</code> keyword): Determines how the data should be ordered before being returned. Example: <code>.namespace.node.srl.platform.control.process order by [memory-usage descending]</code></p> </li> <li> <p><code>Limit</code> (<code>limit</code> keyword): Restricts the number of returned results. Example: <code>.namespace.node.srl.interface limit 10</code></p> </li> <li> <p><code>Frequency</code> (<code>delta</code> or <code>sample</code> keywords): Controls how often updates are returned, establishing a limit in the frequency of updates. Example: <code>.namespace.node.srl.interface delta milliseconds 1000</code>, or <code>sample milliseconds 1000</code> for updates at regular intervals, regardless of change.</p> </li> </ul> <p>If you fancy a deeper dive into the query components, continue reading; else, jump straight to the tasks.</p>"},{"location":"intro/eda-query-language.html#table","title":"Table","text":"<p>A Table is defined using JSPath notation. Table boundaries occur at each list or container element within a target node schema, or within containers/lists exposed by EDA applications.</p> <p>In simpler terms, each node in the JSPath hierarchy represents a distinct table. For example:</p> <ul> <li> <p><code>.namespace.node</code> is a table</p> </li> <li> <p><code>.namespace.node.srl</code> is another table</p> </li> <li> <p><code>.namespace.node.srl.interface</code> is yet another table</p> </li> </ul> <p>To specify a table, you use a complete JSPath expression without including keys. Example: <code>.namespace.node.srl.interface.subinterface</code> refers to the subinterface table.</p>"},{"location":"intro/eda-query-language.html#selector-fields","title":"Selector \u00b7 <code>fields</code>","text":"<p>A Selector is specified using the <code>fields</code> keyword. It defines an array of fields to be returned from the table, and may also include functions applied to those fields.</p> <p>All selected fields must exist in the table being queried, otherwise the query will fail.</p> <p>Only the fields explicitly listed will be returned. If no fields are specified, all fields from the table are returned by default.</p> <p>The <code>fields</code> keyword must come before any <code>where</code> or <code>order by</code> clauses.</p> <p>Example: <code>.namespace.node.srl.interface fields [admin-state, description] order by [oper-state ascending natural]</code></p> <p>You can also use functions within the fields array for evaluation and aggregation:</p> <p><code>average()</code> \u2014 Returns the average value of a field over time.</p> <p><code>count()</code> \u2014 Returns the number of unique matches for a given filter.</p> <p><code>sum()</code> \u2014 Calculates the sum of values for a specific field.</p> <p>These functions are useful for generating insights or summaries within your query results.</p> <p>Example: <code>.namespace.node.srl.interface fields [count(oper-state)] where (oper-state = \"up\")</code></p>"},{"location":"intro/eda-query-language.html#filter-where","title":"Filter \u00b7 <code>where</code>","text":"<p>A Filter defines criteria for narrowing down query results and is specified using the where keyword. The following rules apply:</p> <ul> <li>A filter is composed of an ordered sequence of fields, operators, values, and  keywords.</li> <li>Keywords like <code>and</code> and <code>or</code> are case-insensitive\u2014both <code>AND</code> and <code>and</code> are valid.</li> </ul> <p>Supported Operators:</p> <ul> <li>Comparison: <code>=</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;</code></li> <li>Logical: <code>and</code>, <code>or</code>, and parentheses <code>()</code> for grouping</li> <li> <p>Membership:</p> <ul> <li><code>in</code>: checks if a field's value is in a list of values</li> <li><code>not in</code>: checks if a field's value is not in a list</li> </ul> </li> </ul> <p>Field names are written without quotes, while values are quoted if they are strings and left unquoted if they are integers. Example: <code>.namespace.node.srl.interface where ((oper-state = \"up\") and (ifindex = 49150))</code></p> <p>As you can see, from the previous example, Filters can combine multiple conditions using parentheses and logical operators.</p> <p>Warning</p> <p>Even a single condition must be enclosed in parentheses: <code>.namespace.node.srl.interface where (oper-state = \"up\")</code></p>"},{"location":"intro/eda-query-language.html#sort-order-by","title":"Sort \u00b7 <code>order by</code>","text":"<p>A Sort determines the order in which results are returned, rather than filtering which data is selected. It is specified using the <code>order by</code> keyword.</p> <p>You can include one order by clause per query. Its value is an array of fields, sorting directions, and (optionally) sorting algorithms, evaluated in the order provided.</p> <p>Example: <code>.namespace.node.srl.interface order by [oper-state ascending natural]</code></p> <p>The second element specifies the sort direction: <code>ascending</code> or <code>descending</code>.</p> <p>The third element is optional and currently supports only <code>natural</code> as a sorting algorithm.</p>"},{"location":"intro/eda-query-language.html#limit-limit","title":"Limit \u00b7 <code>limit</code>","text":"<p>The limit keyword restricts the number of results returned by a query. It is applied after all other operations, such as sorting.</p> <p><code>limit</code> takes a single integer value. When combined with order by, it allows you to retrieve the top N or bottom N results, depending on the sort direction.</p> <p>The valid range for limit is <code>1 to 1000</code>. Values outside this range will result in an error.</p> <p>Example: <code>.namespace.node.srl.interface order by [mtu descending] limit 10</code></p>"},{"location":"intro/eda-query-language.html#frequency-deltasample","title":"Frequency \u00b7 <code>delta</code>/<code>sample</code>","text":"<p>The <code>delta</code> keyword controls how frequently query results are updated. It takes two arguments: a unit ( milliseconds) and a value representing the limit of the response rate.</p> <p>For example: <code>.namespace.node.srl.interface.traffic-rate where (in-bps != 0) delta milliseconds 1000</code> This means the client will receive updates no more than once per second.</p> <p>Use delta to avoid overloading the client with rapid updates and to fine-tune the refresh rate for your use case.</p>"},{"location":"intro/eda-query-language.html#navigating-the-eda-database","title":"Navigating the EDA Database","text":"<p>After we covered a lot of theory on the query components, the next step is identifying where the relevant data resides within the EDB. The following table lists some most relevant tables/paths:</p> <p>EDA Queries Cheatsheet</p> Path Description .cluster Holds information about cluster metrics and config/state engine. For example, we can get k8s pod status with <code>.cluster.apps.platform.metrics.namespace.pod</code> or we can get execution metrics of the state engine with <code>.cluster.state-engine.v1.script</code> .namespace The root path for all our namespaced resources. .namespace.apps Access config and state information published by the EDA Apps .namespace.alarms All the alarms raised by nodes are written in this table. For example, we can get current alarms with <code>.namespace.alarms.v1.current-alarm</code> or past ones with <code>.namespace.alarms.v1.alarm.history</code> .namespace.allocations Access EDA allocations pools information (irb indexes, ip pools, bgp asn numbers\u2026). We can retrieve the information with <code>.namespace.allocations.v1.template.instance</code> .namespace.node Get real time access to node's config and state. For example, to get all state info about the SR Linux interfaces - <code>.namespace.node.srl.interface.subinterface</code> or display the statistics of all the interfaces with <code>.namespace.node.srl.interface.statistics</code>To change the network OS, simply replace the operating system name, e.g. <code>.namespace.node.sros</code> for Nokia SR OS, or <code>eos</code> for Arista EOS. .namespace.resources A table that contains the state and specifications of all EDA Custom Resources. For example, we can check the health of our Fabric with <code>.namespace.resources.cr.fabrics_eda_nokia_com.v1alpha1.fabric fields [ status.health ]</code> or see the list of BridgeDomains configured in our Fabric with <code>.namespace.resources.cr.services_eda_nokia_com.v1.bridgedomain</code> .namespace.topologies.topology Everything related to the Topologies tool in EDA dashboard goes here"},{"location":"intro/eda-query-language.html#tasks","title":"Tasks","text":"<p>Done with the theory, let's put things into practice!</p> <p>Imagine this: it\u2019s 3:00 AM, and you\u2019re in the middle of a migration window, moving VMs from one server cluster to another. These servers are connected to multiple leaf switches via a Layer 2 EVPN service (mac-vrf = <code>macvrf1</code>). Based on your experience, you know that a good way to monitor the migration\u2019s progress is by tracking the total number of MAC addresses learned in the service, and closely watching a few specific MACs to see how they shift between switches.</p> <p>Typically you would do this by connecting to every switch and do <code>show</code> commands or have a script that will fetch the show commands and parse the output. With EDA Queries, we can do it centrally, in a fast, performant and always accurate way.</p>"},{"location":"intro/eda-query-language.html#task-1-query-mac-addresses-in-a-specific-mac-vrf-service","title":"Task 1: Query MAC addresses in a specific mac-vrf service","text":"<p>In this first exercise you have to perform a query that shows you all MAC addresses in the bridge table of the <code>macvrf1</code> deployed in your DC fabric. This service is already present in <code>leaf1</code>, <code>leaf2</code>, and <code>leaf3</code>.</p> <p>Empty bridge table</p> <p>Since this instance was recently spun up, chances are high that the bridge table is empty. Log into one of the clients, and ping another. E.g. <pre><code>ssh admin@client1\nping 10.64.30.12\n</code></pre></p> Hints <p>The command we would need to execute in our SR Linux switches is: <code>show network-instance macvrf1 bridge-table mac-table all</code>.</p> <p>We need to filter to only show <code>macvrf1</code>, so we need to use the <code>where</code> keyword.</p> Solutions <p>The EQL for this is:</p> <pre><code>.namespace.node.srl.network-instance.bridge-table.mac-table.mac where(.namespace.node.srl.network-instance.name = \"macvrf1\")\n</code></pre>"},{"location":"intro/eda-query-language.html#natural-language","title":"Natural Language","text":"<p>Remember that Natural Language language selector? It allows you to phrase your queries, well, naturally. So instead of thinking what would the query look like to get all MACs in a certain bridge domain, you could've simply asked:</p> <pre><code>show me all macs in the macvrf1 bridge domain\n</code></pre> <p>You should get the same result, as what NQL does is translates the natural language to a EQL query and runs it. A perfect way to learn and refine future queries.</p>"},{"location":"intro/eda-query-language.html#task-2-select-specific-fields-to-be-displayed-in-mac-table","title":"Task 2: Select specific fields to be displayed in MAC table","text":"<p>Now that you\u2019ve retrieved the full list, refine your query to display only the essential details, such as the MAC address and the interfaces where each is learned.</p> Hints <p>You need to use the <code>fields</code> keyword. The field we are interested in is the <code>destination</code></p> Solutions <p>The EQL for this is:</p> <pre><code>.namespace.node.srl.network-instance.bridge-table.mac-table.mac fields [destination] where (.namespace.node.srl.network-instance.name = \"macvrf1\")\n</code></pre> <p>You can also try and use the NQL for this task.</p>"},{"location":"intro/eda-query-language.html#task-3-count-entries-in-mac-table","title":"Task 3: Count entries in MAC table","text":"<p>Now, you want to see if all the macs are there, and you know that in a stable condition you have 21 MACs in your mac-vrf. Count the macs in your mac-vrf.</p> Hints <p>You need to use the <code>count()</code> keyword to count the number of responses for a given EQL.</p> Solutions <p>The EQL for this is:</p> <pre><code>.namespace.node.srl.network-instance.bridge-table.mac-table.mac fields [count(destination)] where (.namespace.node.srl.network-instance.name = \"macvrf1\")\n</code></pre>"},{"location":"intro/eda-query-language.html#task-4-track-specific-macs-in-your-mac-vrf","title":"Task 4: Track specific MACs in your mac-vrf","text":"<p>And now, let's build a query to keep track of specific MAC addresses in our <code>macvrf1</code> service. Select any MAC address displayed in your Task 2 exercise and build a query that only displays that one.</p> Hints <p>We need to use parentheses <code>()</code> and <code>and</code> to group multiple terms</p> Solutions <p>The EQL for this is:</p> <pre><code>.namespace.node.srl.network-instance.bridge-table.mac-table.mac fields [destination] where ((.namespace.node.srl.network-instance.name = \"macvrf1\") and (address = \"AA:C1:AB:E0:66:72\"))\n</code></pre>"},{"location":"intro/eda-query-language.html#bonus-task-do-it-in-the-cli","title":"Bonus Task: do it in the cli","text":"<p>We can use the <code>edactl</code> command to perform all the different queries that we have tested. You just have to SSH to your own dedicated VM running the lab topology and type:</p> <p><code>edactl query 'your query here'</code></p> <p>You can optionally use the following Flags:</p> <ul> <li><code>-r &lt;value&gt;</code>: to set the max number of rows visible on the terminal (default 20)</li> <li><code>-s</code>: to stream query results</li> </ul>"},{"location":"intro/eda-query-language.html#summary","title":"Summary","text":"<p>This exercise introduces the EDA Query Language (EQL), a powerful tool for real-time querying across managed network elements and the EDA in-memory Database (EDB).</p> <p>You learned the key components that EQL consists of, such as:</p> <ul> <li>Tables: Data sources you're querying (e.g., .namespace.node.srl.interface)</li> <li>Selectors: Fields to return using the fields keyword</li> <li>Filters: Conditions for filtering results using the where keyword</li> <li>Sort: Ordering of results using order by</li> <li>Limit: Restricting number of results using limit</li> <li>Frequency: Controlling update frequency using delta or sample</li> </ul> <p>Practiced running the queries using two different query languages:</p> <ul> <li>EQL: Structured query language with precise syntax</li> <li>Natural Language: Alternative interface for forming queries in plain English</li> </ul> <p>And used <code>edactl</code> to run the queries in the CLI.</p>"},{"location":"intro/label-based-selection.html","title":"Label-based Selection","text":""},{"location":"intro/label-based-selection.html#label-based-selection","title":"Label-based Selection","text":"Short Description Loose coupling of resources delivers flexible relationships between resources.At the helm of this concept sits labeling mechanism that is widely used in microservices and container orchestration. Difficulty Beginner Topology Nodes  spine1,  spine2,  leaf1,  leaf2,  leaf3,  borderleaf1,  borderleaf2 Tools used EDA UI <p>On a broader scale the relationship between the resources can either be tightly coupled or loosely coupled.</p> <p>The tight coupling binds the resources explicitly to each other, typically using a unique identifier. An example of a tight coupling all of you might have used in the past is an inventory system that lists the IP addresses of the devices that you target with your automation scripts. The tight coupling allows for a more deterministic selection of the target nodes your automation acts against, but it is less flexible and requires more effort to maintain.</p> <p>The loose coupling binds the resources implicitly to each other, typically using a concept of a label or tag. An example of a loose coupling would select a label as a target for your automation, and the objects that were having this tag would be the ones that your automation would act against. The loose coupling allows for flexible and dynamic target selection, making it easier to adapt to changes in the network topology and provide more cloud-native resource management.</p>"},{"location":"intro/label-based-selection.html#objective","title":"Objective","text":"<p>The goal of this exercise is to introduce you to the concept of loose coupling of resources and how it is achieved in EDA via the concept of labels. You will see how labels are first class citizen in EDA with every resource having an option of being tagged with one or more labels.</p>"},{"location":"intro/label-based-selection.html#technology-explanation","title":"Technology Explanation","text":"<p>The concept of label-based loose coupling is not new. You may have used it when managing resources in the cloud provider of your choice or with the security platforms where resource tags are used to group resources together. Overall, the concept of tags/labels is well known especially in the cloud-native domain where resources are managed at scale.</p> <p>From the technical perspective, labels are typically implemented as key/value pairs that are attached to a resource and become part of the resource's metadata. A resource with a label is often called labeled or tagged resource.</p> <p>A resource may have none, one or more labels attached to it. The automation system then can select resources using the label selectors and not by pointing to a unique resource identifier (IP or name). Due to the fact that labels are key/value pairs, they have to be uniquely keyed, for example having a set of labels like:</p> <ul> <li><code>nic-type=storage</code></li> <li><code>nic-type=100G</code></li> </ul> <p>is not valid, since the two labels have the same key <code>nic-type</code>. You should choose different keys for the labels.</p> <p>In the diagram below you see how EDA leverages labels to select resources for its intents. The EDA-managed nodes - leafs, borderleaf and spine elements, are labeled with a label that encodes the role of the device (e.g. <code>eda.nokia.com/role=spine</code> for the spine devices)</p> Label-based coupling <p>With the resource being uniformly labeled, EDA can select resources for its intents using the label selectors, instead of specifying the target nodes by their IP addresses or names.</p>"},{"location":"intro/label-based-selection.html#labeled-resources-in-eda","title":"Labeled resources in EDA","text":"<p>You will see labeled resources a lot in EDA, but probably the first time you get to see and interact with labels is when you look at the list of nodes managed by EDA.</p> <p>Note</p> <p>Labels are assigned by an operator or a system that creates the resource.</p> <p>Have one more look at the diagram above that depicts a leaf-spine topology managed by EDA and let's find this list of nodes in the EDA UI.</p> <p>When logged into the EDA UI you can find the list of nodes managed by EDA using the left side bar navigation and selecting Targets \u2192 Nodes menu.</p> <p></p> <p>You should see the familiar node names (we call these resources TopoNodes) as depicted in the diagram above and the associated metadata, specification and status. In the same table view you can find the Labels column that shows the labels attached to each node; they are collapsed under the <code>+5</code> icon, which means there are 5 labels attached to each node and there is no space to display them all in line.</p> <p>If you hover over this icon you should see the list of labels, but you can also select the Configuration View menu element at the end of each row to see the expanded view of the TopoNode resource:</p> <p></p> <p>In the configuration view labels are shown expanded, and we can see all five of them listed there, each carrying our some meaning:</p> <p></p> <p>For the selected <code>leaf3</code> node, the important label it has attached to it is:</p> <ul> <li><code>eda.nokia.com/role = leaf</code> - this label carries out the role of the node in the topology and has a key - <code>eda.nokia.com/role</code> and a value - <code>leaf</code>.</li> </ul> <p>When onboarding the nodes of the topology to EDA we manually assigned labels to each nodes to identify their role and make it possible for EDA to select the nodes for the intents based on these labels.</p>"},{"location":"intro/label-based-selection.html#tasks","title":"Tasks","text":"<p>You will find EDA both strict and loose coupling used in EDA. Often the same intent will offer you the choice of using either approach. In the following tasks you will be using label-based selection to select the resources for your intents as well as using strict coupling based on element names.</p>"},{"location":"intro/label-based-selection.html#configure-login-banner-on-a-single-element","title":"Configure Login Banner on a single element","text":"<p>Your first task is to configure a Login Banner on a single - <code>spine1</code> - element. You will find the Banners resource in the sidebar menu under the Site Profiles group.</p> <p>Don't know what a resource is? Check out the Declarative Intents exercise.</p> <p>Click the Create button to open the resource editor. In the specification section of the Banner resource you will find both strict and loose coupling options for you to choose:</p> <p></p> <p>Since you are tasked with configuring a Login Banner on a single spine element, choose the the option that will allow you to specify the target element by its name.</p> <p>After selecting the <code>spine1</code> element, commit your changes.</p>"},{"location":"intro/label-based-selection.html#verification","title":"Verification","text":"<p>Once the changes have been committed, you can verify the changes using the network-wide queries. EDA comes with a built-in network-wide query engine that allows you to query the network devices in a performant and scalable way. Using the sidebar navigation, go to the Queries resource and paste the following in the EQL<sup>1</sup> Query input field:</p> <pre><code>.namespace.node.srl.system.banner fields [ login-banner ] #(1)!\n</code></pre> <ol> <li>This query will return the value of the <code>/system/banner/login-banner</code> field from all SR Linux nodes managed by EDA.</li> </ol> <p>You should see only <code>spine11</code> feature the <code>login-banner</code> message, as other nodes shouldn't have been targeted by the Banner resource you have created.</p> <p></p>"},{"location":"intro/label-based-selection.html#configure-login-banner-on-multiple-elements","title":"Configure Login Banner on multiple elements","text":"<p>Now that you have configured a Login Banner on a single spine element using the strict coupling with a node name, your next task is to configure a Login Banner on all leaf nodes.</p> <p>You will use the loose coupling enabled by the labels to achieve that. Recall the labeling scheme we covered in the technology explanation section where all leaf nodes have the <code>eda.nokia.com/role=leaf</code> label.</p> <p>Go on and edit the Banner resource you created in the first task and add the Node Selector field with the label all leaf nodes have in common. After you added the Node Selector, add the change to the transaction and run the Dry Run to ensure that all three leaf nodes will be targeted with the same banner.</p> <p>Don't know how to use the Dry Run feature? Check out the Declarative Intents exercise first.</p> <ol> <li> <p>EQL stands for EDA Query Language that is resembles other query languages like PromQL, Jira QL and so on.\u00a0\u21a9</p> </li> </ol>"},{"location":"intro/srl-cli.html","title":"SR Linux CLI","text":"Short Description Introduction to SR Linux CLI Estimated Time 15 minutes Topology Nodes  leaf1,  leaf2,  leaf3,  borderleaf1,  borderleaf2,  spine1,  spine2 <p>Note</p> <p>The focus of this hackathon is mainly on EDA. For your background knowledge, this activity is provided as a reference to SRL CLI. Use this page as a handy reference, but don't loose too much time on this. Briefly read through it and complete the tasks where you will configure an interface using the CLI.</p> <p>Before we jump into our fabric management tool <code>EDA</code>, it can still be beneficial to have an introduction to SR Linux' CLI.</p> <p>Over the past years the industry has seen numerous attempts to sacrifice the CLI to the SDN and/or automation gods. We believe that CLI is here to stay, and we must evolve it and make it powerful, modern, programmable, and highly customizable.</p> <p>With the ambitious goal of making SR Linux CLI the pinnacle of the text-based interfaces, we knew it would look different from the traditional CLI. But fear not, the powers that come with SR Linux CLI outweigh the little effort it takes to make your fingers memorize new commands.</p> <p>Highly customizable CLI</p> <p>SR Linux CLI is highly customizable, you can change the prompt, add new commands, create aliases, etc. If you miss a feature - join our Discord community and let us know!</p>"},{"location":"intro/srl-cli.html#prompt","title":"Prompt","text":"<p>The first thing you will see when logged into SR Linux is its default two-line prompt and a CLI status toolbar.</p> Default SR Linux prompt <p>The prompt' picture title reads \"default\", because it is highly customizable. For the purpose of this guide, we will use the default prompt and leave prompt customization for later. The annotations in the picture provide a brief explanation of each part of the prompt, and we provide a more detailed through the rest of this guide.</p>"},{"location":"intro/srl-cli.html#help","title":"Help","text":"<p>When you first log into an unknown OS, you want to know what commands are available to you. In SR Linux, there are several context-aware help commands and key bindings that can help you navigate the CLI.</p> <p>Hitting the ? in the CLI will list all available local commands: <pre><code>--{ running }--[  ]--\nA:admin@leaf1# &lt;pressed ? key&gt;\nLocal commands:\n  acl               Top level container for configuration and operational state related to access control lists (ACLs)\n  bfd               Context to configure BFD parameters and report BFD sessions state\n  interface         The list of named interfaces on the device\n  network-instance  Network instances configured on the local system\n  platform          Enclosing container for platform components\n  qos               Top-level container for QoS data\n  routing-policy    Top-level container for all routing policy configuration\n  system            Enclosing container for system management\n  tunnel            This model collects all config and state aspects of the tunnel table\n  tunnel-interface  In the case that the interface is logical tunnel\n\n*** Not all commands are listed, press '?' again to see all options ***\n</code></pre></p> <p>Local commands are actual configuration elements available in the present working context. See this <code>[  ]</code> in the prompt? That means the user is in root context, and local commands that are available in the <code>running</code> mode for the root context are listed.</p> <p>If you press ? again, you will see all available commands, local and global:</p> <pre><code>--{ running }--[  ]--\nA:admin@leaf1# &lt;pressed ? key&gt; &lt;pressed ? key again&gt;\nLocal commands:\n  acl               Top level container for configuration and operational state related to access control lists (ACLs)\n  bfd               Context to configure BFD parameters and report BFD sessions state\n # clipped\n  tunnel-interface  In the case that the interface is logical tunnel\n\nGlobal commands:\n  !                 History substitution\n  /                 Moves you to the root\n  back              Return to previous context\n  bash              Open bash session\n# clipped\n  environment       Control the look-and-feel of the CLI\n</code></pre> <p>Global commands, as the name implies, are available in any context. They are not tied to a specific context.</p>"},{"location":"intro/srl-cli.html#suggestions-and-completions","title":"Suggestions and completions","text":"<p>Something that you will notice when hitting TAB is the auto-suggestion form that is common in powerful shells like zsh/fish but was not available in any other NOS CLI until now.</p> <p>The suggestion popup shows global and local commands available in the current context. In other words, it is context aware. Since we are still sitting in the root context (<code>[  ]</code> indicates that), the suggestion popup shows all available commands in the root context.</p> <p>You can use the arrow keys (&lt;--&gt;, etc) to navigate the suggestions and press ENTER to select a suggestion.</p> <p>Besides the suggestions, SR Linux comes with the smart autocompletion system. Again, something that modern shells offer you on *nix systems. When you start typing a command, the CLI will suggest the next command right in the command line using the same context-aware suggestions.</p> <p>And if you are a fast typer, autocompletion engine will try to fix typos for you whenever it can.</p>"},{"location":"intro/srl-cli.html#cli-modes","title":"CLI modes","text":"<p>SR Linux CLI has three main modes that a user can be in:</p> <ul> <li>running</li> <li>candidate (aka configuration)</li> <li>state</li> </ul>"},{"location":"intro/srl-cli.html#running","title":"Running","text":"<p>When a user logs into SR Linux, they start in the <code>running</code> mode. This is the mode in which the user can use operational and show commands, view configuration and perform actions via <code>/tools</code> commands, but they can not perform any configuration changes.</p> <p>Similar to...</p> <p>This mode is similar to the enable mode (in Cisco/Arista) or the operational mode (Juniper Junos). The prompt and the toolbar show <code>running</code> when the user is in this mode.</p> <p>As said, in this mode a user can execute operational and show commands. To give you a few examples:</p> <code>ping</code><code>show version</code> <pre><code>Ping is an operational command.\n\n--{ running }--[  ]--\nA:admin@leaf1# ping network-instance mgmt 10.128.1.1\nUsing network instance mgmt\nPING 10.128.1.1 (10.128.1.1) 56(84) bytes of data.\n64 bytes from 10.128.1.1: icmp_seq=1 ttl=64 time=5.59 ms\n64 bytes from 10.128.1.1: icmp_seq=2 ttl=64 time=1.26 ms\n</code></pre> <pre><code>--{ running }--[  ]--\nA:admin@leaf1# show version\n----------------------------------------------------------\nHostname             : leaf1\nChassis Type         : 7220 IXR-D3L\nPart Number          : Sim Part No.\nSerial Number        : Sim Serial No.\nSystem HW MAC Address: 1A:95:08:FF:00:00\nOS                   : SR Linux\nSoftware Version     : v25.10.1\nBuild Number         : 399-g90c1dbe35ef\nArchitecture         : x86_64\nLast Booted          : 2026-01-09T16:55:30.656Z\nTotal Memory         : 65726332 kB\nFree Memory          : 44092148 kB\n----------------------------------------------------------\n</code></pre>"},{"location":"intro/srl-cli.html#candidate","title":"Candidate","text":"<p>The <code>candidate</code> mode is the mode in which a user performs configuration changes in the candidate datastore. To enter this mode use the <code>enter</code> global command and provide the mode as an argument.</p> Enter candidate mode from running mode<pre><code>--{ running }--[  ]--\nA:admin@leaf1# enter candidate\n\n--{ candidate shared default }--[  ]--\nA:admin@leaf1#\n</code></pre> <p>You can immediately notice how the prompt changed. Now it shows the following information:</p> <ul> <li><code>candidate</code> - the mode in which the user is in</li> <li><code>shared</code> - the type of the candidate datastore is shared<sup>1</sup></li> <li><code>default</code> - the name of the candidate datastore</li> </ul> <p>We will show you how to perform configuration changes when we get to the Interfaces section. You can check your configuration changes by comparing the running config with the candidate config using the <code>diff</code> command.</p>"},{"location":"intro/srl-cli.html#state","title":"State","text":"<p>The last mode we are going to meet is the <code>state</code> mode. This mode is similar to the <code>running</code> mode as the user can view configuration, execute operational and show commands. But in addition to that, the user can also view the state information, that is the values that are non-configurable, but are calculated by the system.</p> <p>Think about counters, like interface statistics, or the system uptime, or BGP peering state. These are state information and these values are accessible in the <code>state</code> mode.</p> Enter candidate mode from running mode<pre><code>--{ running }--[  ]--\nA:admin@leaf1# enter state\n\n--{ state }--[  ]--\nA:admin@leaf1#\n</code></pre> <p>Changing between CLI modes</p> <p>Typing <code>enter &lt;target-mode&gt;</code> anywhere in the CLI will change the current mode to the target mode.</p>"},{"location":"intro/srl-cli.html#navigation-and-contexts","title":"Navigation and Contexts","text":"<p>Upon logging into SR Linux, you start in the root context, as indicated by the <code>[  ]</code> part of prompt. Using the CLI help commands, you can explore what commands and contexts are available to you from your current context.</p> <p>SR Linux is a fully modelled Network OS</p> <p>Since SR Linux Network OS operates on a 100% YANG-modelled infrastructure, its CLI strictly follows the YANG model and the YANG model is a tree-like hierarchical structure.</p> <p>As shown in the Help section before, you can list the local commands available in the current context using ? key. For example, in the root context of the running mode you get the following:</p>"},{"location":"intro/srl-cli.html#entering-contexts","title":"Entering contexts","text":"<p>What you see in the list of the local commands are contexts that you can enter by typing the name of the context. For example, if you want to enter the <code>interface</code> context, you can do so by typing <code>interface</code>:</p> <p>If you click TAB or Space after typing <code>interface</code> the CLI will prompt you with the <code>&lt;name&gt;</code> key, indicating that the <code>interface</code> is a list element and you need to provide the interface name as an argument.</p> <p>Clicking TAB again will show you the configured interfaces present in the system in the autosuggestion window:</p> <p>Let's select <code>mgmt0</code> or type it in and press Enter to enter the <code>interface mgmt0</code> context.</p> <pre><code>--{ running }--[  ]--\nA:admin@leaf1# interface mgmt0\n\n--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1#\n</code></pre> <p>The prompt changed to show the current context - <code>[ interface mgmt0 ]</code>. Recall, that SR Linux CLI is context-aware, therefore using the ? key now will show you the different local commands, as you are standing in a different current context.</p> <pre><code>--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1# &lt;pressed ? key&gt;\nLocal commands:\n  admin-state*      The configured, desired state of the interface\n  description*      A user-configured description of the interface\n  ethernet\n  lag               Container for options related to LAG\n  loopback-mode*    Loopback mode of the port\n  mtu*              Port MTU in bytes including ethernet overhead but excluding 4-bytes FCS\n  qos\n  sflow             Context to configure sFlow parameters\n  subinterface      The list of subinterfaces (logical interfaces) associated with a physical interface\n  tpid*             Optionally set the tag protocol identifier field (TPID) that\n  transceiver\n  vlan-tagging*     When set to true the interface is allowed to accept frames with one or more VLAN tags\n</code></pre> <p>You're again present with a list of local commands, but this time you can spot an asterisk (<code>*</code>) next to some of the commands. These are the stub contexts (leafs and leaf-lists) that you can not enter to.</p> <p>Let's go one level deeper by entering into the <code>subinterface</code> context of our <code>mgmt0</code> interface.</p> <p>By typing <code>subinterface</code> and pressing TAB you will see autosuggested subinterface index <code>0</code> automatically selected. This is because <code>mgmt0</code> interface has only one subinterface configured and it is <code>0</code><sup>2</sup>. By clicking TAB after again you will accept the suggestion and hitting Enter will enter the <code>subinterface 0</code> context.</p> Accept suggested subinterface index with TAB key<pre><code>--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1# subinterface 0\n</code></pre> <p>Now the prompt changed to show the current context - <code>[ interface mgmt0 subinterface 0 ]</code>.</p> <pre><code>--{ running }--[ interface mgmt0 subinterface 0 ]--\nA:admin@leaf1#\n</code></pre>"},{"location":"intro/srl-cli.html#exiting-contexts","title":"Exiting contexts","text":"<p>To exit from the current context use <code>exit</code> command, that takes an optional argument of <code>to</code>. Consider the following example where we are in the <code>interface mgmt0 subinterface 0</code> context and we want to exit one step above to the <code>interface mgmt0</code> context.</p> <code>exit</code> brings you one level up in the context hierarchy<pre><code>--{ running }--[ interface mgmt0 subinterface 0 ]--\nA:admin@leaf1# exit\n--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1#\n</code></pre> <p>If you want to exit to a specific parent context from the current one, you can leverage <code>exit to</code> variant:</p> <pre><code>--{ running }--[ interface mgmt0 subinterface 0 ]--\nA:admin@leaf1# exit to &lt;context&gt;\n                       interface\n                       root\n</code></pre> <p>The autosuggestion window will list all parent contexts (<code>interface</code>, <code>root</code>) that you can exit to from your current context.</p> <p>And lastly, you can also navigate to whatever context from any other context by providing the absolute path to the target context. The absolute path starts with <code>/</code>. The example below will switch the context from <code>interface mgmt0 subinterface 0</code> to <code>system information</code>.</p> <pre><code>--{ running }--[ interface mgmt0 subinterface 0 ]--\nA:admin@leaf1# / system information\n\n--{ running }--[ system information ]--\nA:admin@leaf1#\n</code></pre>"},{"location":"intro/srl-cli.html#command-scope","title":"Command scope","text":"<p>When you're in a context, your commands are scoped to that context. For example, if we are currently sitting in the <code>[ interface mgmt0 subinterface 0 ]</code> context, then the <code>tree</code> command that prints the tree of available child elements will start from our present context:</p> <pre><code>--{ running }--[ interface mgmt0 subinterface 0 ]--\nA:admin@leaf1# tree\nsubinterface\n+-- type\n+-- description\n+-- admin-state\n+-- ip-mtu\n+-- l2-mtu\n+-- ipv4\n|  +-- admin-state\n# clipped\n</code></pre> <p>If you want to change the context of a given command you provide the context as an argument. Using the same <code>tree</code> command we can list the available child elements of the <code>system information</code> context by providing the absolute path to the target context:</p> <pre><code>--{ running }--[ interface mgmt0 subinterface 0 ]--\nA:admin@leaf1# tree /system information\ninformation\n+-- contact\n+-- location\n</code></pre> <p>Even <code>show</code> commands that we will explore later are context-aware. For example, within our <code>[ interface mgmt0 subinterface 0 ]</code> context, the <code>show version</code> command that every NOS has will yield the error:</p> <pre><code>--{ running }--[ interface mgmt0 subinterface 0 ]--\nA:admin@leaf1# show version\nParsing error: Unknown token 'version'.\nOptions are ['#', '..', '/', '&gt;', '&gt;&gt;', 'all', 'brief', 'detail', 'queue-detail', '|', '}']\n</code></pre> <p>And that is because in the current context there is no <code>version</code> command that <code>show</code> can execute. The <code>version</code> show report belongs to the root context, so to successfully execute it we need to be in the root context, or provide the fully-qualified-context-path:</p> <pre><code>--{ running }--[ interface mgmt0 subinterface 0 ]--\nA:admin@leaf1# show / version\n-----------------------------------------------------\nHostname             : leaf1\nChassis Type         : 7220 IXR-D2L\nPart Number          : Sim Part No.\nSerial Number        : Sim Serial No.\n# clipped\n</code></pre>"},{"location":"intro/srl-cli.html#info-command","title":"<code>info</code> command","text":"<p>The <code>info</code> command is your swiss army knife when you are in the CLI jungles. You would use it to get both configuration and state information available on the SR Linux device. Let's see how it works.</p> <p>While we are in the running mode, lets go once again to the <code>mgmt0</code> interface context:</p> <pre><code>--{ running }--[  ]--\nA:admin@leaf1# interface mgmt0\n\n--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1#\n</code></pre> <p>Now let's run the <code>info</code> command:</p> <pre><code>--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1# info\n    admin-state enable\n    subinterface 0 {\n        admin-state enable\n        ip-mtu 1500\n        ipv4 {\n            admin-state enable\n            dhcp-client {\n            }\n        }\n        ipv6 {\n            admin-state enable\n            dhcp-client {\n            }\n        }\n    }\n</code></pre> <p>Look at that, we just listed the running configuration of the <code>mgmt0</code> interface. Which brings us to the conclusion #1: In running CLI mode, the <code>info</code> command shows the running configuration of the current context.</p> <p>What happens, if we switch to the <code>state</code> mode right from the <code>interface mgmt0</code> context and run the <code>info</code> command there?</p> <pre><code>--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1# enter state\n\n--{ state }--[ interface mgmt0 ]--\nA:admin@leaf1# info\n    admin-state enable\n    mtu 1514\n    ifindex 1077952510\n    oper-state up\n    last-change \"2024-09-25T14:28:40.810Z (21 hours ago)\"\n    statistics {\n        in-packets 622\n        in-octets 63571\n        in-unicast-packets 231\n        in-broadcast-packets 36\n        in-multicast-packets 141\n        in-discarded-packets 211\n        in-error-packets 3\n        in-fcs-error-packets 0\n# clipped\n    }\n    sflow {\n        admin-state disable\n    }\n</code></pre> <p>Nice, way more information, and that is because the <code>info</code> command returns state elements of the current context (and its children) when executed in the <code>state</code> CLI mode.</p> <p>SR Linux State = configuration + state</p> <p>It is important to remember, that unlike SR OS, in SR Linux the state contains both configuration and state values. Hence when you execute the <code>info</code> command in the <code>state</code> CLI mode, you will see configuration values such as <code>admin-state</code> and <code>mtu</code> and also state values such as <code>oper-state</code>, and <code>statistics</code>.</p>"},{"location":"intro/srl-cli.html#from","title":"from","text":"<p>Even though <code>info</code> behaves differently depending on the CLI mode, you don't need to always switch the CLI mode, as the <code>info</code> command can take it as an argument. For example, here is how we can list the configuration of the <code>mgmt0</code> interface without leaving the <code>state</code> mode:</p> <pre><code>--{ state }--[ interface mgmt0 ]--\nA:admin@leaf1# info from running\n    admin-state enable\n    subinterface 0 {\n        admin-state enable\n        ip-mtu 1500\n        ipv4 {\n            admin-state enable\n            dhcp-client {\n            }\n        }\n        ipv6 {\n            admin-state enable\n            dhcp-client {\n            }\n        }\n    }\n</code></pre>"},{"location":"intro/srl-cli.html#output-modifiers","title":"Output modifiers","text":"<p>Output modifiers allow you to process the output of the commands (such as <code>info</code> output) and modify it. They should be provided after the command and after the pipe - | - key.</p>"},{"location":"intro/srl-cli.html#more","title":"more","text":"<p>Inspired by the Linux, SR Linux does not paginate the output by default. Instead, a user should apply the <code>| more</code> modifier if they wish to paginate the output.</p> <p>Can be useful when you want to see the large output of the <code>info</code> or <code>show</code> command in a single screen:</p> <pre><code>--{ state }--[ interface mgmt0 ]--\nA:admin@leaf1# info | more\n    admin-state enable\n    mtu 1514\n    ifindex 1077952510\n    oper-state up\n    last-change \"2024-09-25T14:28:40.810Z (21 hours ago)\"\n    statistics {\n        in-packets 983\n        in-octets 98381\n        in-unicast-packets 582\n        in-broadcast-packets 36\n        in-multicast-packets 142\n        in-discarded-packets 220\n        in-error-packets 3\n        in-fcs-error-packets 0\n        out-packets 598\n        out-octets 107162\n        out-mirror-octets 0\n        out-unicast-packets 546\n        out-broadcast-packets 6\n        out-multicast-packets 46\n        out-discarded-packets 0\n        out-error-packets 0\n        out-mirror-packets 0\n--More--\n</code></pre> <p>The output will stop filling up the available height of the terminal, waiting for a user to press on of the following:</p> <ul> <li>Enter - to advance a line</li> <li>Space - to advance a page</li> <li>Ctrl+C - to close the paginator</li> </ul>"},{"location":"intro/srl-cli.html#as","title":"as","text":"<p>Another important modifier is the <code>as</code> modifier that allows you to transform the output to a different format:</p> <ul> <li>yaml</li> <li>json</li> <li>table</li> </ul> <p>It is primarily used with the <code>info</code> output. For example, if you want to convert the configuration of a certain context to the YAML or JSON format, you can use the <code>as</code> modifier:</p> JSONYAML <pre><code>--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1# info | as json\n{\n  \"name\": \"mgmt0\",\n  \"admin-state\": \"enable\",\n  \"subinterface\": [\n    {\n      \"index\": 0,\n      \"admin-state\": \"enable\",\n      \"ip-mtu\": 1500,\n      \"ipv4\": {\n        \"admin-state\": \"enable\",\n        \"dhcp-client\": {\n        }\n      },\n      \"ipv6\": {\n        \"admin-state\": \"enable\",\n        \"dhcp-client\": {\n        }\n      }\n    }\n  ]\n}\n</code></pre> <pre><code>--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1# info | as yaml\n---\nname: mgmt0\nadmin-state: enable\nsubinterface:\n  - index: 0\n    admin-state: enable\n    ip-mtu: 1500\n    ipv4:\n      admin-state: enable\n      dhcp-client:\n    ipv6:\n      admin-state: enable\n      dhcp-client:\n</code></pre>"},{"location":"intro/srl-cli.html#grepheadtailwc","title":"grep/head/tail/wc","text":"<p>Of course, you can use the common Linux utilities like <code>grep</code>, <code>head</code>, <code>tail</code> and <code>wc</code>. We leverage the underlying Debian 12 Linux distribution where these utilities are available.</p>"},{"location":"intro/srl-cli.html#jq-and-yq","title":"jq and yq","text":"<p>We have also baked in the powerful <code>jq</code> and <code>yq</code> tools to the SR Linux CLI so that you can transform, query, and modify the output of the <code>info</code> command and create your own custom outputs.</p>"},{"location":"intro/srl-cli.html#wildcards-and-ranges","title":"Wildcards and Ranges","text":"<p>Wildcards and ranges in the Nokia SR Linux CLI let you operate on many YANG list elements with a single, compact command. Instead of repeating similar commands per interface, VRF, or ACL, you can use * as a wildcard to match all existing objects, and {} ranges to address specific sets or even create new ones. For example: <pre><code>info interface ethernet-1/*\ninfo interface ethernet-1/{1..4} admin-state\ninfo interface ethernet-1/{1,3..5,8} admin-state\ninfo from state interface * traffic-rate | filter fields in-bps out-bps | as table\n/interface * subinterface 0 description \"created with a wildcard\"\n</code></pre> The CLI engine expands these patterns into individual keys and executes the command for each, enabling powerful bulk queries and configuration changes without copy\u2011paste. Wildcards focus on existing objects, while ranges can also generate new ones, making large-scale edits fast and consistent.</p>"},{"location":"intro/srl-cli.html#show-commands","title":"Show commands","text":"<p>It is hard to imagine a Network CLI without the <code>show</code> command. When the <code>info</code> command outputs the raw, most details config or state of a particular context, effectively dumping the whole datastore, the <code>show</code> command produces the output that is meant to be more human-readable. Like a table output with information potentially pulled from different contexts.</p> <p>SR Linux comes with a good number of <code>show</code> commands. A <code>show</code> command is essentially a small CLI program that talks to SR Linux management core and parses the output into a desired format.</p> <p>Naturally, the first command you execute on a system is the <code>show version</code> command. But mind that the <code>show</code> command is context-aware, so if you're in the context other than the root, you will have to specify the context:</p> <pre><code>--{ running }--[ interface mgmt0 ]--\nA:admin@leaf1# show /version\n----------------------------------------------------------\nHostname             : leaf1\nChassis Type         : 7220 IXR-D3L\nPart Number          : Sim Part No.\nSerial Number        : Sim Serial No.\nSystem HW MAC Address: 1A:95:08:FF:00:00\nOS                   : SR Linux\nSoftware Version     : v25.10.1\nBuild Number         : 399-g90c1dbe35ef\nArchitecture         : x86_64\nLast Booted          : 2026-01-09T16:55:30.656Z\nTotal Memory         : 65726332 kB\nFree Memory          : 44092148 kB\n----------------------------------------------------------\n</code></pre> <p>SR Linux show commands follow the same schema as the contexts follow. This makes the mental map of SR Linux schema much easier, as you can use the <code>show</code> command in front of the path that you used to enter the context.</p> <p>Let's look at the example where we use the <code>show interface</code> command:</p> <pre><code>--{ running }--[  ]--\nA:admin@leaf1# show interface mgmt0\n============================================================================\nmgmt0 is up, speed 1G, type None\n  mgmt0.0 is up\n    Network-instances:\n      * Name: mgmt (ip-vrf)\n    Encapsulation   : null\n    Type            : None\n    IPv4 addr    : 172.20.20.3/24 (dhcp, preferred)\n    IPv6 addr    : 2001:172:20:20::3/64 (dhcp, preferred)\n    IPv6 addr    : fe80::42:acff:fe14:1403/64 (link-layer, preferred)\n----------------------------------------------------------------------------\n============================================================================\n</code></pre> <p>Note, how after the <code>show</code> command we provide the context in the same way as we would use to enter into the interface context. The same schema applies to the <code>show</code> command.</p> <p>Another, more elaborated example is showing the <code>bgp</code> summary of the management network instance:</p> <pre><code>--{ running }--[  ]--\nA:admin@leaf1# show network-instance mgmt protocols bgp summary\n</code></pre> <p>It doesn't yield any output, since we don't have any BGP sessions configured, but it is a good example of how the show command follows the same schema, because to enter into the bgp context for configuration we would type the following:</p> <pre><code>--{ running }--[  ]--\nA:admin@leaf1# enter candidate\n\n--{ candidate shared default }--[  ]--\nA:admin@leaf1# network-instance mgmt protocols bgp\n\n--{ * candidate shared default }--[ network-instance mgmt protocols bgp ]--\nA:admin@leaf1#\n</code></pre> <p>Now you have a good primer on the SR Linux CLI and ready to start using it to configure, monitor, and troubleshoot your network.</p>"},{"location":"intro/srl-cli.html#tasks","title":"Tasks","text":""},{"location":"intro/srl-cli.html#configuring-sr-linux-interfaces","title":"Configuring SR Linux Interfaces","text":"<p>Configure interfaces 5-10 on <code>leaf1</code>, these interfaces are not connected to anything, so they will not come in the operational up state.</p> Solution Step 1Step 2Step 3Step 4Step 5 <pre><code>enter candidate\n</code></pre> <pre><code>interface ethernet-1/{5..10} admin-state enable\n</code></pre> <pre><code>--{ * candidate shared default }--[  ]--\nA:admin@leaf1# diff\n+     interface ethernet-1/5 {\n+         admin-state enable\n+     }\n+     interface ethernet-1/6 {\n+         admin-state enable\n+     }\n+     interface ethernet-1/7 {\n+         admin-state enable\n+     }\n+     interface ethernet-1/8 {\n+         admin-state enable\n+     }\n+     interface ethernet-1/9 {\n+         admin-state enable\n+     }\n+     interface ethernet-1/10 {\n+         admin-state enable\n+     }\n</code></pre> <pre><code>commit now\n</code></pre> <pre><code>--{ + running }--[  ]--\nA:admin@leaf1# info interface *\n# clipped\n    interface ethernet-1/5 {\n        admin-state enable\n    }\n    interface ethernet-1/6 {\n        admin-state enable\n    }\n    interface ethernet-1/7 {\n        admin-state enable\n    }\n    interface ethernet-1/8 {\n        admin-state enable\n    }\n    interface ethernet-1/9 {\n        admin-state enable\n    }\n    interface ethernet-1/10 {\n        admin-state enable\n    }\n# clipped\n</code></pre> <p>Revert config</p> <p>Before continuing to the next activity, make sure your config is restored to not interfere with the upcoming activities.</p> <pre><code>--{ + running }--[  ]--\nA:admin@leaf1# enter candidate\n\n\n--{ candidate shared default }--[  ]--\nA:admin@leaf1# load startup auto-commit\n/system/configuration/checkpoint[id=__startup__]:\n    Reverting to startup configuration\n\n/:\n    Successfully reverted configuration\n</code></pre> <p>Deviations</p> <p>Alternatively, you can use <code>Deviations</code> in EDA to remove this configuration. By using the CLI to configure something manually, the node has drifted away from EDA's intent. This is what we call a <code>Deviation</code>. In EDA we can easily remove this deviation, by declining it.</p> <p></p> <p>This was a simple example to get you familiar with the SRL CLI. On the next page, we will also configure interfaces though EDA, instead of through the CLI. We will see that in EDA we can define resources declaratively (what do we need), instead of imperatively (how do we configure it).</p> <ol> <li> <p>For the sake of simplicity, we will not go into the details of the candidate datastore types in the introduction. Refer to the official documentation for more information.\u00a0\u21a9</p> </li> <li> <p>We will cover the interface/subinterface model in more detail later.\u00a0\u21a9</p> </li> </ol>"},{"location":"overlay/bridge-domains.html","title":"Bridge domains","text":"Short Description Creating bridge domains with EDA to achieve layer 2 connectivity Difficulty Beginner Topology Nodes  client1,  client3,  leaf1,  leaf3 <p>This is the first exercise in a 3-part series around using EDA to achieve connectivity to, from, and within your datacenter. In this exercise, we will achieve layer-2 connectivity between two hosts in the same broadcast domain.</p> <ul> <li>Part 1 (this activity): achieve layer-2 connectivity using bridge domains</li> <li>Part 2: achieve layer-3 connectivity using routers</li> <li>Part 3: combine layer-2 and layer-3 connectivity through a single EDA object - the Virtual Network (VNET)</li> </ul>"},{"location":"overlay/bridge-domains.html#objective","title":"Objective","text":"<p>In this exercise, we enable the layer 2 connectivity between the two linux hosts in our lab topology. Both linux hosts have an IP address in the same IP subnet and our objective is to ensure that the traffic is switched over the datacenter fabric using a dedicated and isolated MAC-VRF service.</p>"},{"location":"overlay/bridge-domains.html#technology-explanation","title":"Technology explanation","text":"<p>Layer-2 or switched traffic in a datacenter is often used in distributed workloads to accommodate connectivity between two computes, without the router being aware of which IPs the computes use to communicate. Some prominent examples where Layer 2 connectivity is required are:</p> <ol> <li> <p>VM mobility</p> <p>Virtual machines are being recreated with the same IP on a different physical compute, to allow for maintenance and rapid failover.</p> </li> <li> <p>DHCP</p> <p>Broadcast traffic is often a significant and important part of connectivity between computes and relies exclusively on MAC addresses to communicate. One such example is the dynamic host configuration protocol (DHCP) used to dynamically assign IP addresses.</p> </li> </ol> <p>In this exercise, we'll take a look at how layer 2 connectivity can be facilitated using EDA's Bridge Domains. A bridge domain is another word for a Virtual Private LAN Service (VPLS in SR OS lingo) or a MAC-VRF (SR Linux).</p>"},{"location":"overlay/bridge-domains.html#tasks","title":"Tasks","text":"<p>See Access Details if you need a reminder on how to access the nodes in the topology.</p>"},{"location":"overlay/bridge-domains.html#inspect-the-ip-configuration-of-both-clients","title":"Inspect the IP configuration of both clients","text":"<p>Before we start, we need to verify the IP configuration on both clients. We're interested in two things:</p> <ol> <li>the VLAN the clients use to communicate</li> <li>the IP address of each client so we can test later whether the connectivity is in place.     Multiple IP addresses are configured for different hackathon exercises, so you're looking for an IP in the subnet <code>10.30.0.0/24</code></li> </ol> <p>To connect to the shell of the client nodes, you should connect to the server running your lab and then ssh to each node, for example, for <code>client1</code>:</p> execute from the lab server<pre><code>ssh admin@clab-kpn-hackathon-client1\n</code></pre> <pre><code>[*]\u2500[client1]\u2500[~]\n\u2514\u2500\u2500&gt;\n</code></pre> <p>When in the client shell, try to answer these questions:</p> <ul> <li>Which VLAN are the clients using to communicate?</li> <li>Which command can you use to test the connectivity?</li> </ul> Hint: the relevant IP interfaces on the clients client-1client-3 <pre><code>[*]\u2500[client1]\u2500[~]\n\u2514\u2500\u2500&gt; ip route show 10.30.0.0/24\n10.30.0.0/24 dev eth1.300 proto kernel scope link src 10.30.0.11\n</code></pre> <pre><code>[*]\u2500[client3]\u2500[/]\n\u2514\u2500\u2500&gt; ip a | grep \"10.30.0\" -A 5 -B 2\n5: eth1.300@eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9500 qdisc noqueue state UP group default qlen 1000\n    link/ether aa:c1:ab:b9:1b:9e brd ff:ff:ff:ff:ff:ff\n    inet 10.30.0.13/24 scope global eth1.300\n       valid_lft forever preferred_lft forever\n    inet6 fd00:fdfd:0:3000::13/64 scope global\n       valid_lft forever preferred_lft forever\n    inet6 fe80::a8c1:abff:feb9:1b9e/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> Solution <p>The VLAN the computes will use to access the layer 2 domain is VLAN <code>300</code>. Note that there are both IPv4 and IPv6 addresses configured on the node.</p> <p>To test the connectivity, the following command can be used. Note that connectivity is currently not working, as expected. We will have to create the Bridge Domain to achieve it.</p> <pre><code># for IPv4\n[x]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.13\nPING 10.30.0.13 (10.30.0.13) 56(84) bytes of data.\nFrom 10.30.0.11 icmp_seq=1 Destination Host Unreachable\n\n--- 10.30.0.13 ping statistics ---\n1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms\n</code></pre> <pre><code># for IPv6\n[x]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::13\nPING fd00:fdfd:0:3000::13(fd00:fdfd:0:3000::13) 56 data bytes\nFrom fd00:fdfd:0:3000::11 icmp_seq=1 Destination unreachable: Address unreachable\n\n--- fd00:fdfd:0:3000::13 ping statistics ---\n1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms\n</code></pre>"},{"location":"overlay/bridge-domains.html#list-bridge-domains","title":"List Bridge Domains","text":"<p>Login to the EDA UI using the assigned Group ID and EDA credentials provided to you.</p> <p>The EDA platform consists of the core and the apps that extend it and provide the resources for declarative network management. Although you can make your own apps, Nokia already provides an extensive library of pre-installed apps that can handle a lot of configuration tasks. Programming your own app is beyond the scope of this exercise.</p> <p>Look at the app menu in the left sidebar for \"Bridge Domains\", which is located in the \"Virtual Networks\" category.</p> <p></p> <p>When you click on the Bridge Domain menu element, you will see the list of existing Bridge Domains. A few of them are already there to power up other exercises, but none of them enable connectivity over VLAN 300 that our clients are intent on using.</p> <p>If you come from operations you don't just blindly trust some lines in a management system, you want proofs, and better yet, the exact config that is running on the devices. Normally, you would log in to the switches, maybe one by one, and run the show commands. But this is so eighties, how about you use the query language that EDA provides and ask all your network elements to list their MAC VRFs?</p> <p>EDA comes with a built-in network-wide query engine that allows you to query the network devices in a performant and scalable way. Using the sidebar navigation menu, select the Queries menu and paste the following in the EQL Query input field:</p> <pre><code>.namespace.node.srl.network-instance where ( type = \"mac-vrf\" )\n</code></pre> <p>You should see a network-wide query result with all nodes reporting back all network instances of type <code>mac-vrf</code> they have configured.</p> <p></p> <p>Then you can ask the nodes to list all subinterfaces they have and their single-tagged vlan ids:</p> <pre><code>.namespace.node.srl.interface.subinterface.vlan.encap.single-tagged\n</code></pre> <p>You will likely won't see any subinterface with VLAN 300, and that's expected, we did not configure this either. So let's get to it.</p>"},{"location":"overlay/bridge-domains.html#create-a-bridge-domain","title":"Create a bridge domain","text":"<p>In the Virtual Networks \u2192 Bridge Domains app page click the \"Create\" button in the top-right to create a new bridge domain. In the center of the screen you can see all configuration options for the new bridge domain, and on the right is a YAML representation of the same. You can either fill the form fields, or edit the YAML, whatever you prefer.</p> <p></p> <p>Create a new bridge domain, so you can attach some interfaces to it in the next step. If you're not sure which value you need to pick for a particular property, you can leave the field default or empty. The most important properties are:</p> <ul> <li>A name so you can reference this bridge domain later.</li> <li>The type should be left as \"EVPNVXLAN\", as the Bridge Domain (mac vrf) will be used to provide overlay services.</li> </ul> A note about namespaces <p>Namespaces in EDA are used to separate resources into any way you see fit: in a real-life network, you may want to split your fabric resources into regions or functions, for example. In the hackathon we have only one namespace -  <code>eda</code> - which has been pre-configured in your lab topology.</p> <p>When you are finished, you can press the Commit button to commit the transaction<sup>1</sup> right away which will result in EDA verifying the correctness of the Bridge Domain configuration and... It will store the Bridge Domain resource in the EDA database, but no config will be pushed to the nodes. Why, you ask?</p> <p>The bridge domain configuration is only pushed to nodes when Bridge Interface resources are created that refer a bridge domain; And since we don't have them yet - EDA does not push anything to the nodes. We'll add them in the next step.</p> <p>The solution can be found below in YAML format, if you want to refer to it. You can copy this yaml object into the right column in the GUI to change your current config.</p> Solution <p>It is enough to define the Bridge Domain like this:</p> <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: BridgeDomain\nmetadata:\n  name: bridge-domain-vlan300\n  namespace: eda\nspec:\n  type: EVPNVXLAN\n  vniPool: vni-pool\n  eviPool: evi-pool\n  tunnelIndexPool: tunnel-index-pool\n</code></pre> <p>The key pieces here are the pools used for the VNI, EVI and tunnel index allocation. Want to know more about pools and how EDA presents itself as a source of truth and IPAM? Read about Allocation Pools first.</p> <p>After committing the Bridge Domain you can verify that it was not instantiated on the nodes by running the same EQL query listing all mac-vrfs as we did before.</p>"},{"location":"overlay/bridge-domains.html#create-bridge-interfaces","title":"Create Bridge Interfaces","text":"<p>Bridge interfaces enable the attachment of the network interfaces to a particular service/vrf/bridge-domain. They can refer to a physical interface on a device, perform actions on ingress/egress and set the VLAN ID and thus ensure that multiple virtual machines can share the same physical interface, yet are logically isolated.</p> <p>In EDA, you can create Bridge Interfaces resources one at a time by referencing a particular interface object, or create several of them by using labels. We'll start with manually specifying an interface, but in a future step we'll do this again with labels, which are much easier to work with!</p> <p>Find the Bridge Interfaces section of the Virtual Networks category of your side menu on the left. You should not see any existing bridge interfaces, as we will create them in this exercise. Hit the Create button and let's dive in.</p> <p>Recall, that the Bridge Interface resource in EDA can reference an existing Interface object to a single Bridge Interface mapped to a network interface. You are tasked with creating a Bridge Interface that would target the already existing interface <code>leaf1-client1</code> and associate it with the Bridge Domain we created earlier. In the Bridge Interface form you should at a minimum provide the following:</p> <ol> <li>Bridge Interface a name</li> <li>A reference to the Bridge Domain that this Bridge Interface should be connected to</li> <li>A VLAN ID that this Bridge Interface should be using (hint: you found out the VLAN ID in one of the previous steps!).</li> <li>A reference to the Interface resource that this Bridge Interface should be using.</li> </ol> <p>Once you figured out what to enter in the Bridge Interface form, don't hit the Commit button right away as we did with the Bridge Domain. Let's explore the power of transactions and dry runs, by clicking the Add to Transaction button and stage our change into the transaction basket.</p> Solution <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: BridgeInterface\nmetadata:\n  name: client1-bridge-domain-300\n  namespace: eda\nspec:\n  description: Provides a logical connection from client1 to the bridge domain using VLAN ID 300\n  ###### WARNING ######\n  # this name should match the name of the bridge domain created earlier\n  #####################\n  bridgeDomain: bridge-domain-vlan300\n  vlanID: '300'\n  interface: leaf1-client1\n</code></pre> <p>Learn more about Transactions and Dry Run functionality.</p> <p>Use the Dry Run functionality in EDA to check what would change if we were to commit our Bridge Interface.</p> <p></p> <p>Using the dry-run feature, you can check the diffs that the particular transaction would emit, and there you have a chance to see what node-specific configs would be pushed to which nodes if we were to commit our transaction.</p> <p>The Dry Run functionality does not touch the network elements in any way. All the potential change sets are computed by EDA. Safe and fast.</p> <p>The change set in the diff view should indicate that a subinterface with vlan-id is created on the <code>leaf1</code> switch as well as the network instance of type <code>mac-vrf</code> that this subinterface is connected to.</p> <p>Create the Bridge Interface targeting <code>leaf3</code> node as well, to attach the second client to the bridge domain before proceeding further.</p>"},{"location":"overlay/bridge-domains.html#resource-status","title":"Resource status","text":"<p>You should be able to see the Bridge Interface status reflected in the GUI. To see the status of the configured object in EDA you can use the info icon or double click on the created resource to open up the view mode.</p> <p>You can also navigate to your bridge domain, and find out which leaf nodes are now participating in the service.</p> <p></p>"},{"location":"overlay/bridge-domains.html#testing-the-connectivity","title":"Testing the connectivity","text":"<p>With Bridge Domain and two Bridge Interfaces committed to the fabric, you should now have IP connectivity between your two clients! Login to one of the clients participating in the layer-2 service, and try to ping the IP of the other one!</p> client-1client-3 <p>Connect to the server and then SSH into the client</p> <pre><code>ssh admin@clab-kpn-hackathon-client1\n</code></pre> <p>Once in the shell, ping client3:</p> <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.13\nPING 10.30.0.13 (10.30.0.13) 56(84) bytes of data.\n64 bytes from 10.30.0.13: icmp_seq=1 ttl=64 time=3.13 ms\n\n--- 10.30.0.13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 3.128/3.128/3.128/0.000 ms\n</code></pre> <p>And with IPv6:</p> <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::13\nPING fd00:fdfd:0:3000::13(fd00:fdfd:0:3000::13) 56 data bytes\n64 bytes from fd00:fdfd:0:3000::13: icmp_seq=1 ttl=64 time=1.92 ms\n\n--- fd00:fdfd:0:3000::13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 1.915/1.915/1.915/0.000 ms\n</code></pre> <p>Connect to the server and then SSH into the client</p> <pre><code>ssh admin@clab-kpn-hackathon-client3\n</code></pre> <p>Once in the shell, ping client1:</p> <pre><code>[*]\u2500[client3]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.11\nPING 10.30.0.11 (10.30.0.11) 56(84) bytes of data.\n64 bytes from 10.30.0.11: icmp_seq=1 ttl=64 time=0.779 ms\n\n--- 10.30.0.11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.779/0.779/0.779/0.000 ms\n</code></pre> <p>And with IPv6:</p> <pre><code>[*]\u2500[client3]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::11\nPING fd00:fdfd:0:3000::11(fd00:fdfd:0:3000::11) 56 data bytes\n64 bytes from fd00:fdfd:0:3000::11: icmp_seq=1 ttl=64 time=0.841 ms\n\n--- fd00:fdfd:0:3000::11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.841/0.841/0.841/0.000 ms\n</code></pre> <p>Beautiful, we have configured the network connectivity in the overlay between clients 11 and 13 using EDA's Bridge Domain and Bridge Interface Resources. By the way, you can the same queries using EQL as we did at the beginning of this exercise to see the new bridge domain and interfaces present.</p>"},{"location":"overlay/bridge-domains.html#using-labels","title":"Using labels","text":"<p>In the previous step, we have created a single bridge interface per (bridge-domain, interface, VLAN) combination. For dozens of services with hundreds of physical interfaces, this quickly becomes impractical. In this task, we'll take a look at label-based operations.</p> <p>Start off by deleting the bridge interfaces you have created so far (you can keep the bridge domain). You can remove the Bridge Interfaces one by one, or by selecting them in the grid view and bulk deleting via the  menu icon. After deleting the Bridge Interface objects feel free to run the EQL queries to ensure that the nodes were stripped off of the relevant configurations.</p> <p>Next up, find the two Interfaces <code>leaf1-client1</code> and <code>leaf3-client3</code> in the Interfaces menu under the Topology group and have a look at the labels metadata field: </p> <p>Each resource in EDA can have a number of labels, which can be used to select the resources. Want to know more about the labels - we have a dedicated exercise for it.</p> <p>A label consists of a label key and a label value and is often written in the form of <code>key=value</code> string. For example, let's imagine that our two clients - client1 and client3 - are VMware hypervisors. Then we might want to tag them with the <code>tenant-type=vmware-hv</code> label to provide this metadata information that we can act on later.</p> <p>You can edit the Interface resources one by one, or select them both and make use of the Bulk Edit edit unt</p> <p>To avoid issues with other exercises, don't delete any existing label by overriding their label key!</p> <p>After assigning your new label to both interfaces, the list should look as follows (notice the filter in the Labels column at the top of the grid):</p> <p></p>"},{"location":"overlay/bridge-domains.html#vlan-resource","title":"VLAN resource","text":"<p>Now that both interfaces have been assigned a common label, any EDA application can select them based on the tag. If before we had to create two instances of Bridge Interface for each interface/vlab/bridge-domain triplet, now we can optimize the workflow by using a different EDA resource - the VLAN resource.</p> <p>The VLAN resource, in contrast to the Bridge Interface, selects the interfaces based on the label selector, and does not allow you to individually pick an interface. It provides a way to connect the customer-facing interfaces to the bridge domain in a bulk mode. And this is exactly what you are tasked with, even though your fabric only has two clients, you can imagine running real fabric with hundreds or thousands VMs that ought to be interconnected via the overlay network service.</p> <p>Select the VLANs application under the Services category in the sidebar and open the creation window for your first VLAN resource. When filling the the resource form, focus on:</p> <ul> <li>A name for your VLAN so you can easily recognize it later</li> <li>An optional description</li> <li>A reference to the bridge domain you created earlier</li> <li>A label in the <code>Interface Selector</code> section of the spec that you assigned to both client interfaces. This field does not auto-complete yet, so you need to manually enter the label. Follow the pattern <code>{key}={value}</code> and type in the label you assigned to the interfaces in the previous step.</li> <li>The VLAN ID you discovered at the start of this exercise. Note: replace the \"pool\" value from the field (which indicates that EDA should choose a VLAN from the allocation pool automatically) with the ID you discovered earlier.</li> </ul> <p>After filling out the required fields, feel free to run a Dry Run and ensure that you see configuration changes aimed at both leaf switches and matching the configuration you've seen when manually added the Bridge Interfaces.</p> <p>If everything was configured correctly and committed, you should now be able to see the status of both interfaces in your VLAN object.</p> Solution <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: VLAN\nmetadata:\n  name: bridge-domain-vlan300\n  namespace: eda\nspec:\n  ###### WARNING ######\n  # this name should match the name of the bridge domain created earlier\n  #####################\n  bridgeDomain: bridge-domain-vlan300\n  description: &gt;-\n    This object creates a subinterface for each port assigned to label\n    \"tenant-type=vmware-hv\"\n  interfaceSelector:\n    - tenant-type=vmware-hv\n  vlanID: '300'\n</code></pre>"},{"location":"overlay/bridge-domains.html#test-the-connectivity","title":"Test the connectivity","text":"<p>To ensure that everything was configured correctly, re-check the connectivity between both clients</p> client-1client-3 <p>Connect to the server and then SSH into the client</p> <pre><code>ssh admin@clab-kpn-hackathon-client1\n</code></pre> <p>Once in the shell, ping client3:</p> <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.13\nPING 10.30.0.13 (10.30.0.13) 56(84) bytes of data.\n64 bytes from 10.30.0.13: icmp_seq=1 ttl=64 time=3.13 ms\n\n--- 10.30.0.13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 3.128/3.128/3.128/0.000 ms\n</code></pre> <p>And with IPv6:</p> <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::13\nPING fd00:fdfd:0:3000::13(fd00:fdfd:0:3000::13) 56 data bytes\n64 bytes from fd00:fdfd:0:3000::13: icmp_seq=1 ttl=64 time=1.92 ms\n\n--- fd00:fdfd:0:3000::13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 1.915/1.915/1.915/0.000 ms\n</code></pre> <p>Connect to the server and then SSH into the client</p> <pre><code>ssh admin@clab-kpn-hackathon-client3\n</code></pre> <p>Once in the shell, ping client1:</p> <pre><code>[*]\u2500[client3]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.0.11\nPING 10.30.0.11 (10.30.0.11) 56(84) bytes of data.\n64 bytes from 10.30.0.11: icmp_seq=1 ttl=64 time=0.779 ms\n\n--- 10.30.0.11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.779/0.779/0.779/0.000 ms\n</code></pre> <p>And with IPv6:</p> <pre><code>[*]\u2500[client3]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3000::11\nPING fd00:fdfd:0:3000::11(fd00:fdfd:0:3000::11) 56 data bytes\n64 bytes from fd00:fdfd:0:3000::11: icmp_seq=1 ttl=64 time=0.841 ms\n\n--- fd00:fdfd:0:3000::11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.841/0.841/0.841/0.000 ms\n</code></pre> <p>Great job completing the Bridge Domains exercise! You've successfully:</p> <ul> <li>Created layer-2 connectivity between client1 and client3 using EDA's Bridge Domain resources</li> <li>Learned how to configure Bridge Interfaces to connect physical interfaces to virtual networks</li> <li>Mastered the use of EDA's transaction and dry run capabilities to preview configuration changes</li> <li>Discovered the power of label-based operations to efficiently manage multiple interfaces</li> <li>Implemented VLAN resources to streamline the configuration process using interface selectors</li> </ul> <p>Your work has established a functional layer-2 network service that allows both IPv4 and IPv6 communication between the clients. This foundation in EDA's declarative approach to network configuration will serve you well as you progress to more advanced topics like layer-3 connectivity with routers and virtual networks.</p> <p>Ready for the next challenge? Continue to Part 2: Routers to build on what you've learned!</p> <ol> <li> <p>If you want to learn more about transactions, checkout transactions section of the Declarative Intents exercise.\u00a0\u21a9</p> </li> </ol>"},{"location":"overlay/routers.html","title":"Routers","text":"Short Description Creating a router with EDA to achieve layer 3 connectivity Difficulty Beginner Resources used Virtual Networks \u2192 Routers / Routed Interfaces Topology Nodes  client1,  client3,  leaf1,  leaf3 <p>This is the second exercise in a 3-part series about using EDA to achieve connectivity to, from, and within your datacenter. In this exercise, we will achieve layer-3 connectivity between two hosts in different broadcast domains.</p> <ul> <li>Part 1: achieve layer-2 connectivity using bridge domains</li> <li>Part 2 (this activity): achieve layer-3 connectivity using routers</li> <li>Part 3: combine layer-2 and layer-3 connectivity through a single EDA object: the Virtual Network</li> </ul>"},{"location":"overlay/routers.html#objective","title":"Objective","text":"<p>In this exercise, we enable two linux hosts to talk to each other, but in contrast to the Part 1 exercise the two hosts reside in different subnets and have IP addresses from different subnets. Therefore, traffic must be routed instead of switched over the datacenter fabric using a dedicated and isolated service: the IP-VRF.</p> <p>We will have to configure the overlay services in such a way that traffic between these client interfaces is successfully routed, without creating any layer-2 subnets in the overlay, pure L3.</p> Target connectivity model: Layer 3 only"},{"location":"overlay/routers.html#technology-explanation","title":"Technology explanation","text":"<p>While EVPN originally emerged as a Layer 2 VPN technology to overcome VPLS limitations, it has since evolved to become a unified control plane for many services, Layer 3 VPN included. Founded upon the BGP protocol, EVPN has lots of flexibility and features to become a one-stop-shop for all VPN services in various network deployments, but especially fit for the IP fabrics.</p> <p>In the Part 1 we learned how to use EDA to provide layer 2 services across an IP fabric. The focus of this part is on deploying a Layer 3 Ethernet VPN (EVPN) overlay service in the EDA-managed DC fabric.</p> <p>We will instantiate an interface-less flavor of an L3 EVPN service that does not require the use of Integrated Routing and Bridging (IRB) interfaces, and as such has no need MAC VRF instances, ARP/ND entries synchronization, MAC/IP (RT2) and IMET routes.</p> <p>As you might expect, the Layer 3 EVPN is designed to provide Layer 3 services across the fabric. As such, there are no stretched broadcast domains across the fabric and the customer equipment is directly connected via L3 interfaces to the leafs and often runs a PE-CE routing protocol to exchange IP prefixes.</p> <p>Layer-3 or routed services enables a datacenter infrastructure team to:</p> <ol> <li>reduce the size of Layer-2 broadcast domains and segment the network into smaller subnets interconnected by routers</li> <li>force the traffic path of certain flows over specific paths.     For example: you may want to add a firewall between computes, so only traffic to and from the HTTPS port is allowed to go to a web farm. This is not possible with bridge domains, as traffic can be broadcasted for everyone to hear: this is not the case for routed traffic.</li> </ol> <p>We'll look at how this connectivity can be achieved in EDA using declarative abstracted resources such as Routers and Routed Interfaces. A router is another word for Virtual Private Routed Network (or VPRN) in SR OS terms or IP-VRF in SR Linux. And a routed interface is an L3 interface that is part of a router.</p> <p>The Router resource declaratively defines the virtual router (VRF) on the supported network OSes, whereas the Routed Interface resource defines the L3 interface that is part of virtual router.</p>"},{"location":"overlay/routers.html#tasks","title":"Tasks","text":"<p>See Access Details if you need a reminder on how to access the nodes in the topology.</p> <p>The tasks ahead of you require you to enable the layer-3 connectivity between <code>clients11</code> and <code>client3</code>. You start from a clean slate where clients have IP addresses configured, and they are physically connected to the datacenter fabric, but there is no relevant config present on the leaf switches to enable this connectivity as shown on the diagram below:</p> Starting state <p>For this exercise, the clients have been configured with the following IP addresses:</p> Client Interface IP address VLAN client1 eth1.311 10.30.1.11/24  fd00:fdfd:0:3001::11/64 311 client3 eth1.313 10.30.3.13/24  fd00:fdfd:0:3003::13/64 313"},{"location":"overlay/routers.html#inspect-the-ip-configuration-of-both-clients","title":"Inspect the IP configuration of both clients","text":"<p>Before we start, we need to verify the IP configuration on both clients. We're interested in two things:</p> <ol> <li>the IP address of each client's interface so we can test later whether the connectivity is in place.  </li> <li>the VLAN this interface is configured with</li> </ol> <p>Using the IP configuration provided in the Objective section, verify the acting configuration on the clients by connecting to the shell.</p> <p>To connect to the shell of the client nodes, you should connect to the server running your lab and then ssh to each node, for example, for <code>client1</code>:</p> execute from the lab server<pre><code>ssh admin@clab-kpn-hackathon-client1\n</code></pre> <pre><code>[*]\u2500[client1]\u2500[~]\n\u2514\u2500\u2500&gt;\n</code></pre> <p>When in the client shell, use your linux skills to inspect the IP configuration of the client and match it with the IP plan provided in the Objective section.</p> Hint: the relevant IP interfaces on the clients client-1client-3 <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ip a | grep \"10.30.1\" -A 5 -B 2\n6: eth1.311@eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9500 qdisc noqueue state UP group default qlen 1000\n    link/ether aa:c1:ab:2f:4b:67 brd ff:ff:ff:ff:ff:ff\n    inet 10.30.1.11/24 scope global eth1.311\n       valid_lft forever preferred_lft forever\n    inet6 fd00:fdfd:0:3001::11/64 scope global\n       valid_lft forever preferred_lft forever\n    inet6 fe80::a8c1:abff:fe2f:4b67/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <pre><code>[*]\u2500[client3]\u2500[/]\n\u2514\u2500\u2500&gt; ip a | grep \"10.30.3\" -A 5 -B 2\n7: eth1.313@eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9500 qdisc noqueue state UP group default qlen 1000\n    link/ether aa:c1:ab:b9:1b:9e brd ff:ff:ff:ff:ff:ff\n    inet 10.30.3.13/24 scope global eth1.313\n       valid_lft forever preferred_lft forever\n    inet6 fd00:fdfd:0:3003::13/64 scope global\n       valid_lft forever preferred_lft forever\n    inet6 fe80::a8c1:abff:feb9:1b9e/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>To test the connectivity, ping client3 interface from client1:</p> IPv4IPv6 <pre><code>[x]\u2500[client1]\u2500[~]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.3.13\nPING 10.30.3.13 (10.30.3.13) 56(84) bytes of data.\nFrom 10.30.1.11 icmp_seq=1 Destination Host Unreachable\n\n--- 10.30.3.13 ping statistics ---\n1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms\n</code></pre> <pre><code>[x]\u2500[client1]\u2500[~]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3003::13\nPING fd00:fdfd:0:3003::13(fd00:fdfd:0:3003::13) 56 data bytes\nFrom fd00:fdfd:0:3001::11 icmp_seq=1 Destination unreachable: Address unreachable\n\n--- fd00:fdfd:0:3003::13 ping statistics ---\n1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms\n</code></pre> <p>There is no connectivity, as the overlay services are not configured. There is no virtual router (VRF) in the fabric that would route the traffic between the clients.</p>"},{"location":"overlay/routers.html#list-routers","title":"List Routers","text":"<p>We just established that the connectivity between our clients is not working, and assumed that this is due to the network not being configured to support this service.</p> <p>In EDA, the Routers resources declaratively define the VRFs on the network elements. Let's check if there are any Routers already configured.</p> <p>Login to the EDA UI using the assigned Group ID and EDA credentials provided to you.</p> <p>EDA Core and the Apps</p> <p>The EDA platform consists of the core and the apps that extend it and provide the resources for declarative network management. Although you can make your own apps, Nokia already provides an extensive library of pre-installed apps that can handle a lot of configuration tasks. Programming your own app is beyond the scope of this exercise.</p> <p>Look at the app menu in the left sidebar for RRouters, which is located in the   VIRTUAL NETWORK category.</p> <p></p> <p>When you click on the RRouters menu element, you get the list of existing Router resources. A few of them may already be there to power up other exercises, but none of them enable Layer-3 connectivity for our clients as your pings indicated. Time to create your first Router and see what it gets you.</p>"},{"location":"overlay/routers.html#create-a-router","title":"Create a Router","text":"<p>Using the \"Create\" button in the top-right, you can create a new Router. In the center of the screen you can see all configuration options for the new Router, and on the right is a YAML representation that could be used for automation.</p> <p></p> <p>By creating a new Router resource we intend our network elements to have a VRF that will serve as a virtual routing instance for the two clients.</p> <p>The Router resource provides Network OS agnostic fields to define a virtual routing instance. The form and its YAML representation will have some fields set to their default values, and some fields will be set to <code>null</code> to indicate that they were not set. The most important Router properties you have to pay attention to are:</p> <ul> <li>A name so you can reference this Router later</li> <li>The type should be left as \"EVPNVXLAN\", as the Router is intended to provide overlay services and be used in the EVPN VXLAN fabric that you have at hand.</li> </ul> A note about namespaces <p>Namespaces in EDA are used to separate resources into any way you see fit: in a real-life network, you may want to split your fabric resources into regions or functions, for example. In the hackathon we have only one namespace -  <code>eda</code> - which has been pre-configured in your lab topology.</p> <p>When you are finished, you can press the Commit button to commit the transaction<sup>1</sup> right away which will result in EDA verifying the correctness of the Router configuration and... It will store the Router resource in the EDA database, but no config will be pushed to the nodes. Why, you ask? The Router configuration is only pushed to nodes when Routed Interface resources are created that refer a Router; And since we don't have them yet - EDA does not push anything to the nodes. We'll add them in the next step.</p> <p>When you configured and committed the Router configuration, your logical topology started to look like this:</p> Created a Router <p>The virtual router is created, but we did not create the interfaces that would connect to it, to satisfy the connectivity requirement.</p> <p>The solution can be found below in YAML format, if you want to refer to it. You can copy this yaml object into the right column in the GUI to change your current config.</p> Solution <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: Router\nmetadata:\n  name: router\n  namespace: eda\nspec:\n  eviPool: evi-pool\n  tunnelIndexPool: tunnel-index-pool\n  type: EVPNVXLAN\n  vniPool: vni-pool\n</code></pre> <p>The key pieces here are the pools used for the VNI, EVI and tunnel index allocation. Want to know more about pools and how EDA presents itself as a source of truth and IPAM? Read about Allocation Pools first.</p>"},{"location":"overlay/routers.html#create-routed-interfaces","title":"Create Routed Interfaces","text":"<p>The RoutedInterface enables the configuration and management of Layer 3 interfaces for routing traffic between different networks. This resource allows for specifying an underlying Interface and Router, configuring VLAN IDs, and setting the IP MTU. Routed Interfaces are similar to Bridge Interfaces, but they define a routed interface, instead of a bridged/switch one.</p> <p>You will find the RIRouted Interface resource under the   VIRTUAL NETWORK category. Your goal is two create two routed interface, one for each client. These interfaces should reference the physical network interfaces that are part of your topology as well reference the Router you created in the previous step.</p> <p>The physical interfaces were already modeled in EDA with the IInterface resource during the topology onboarding process, their names are:</p> <ul> <li><code>leaf1-client1</code></li> <li><code>leaf3-client3</code></li> </ul> <p>When defining the Routed Interfaces, make sure to set the VLAN ID to match the one used by the associated client interface.</p> <p>Additionally, you want to give the routed interface both an IPv4 and an IPv6 address that your clients will use as the gateway for the subnet.</p> <p>Before you commit, do a dry-run first, just like in the previous exercise! This will allow you to inspect the configuration pushed to the nodes. After you commit this change to the fabric, you should be able to see the routed interface status reflected in the GUI. You can also navigate to your router, and find out which leaf nodes are now participating in the service.</p> <p></p> Solution interface for client1interface for client3 <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: RoutedInterface\nmetadata:\n  name: router-client1\n  namespace: eda\nspec:\n  interface: leaf1-client1\n  ipMTU: 1500\n  ipv4Addresses:\n    - ipPrefix: 10.30.1.1/24\n      primary: true\n  ipv6Addresses:\n    - ipPrefix: fd00:fdfd:0:3001::1/64\n  router: router\n  vlanID: '311'\n  vlanPool: vlan-pool\n</code></pre> <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: RoutedInterface\nmetadata:\n  name: router-client3\n  namespace: eda\nspec:\n  interface: leaf3-client3\n  ipMTU: 1500\n  ipv4Addresses:\n    - ipPrefix: 10.30.3.1/24\n      primary: true\n  ipv6Addresses:\n    - ipPrefix: fd00:fdfd:0:3003::1/64\n  router: router\n  vlanID: '313'\n  vlanPool: vlan-pool\n</code></pre> <p>Once this is done, you should be able to ping the gateway IP that you assigned in the Routed Interface resource from the client's shell. The examples are provided for <code>client1</code>.</p> IPv4IPv6 <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.1.1\nPING 10.30.1.1 (10.30.1.1) 56(84) bytes of data.\n64 bytes from 10.30.1.1: icmp_seq=1 ttl=64 time=3.55 ms\n\n--- 10.30.1.1 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 3.553/3.553/3.553/0.000 ms\n</code></pre> <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3001::1\nPING fd00:fdfd:0:3001::1(fd00:fdfd:0:3001::1) 56 data bytes\n64 bytes from fd00:fdfd:0:3001::1: icmp_seq=1 ttl=64 time=4.00 ms\n\n--- fd00:fdfd:0:3001::1 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 3.997/3.997/3.997/0.000 ms\n</code></pre> <p>With these changes committed, your logical connectivity diagram completes, as client interfaces are now connected to the virtual router, via the routed interfaces:</p> Routed Interfaces connected"},{"location":"overlay/routers.html#enabling-inter-client-connectivity","title":"Enabling inter-client connectivity","text":"<p>So far, we've only pinged the router from each client, but in a real-world scenario we want to ping the other clients instead. On the clients, a static route has been pre-configured so that the subnet <code>10.30.0.0/16</code> is routed via each client's gateway, which includes the subnets of the other clients.</p> <p>Give it a try!</p> client-1client-3 <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.3.13\nPING 10.30.3.13 (10.30.3.13) 56(84) bytes of data.\n64 bytes from 10.30.3.13: icmp_seq=1 ttl=253 time=4.93 ms\n\n--- 10.30.3.13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 4.933/4.933/4.933/0.000 ms\n\n[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3003::13\nPING fd00:fdfd:0:3003::13(fd00:fdfd:0:3003::13) 56 data bytes\n64 bytes from fd00:fdfd:0:3003::13: icmp_seq=1 ttl=253 time=6.04 ms\n\n--- fd00:fdfd:0:3003::13 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 6.039/6.039/6.039/0.000 ms\n</code></pre> <pre><code>[*]\u2500[client3]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 10.30.1.11\nPING 10.30.1.11 (10.30.1.11) 56(84) bytes of data.\n64 bytes from 10.30.1.11: icmp_seq=1 ttl=253 time=4.56 ms\n\n--- 10.30.1.11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 4.559/4.559/4.559/0.000 ms\n\n[*]\u2500[client3]\u2500[/]\n\u2514\u2500\u2500&gt; ping -c 1 fd00:fdfd:0:3001::11\nPING fd00:fdfd:0:3001::11(fd00:fdfd:0:3001::11) 56 data bytes\n64 bytes from fd00:fdfd:0:3001::11: icmp_seq=1 ttl=253 time=5.09 ms\n\n--- fd00:fdfd:0:3001::11 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 5.087/5.087/5.087/0.000 ms\n</code></pre>"},{"location":"overlay/routers.html#summary","title":"Summary","text":"<p>In this exercise, you successfully established layer-3 connectivity between two clients (<code>client1</code> and <code>client3</code>) residing in different subnets leveraging EDA's Router and Routed Interface resources. Specifically:</p> <ul> <li>You created a Router resource that defined a virtual routing instance (VRF) in the datacenter fabric</li> <li>You configured Routed Interfaces that connected the physical interfaces to the Router resource</li> <li>You established proper IP addressing for both IPv4 and IPv6 on the Routed Interfaces</li> <li>You verified connectivity between clients across different subnets through successful ping tests</li> </ul> <p>Now that you mastered Layer-2 and Layer-3 basic buildings blocks represented by Bridge Domains and Routers, it is time to see how they can be combined in a single unit of abstraction that we call a Virtual Network, or VNET for short. On to the next exercise!</p> <ol> <li> <p>If you want to learn more about transactions, checkout transactions section of the Declarative Intents exercise.\u00a0\u21a9</p> </li> </ol>"},{"location":"overlay/virtual-networks.html","title":"Virtual Networks","text":"Short Description Creating a virtual network with EDA to combine layer-2 and layer-3 connectivity Difficulty Beginner Topology Nodes  client1,  client2,  client3,  leaf1,  leaf2,  leaf3 <p>This is the final exercise in a 3-part series around using EDA to achieve connectivity within your datacenter. In this exercise, we will leverage the knowledge gained in the previous two parts and deploy both layer-2 and layer-3 overlay services. Thanks to the power of abstracted and derived intents, under the hood the virtual network will create the individual resources we created manually in parts 1 &amp; 2.</p> <ul> <li>Part 1: achieve layer-2 connectivity using bridge domains</li> <li>Part 2: achieve layer-3 connectivity using routers</li> <li>Part 3 (this activity): combine layer-2 and layer-3 connectivity through a single EDA object: the Virtual Network</li> </ul>"},{"location":"overlay/virtual-networks.html#objective","title":"Objective","text":"<p>Through the past two exercises, you have learned how to deploy pure layer-2 and pure layer-3 overlay services using EDA abstracted intents. In particular, for layer-2 services you have used the Bridge Domain/Bridge Interface/VLAN resources, and for layer-3 services you used the Router/Routed Interface.</p> <p>However, both these designs have their own challenges and limitations. A layer-2 overlay service does not allow inter-subnet routing and has all the challenges of a big broadcast domain. A pure layer-3<sup>1</sup> design with clients using the layer-3 interfaces not only does not support applications that require L2 connectivity, but would also require each leaf to have a distinct and dedicated routed interface with a unique gateway IP, which makes host migration difficult.</p> <p>This is why many datacenters are built using the hybrid approach of combining small layer-2 overlay services with the inter-subnet overlay routing. This design allows clients to use a simple LAG interface towards the leaf switches, while achieving multihoming, workload migration and layer-2 connectivity, when required.</p> <p>In this exercise your focus will be on building a composite overlay service that will enable three linux hosts to talk to each other, both within their own subnet (switched traffic) and between the subnets (routed traffic).</p>"},{"location":"overlay/virtual-networks.html#technology-explanation","title":"Technology explanation","text":"<p>We have covered the scenario where hosts can talk to each other in a layer-2 domain (via a Bridge Domain), and the scenario where hosts in different subnets can be interconnected (via a Router). We did not cover perhaps the most frequent scenario: a combination of the layer-2 inter-subnet bridging and layer-3 routing to interconnected different subnets.</p> <p>Because of the popularity of this design, EDA provides a dedicated abstraction for it: the VNVirtual Networks resource that you can find in   VIRTUAL NETWORK category.</p> <p>A Virtual Network combines multiple bridge domains, routers, routed interfaces and protocols in a single resource. A typical Virtual Network might for example contain:</p> <ul> <li>A bridge domain for storage computes</li> <li>A bridge domain for GPU clusters</li> <li>A bridge domain for in-band management access to all computes</li> <li>Redundant routed interfaces, each towards a datacenter gateway (DCGW)</li> <li>BGP sessions with the DCGWs, so the internal routes can be advertised to the Wide-Area Network (WAN) and external routes can be imported to provide internet connectivity</li> </ul> <p>In this exercise, we'll create a mix of bridge domains and routed interfaces that can all communicate with each other, regardless of whether their IP addresses are in the same subnet or not. The whole network connectivity design will be driven off of a single abstracted intent - Virtual Network - that will emit multiple sub-resources that we previously covered in parts 1 and 2.</p> <p>The diagram below depicts how a single high-level Virtual Network resource emits multiple sub-resources and through this orchestrates a creation of a composite service topology.</p> <pre><code>graph TB\n    X[\"Virtual Network\"]--&gt;A[\"Router\"]\n    A--&gt;B[\"Bridge Domain A\"]\n    A--&gt;C[\"Bridge Domain B\"]\n    A--&gt;D[\"Routed Interface 1\"]\n    A--&gt;E[\"Routed Interface 2\"]\n    B--&gt;F[\"VLAN 300\"]\n    C--&gt;G[\"VLAN 311\"]</code></pre>"},{"location":"overlay/virtual-networks.html#irb-interfaces","title":"IRB interfaces","text":"<p>So far, we've seen two types of interfaces:</p> <ul> <li>A bridged interface, which connects a (physical port, VLAN) combination to a MAC-VRF</li> <li>A routed interface, which connects a (physical port, VLAN) combination to an IP-VRF</li> </ul> <p>With a bridged interface, we can interconnect many hosts with an IP in the same subnet, whereas with a routed interface we can allow a single host to communicate with IPs outside of their subnet. We're missing one piece of the puzzle: what if we want many hosts with IPs in the same subnet, to all be able to communicate with IP addresses in the other subnets?</p> <p>That's where the Integrated Routing and Bridging (IRB) comes in: an IRB is a logical interface that connects a MAC-VRF to an IP-VRF. The IRB needs to have an IP address assigned to it that the bridged interfaces will use to reach addresses outside of their subnet. Usually, the first host in the subnet is assigned to the IRB and is called the \"anycast gateway\", or simply \"gateway\".</p> <pre><code>graph TB\n    A[\"IP VRF\"]--&gt;B[\"IRB 1 (10.100.100.1/24)\"]\n    A--&gt;C[\"IRB 2 (10.200.200.129/26)\"]\n    B--&gt;D[\"MAC-VRF 1\"]\n    C--&gt;E[\"MAC-VRF 2\"]\n    D---&gt;F[\"Host 1 (10.100.100.10)\"]\n    D--&gt;G[\"Host 2 (10.100.100.11)\"]\n    D---&gt;H[\"Host 3 (10.100.100.15)\"]\n    E--&gt;I[\"Host 4 (10.200.200.135)\"]\n    E---&gt;J[\"Host 5 (10.200.200.136)\"]\n    E--&gt;K[\"Host 6 (10.200.200.137)\"]</code></pre> <p>The IRB interfaces depicted above \"connect\" a MAC-VRF to an IP-VRF and make the inter-subnet routing possible.</p>"},{"location":"overlay/virtual-networks.html#tasks","title":"Tasks","text":"<p>See Access Details if you need a reminder on how to access the nodes in the topology.</p> <p>For this exercise the relevant IP configuration on the clients is presented below:</p> Client Interface IP address VLAN client1 eth1.300 10.30.0.11/24  fd00:fdfd:0:3000::11/64 300 eth1.311 10.30.1.11/24  fd00:fdfd:0:3001::11/64 311 client2 eth1.300 10.30.0.12/24  fd00:fdfd:0:3000::12/64 300 eth1.312 10.30.2.12/24  fd00:fdfd:0:3002::12/64 312 client3 eth1.300 10.30.0.13/24  fd00:fdfd:0:3000::13/64 300 eth1.313 10.30.3.13/24  fd00:fdfd:0:3003::13/64 313 <p>And your task is to create a service that has the following connectivity matrix:</p> Target connectivity <p>IMPORTANT</p> <p>Remove any Bridge Domains, Bridge Interfaces, VLANs and Routed Interfaces that you may have created in the Bridge Domains/Part 1 and the Routers/Part 2 as our Virtual Network will create them or simply reset EDA using the git time machine.</p> <p>Be careful when removing these resources and do not remove resources that have <code>role=hackathon-infra</code> tag as they are infrastructure related. But if you messed it up, don't worry, you can always reset EDA.</p> <p>You should expect that clients can't reach each other in any direction, due to no overlay services being configured.</p>"},{"location":"overlay/virtual-networks.html#list-virtual-networks","title":"List Virtual Networks","text":"<p>Login to the EDA UI using the assigned Group ID and EDA credentials provided to you.</p> <p>EDA Core and the Apps</p> <p>The EDA platform consists of the core and the apps that extend it and provide the resources for declarative network management. Although you can make your own apps, Nokia already provides an extensive library of pre-installed apps that can handle a lot of configuration tasks. Programming your own app is beyond the scope of this exercise.</p> <p>Look at the app menu in the left sidebar for VNVirtual Networks, which is located in the   VIRTUAL NETWORK category.</p> <p></p> <p>When you click on the VNVirtual Networks menu element, you get the list of existing Virtual Network resources. There might be one VNET already that powers up the hackathon infrastructure, but it does not interfere with the goal of this exercise. Time to create your first Virtual Network and make your clients talk to each other.</p>"},{"location":"overlay/virtual-networks.html#create-a-virtual-network","title":"Create a Virtual Network","text":"<p>Use the knowledge of the previous two exercises (Bridge Domains and Routers) to achieve the connectivity as shown on the diagram above. A single virtual network resource would be able to define the following:</p> <ul> <li>a Router to create the IP-VRF of the EVPNVXLAN type</li> <li>two Routed Interfaces to connect the Router to the <code>client1</code> and <code>client3</code> over the respective VLANs 311 and 313</li> <li>two Bridge Domains to create subnets for VLAN 300 and 312 respectively</li> <li>two VLAN resources to create Bridge Interfaces for the respective VLANs 300 and 312</li> <li>two IRB Interfaces to connect the Bridge Domains to the Router</li> </ul> <p>Yes, a single Virtual Network resource can define all of these objects, and it will emit the necessary sub resources, and each sub resource can emit its own sub resources, and so on, until the configuration is complete.</p> <p>Note</p> <p>Hosts <code>client1</code> and <code>client3</code> are both single-homed clients, meaning that they physically connect to only one leaf switch.</p> <p>Host <code>client2</code> is different: it is multihomed to 3 leaf switches in an all-active configuration, and its EDA interface is called <code>lag1</code>. Can you find this special interface in EDA? Which physical ports are connected to <code>client2</code>?</p> <p>Auto-completion for non-committed objects</p> <p>When creating an IRB for example, you must specify references to both a Router and a Bridge Domain. The autocomplete suggestions of these fields only show created objects. Therefore, you will not see suggestions for Routers and Bridge Domains that have not been committed yet. Specify the name without the auto-completion, as you provide it in the same resource.</p> Solution <p>It might be tricky to solve this challenge if you see EDA for the first time, so here is a solution:</p> <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: VirtualNetwork\nmetadata:\n  name: virtual-network\n  namespace: eda\n  labels:\n    role: exercise\nspec:\n  routers:\n    - name: vnet-router\n      spec:\n        eviPool: evi-pool\n        tunnelIndexPool: tunnel-index-pool\n        type: EVPNVXLAN\n        vniPool: vni-pool\n\n  routedInterfaces:\n    - name: vnet-routed-interface-client1\n      spec:\n        interface: leaf1-client1\n        ipv4Addresses:\n          - ipPrefix: 10.30.1.1/24\n            primary: true\n        ipv6Addresses:\n          - ipPrefix: fd00:fdfd:0:3001::1/64\n            primary: true\n        router: vnet-router\n        vlanID: '311'\n    - name: vnet-routed-interface-client3\n      spec:\n        interface: leaf3-client3\n        ipv4Addresses:\n          - ipPrefix: 10.30.3.1/24\n            primary: true\n        ipv6Addresses:\n          - ipPrefix: fd00:fdfd:0:3003::1/64\n            primary: true\n        router: vnet-router\n        vlanID: '313'\n\n  bridgeDomains:\n    - name: vnet-bridge-domain-300\n      spec:\n        eviPool: evi-pool\n        tunnelIndexPool: tunnel-index-pool\n        type: EVPNVXLAN\n        vniPool: vni-pool\n    - name: vnet-bridge-domain-312\n      spec:\n        eviPool: evi-pool\n        tunnelIndexPool: tunnel-index-pool\n        type: EVPNVXLAN\n        vniPool: vni-pool\n\n  vlans:\n    - name: vnet-vlan-300\n      spec:\n        bridgeDomain: vnet-bridge-domain-300\n        interfaceSelector:\n          - edge-type=compute\n        uplink:\n          uplinkVLANID: pool\n        vlanID: '300'\n    - name: vnet-vlan-312\n      spec:\n        bridgeDomain: vnet-bridge-domain-312\n        interfaceSelector:\n          - edge-type=compute\n        uplink:\n          uplinkVLANID: pool\n        vlanID: '312'\n\n  irbInterfaces:\n    - name: vnet-irb-300\n      spec:\n        bridgeDomain: vnet-bridge-domain-300\n        ipAddresses:\n          - ipv4Address:\n              ipPrefix: 10.30.0.1/24\n              primary: true\n            ipv6Address:\n              ipPrefix: fd00:fdfd:0:3000::1/64\n              primary: true\n        hostRoutePopulate:\n          dynamic: true\n          static: true\n        router: vnet-router\n    - name: vnet-irb-312\n      spec:\n        bridgeDomain: vnet-bridge-domain-312\n        ipAddresses:\n          - ipv4Address:\n              ipPrefix: 10.30.2.1/24\n              primary: true\n            ipv6Address:\n              ipPrefix: fd00:fdfd:0:3002::1/64\n              primary: true\n        hostRoutePopulate:\n          dynamic: true\n          static: true\n        router: vnet-router\n</code></pre> <p>We recommend you do a Dry Run first, and see the node configuration diff to see how much stuff gets created on the node when you commit it. Overlay services is not a small feat, and configuring this manually would be a lot of work. With EDA, you get a lot for free, with reliable and fast transaction model to ensure consistency and reliability.</p> <p>When the Virtual Network resource is successfully created, test the connectivity between the clients. Try to understand what the ping command is doing, and which components you created in EDA are responsible for routing/switching the traffic to the correct destination. The activity has been successfully completed if all these ping commands succeed.</p> Ping &amp; traceroute command syntax <p>You can use the <code>-I</code> flat to force a ping request to exit through a particular interface. This is used in the commands below to force the traffic to either be switched or routed.</p> <p>Similarly, you can use the <code>-i</code> flag with traceroute to see the difference between switched and routed traffic:</p> <pre><code>[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; traceroute -i eth1.300 10.30.0.12\ntraceroute to 10.30.0.12 (10.30.0.12), 30 hops max, 46 byte packets\n 1  10.30.0.12 (10.30.0.12)  0.826 ms  0.733 ms  0.510 ms\n\n[*]\u2500[client1]\u2500[/]\n\u2514\u2500\u2500&gt; traceroute -i eth1.311 10.30.0.12\ntraceroute to 10.30.0.12 (10.30.0.12), 30 hops max, 46 byte packets\n 1  10.30.1.1 (10.30.1.1)  1.156 ms  1.262 ms  0.769 ms\n 2  10.30.0.12 (10.30.0.12)  0.978 ms  0.777 ms  0.777 ms\n</code></pre> client1client2client3 <ul> <li><code>ping -I eth1.300 10.30.0.12</code></li> <li><code>ping -I eth1.311 10.30.2.12</code></li> <li><code>ping -I eth1.311 10.30.3.13</code></li> </ul> <ul> <li><code>ping -I bond0.300 10.30.0.13</code></li> <li><code>ping -I bond0.312 10.30.1.11</code></li> <li><code>ping -I bond0.312 10.30.3.13</code></li> </ul> <ul> <li><code>ping -I eth1.300 10.30.0.11</code></li> <li><code>ping -I eth1.313 10.30.1.11</code></li> <li><code>ping -I eth1.313 10.30.2.12</code></li> </ul>"},{"location":"overlay/virtual-networks.html#summary","title":"Summary","text":"<p>In this exercise, you successfully created a Virtual Network that combines both layer-2 and layer-3 connectivity in a single abstracted intent. Specifically:</p> <ul> <li>You created a Virtual Network resource that defined multiple components in one declaration:<ul> <li>A Router to create an IP-VRF for layer-3 routing</li> <li>Routed Interfaces to connect clients directly to the Router over specific VLANs</li> <li>Bridge Domains to create layer-2 connectivity for specific VLANs</li> <li>VLAN resources to create Bridge Interfaces for the respective VLANs</li> <li>IRB Interfaces to connect the Bridge Domains to the Router, enabling inter-subnet routing</li> </ul> </li> </ul> <p>This exercise demonstrated the power of abstraction in EDA, where a single high-level Virtual Network resource can emit multiple sub-resources to orchestrate a complete connectivity solution. By combining layer-2 and layer-3 services, you've created a more flexible network design that supports both applications requiring direct layer-2 connectivity and the scalability benefits of layer-3 routing between subnets.</p> <ol> <li> <p>You can check an in-depth lab where we covered this type of design at Learn SR Linux blog.\u00a0\u21a9</p> </li> </ol>"},{"location":"telco-cloud/unequal-ecmp.html","title":"Unequal ECMP for EVPN IP prefix routes","text":"Short Description Enable Unequal ECMP for anycast BGP PE-CE routes Estimated Time 60 minutes Topology Nodes  client1,  client3,  client4,  client5,  leaf1,  leaf3,  borderleaf1,  borderleaf2 References SR Linux documentation"},{"location":"telco-cloud/unequal-ecmp.html#objective","title":"Objective","text":"<p>In this activity, you will deploy a virtual network with BGP PE-CE edge connectivity to the clients that are running FRR. The clients on the leaf side are advertising the 1.1.1.0/24 subnet into the L3 service. This can be seen as an anycast services network. Leaf1 has a single path to the network, while leaf3 has 2. In normal operation, the borderleafs will load-balance evenly to leaf1 and leaf3. To ensure equal load-balancing on the edge interfaces, instead of across VTEPs, we can enable EVPN with weighted ECMP.</p>"},{"location":"telco-cloud/unequal-ecmp.html#technology-explanation","title":"Technology explanation","text":""},{"location":"telco-cloud/unequal-ecmp.html#weighted-ecmp-for-evpn-ip-prefix-routes","title":"Weighted ECMP for EVPN IP prefix routes","text":"<p>SR Linux supports weighted Equal Cost Multi Path (ECMP) for EVPN IP prefix IFL (interface-less) routes for EVPN-VXLAN and EVPN-MPLS services. To do this, SR Linux makes use of the EVPN link-bandwidth extended community (EC) defined in draft-ietf-bess-evpn-unequal-lb. This extended community indicates the weight for a specific IP prefix; that is, the number of PE-CE multi-paths for an IP prefix that is re-advertised into an EVPN IP prefix route.</p> <p>EVPN using weighted ECMP shows an example of weighted ECMP. Assuming each Container Network Function (CNF) advertises the anycast subnet 1.1.1.0/24 from a different next-hop, each leaf ends up with a different number of multi-paths in its PE-CE session. In the example below, leaf3 has 2 multi-paths for the anycast subnet, and the advertised EVPN IP prefix route includes an EVPN link-bandwidth extended community with a weight of 2. Leaf1 sends a weight of 1.</p> <p>On the border leafs / data center gateways, when this feature is enabled, if the EVPN IP prefix route has an Ethernet Segment Identifier (ESI) of 0, the PE sprays the flows to the EVPN IP prefix route based on the received weight; in this example, one-third of the flows are sent to Leaf1, and two-thirds are sent to Leaf3.</p> <p></p> EVPN using weighted ECMP"},{"location":"telco-cloud/unequal-ecmp.html#service-creation-using-eda","title":"Service creation using EDA","text":"<p>EDA provides a dedicated abstraction for the creation of combined layer-2 and layer-3 services: the VNVirtual Networks resource. Off course you can also create L2 and L3 services separately, using the BDBridge Domains and RRouters resources respectively. More information on this can be found in the References sections. In this activity, we will use the <code>Virtual Networks</code> resource.</p> <p>A Virtual Network combines multiple bridge domains, routers, routed interfaces and protocols in a single resource. A typical Virtual Network might for example contain:</p> <ul> <li>A bridge domain for storage computes</li> <li>A bridge domain for GPU clusters</li> <li>A bridge domain for in-band management access to all computes</li> <li>Redundant routed interfaces, each towards a datacenter gateway (DCGW)</li> <li>BGP sessions with the DCGWs, so the internal routes can be advertised to the Wide-Area Network (WAN) and external routes can be imported to provide internet connectivity</li> </ul> <p>The diagram below depicts how a single high-level Virtual Network resource emits multiple sub-resources and through this orchestrates a creation of a composite service topology.</p> <pre><code>graph TB\n    X[\"Virtual Network\"]--&gt;A[\"Router\"]\n    A--&gt;B[\"Bridge Domain A\"]\n    A--&gt;C[\"Bridge Domain B\"]\n    A--&gt;D[\"Routed Interface 1\"]\n    A--&gt;E[\"Routed Interface 2\"]\n    B--&gt;F[\"VLAN 300\"]\n    C--&gt;G[\"VLAN 311\"]</code></pre> <p>More details about service creation using EDA can be found in activities Bridge Domains, Routers and Virtual Networks in the References section.</p> <p>In this exercise, we'll create a L3 EVPN service with routed interfaces towards clients 1, 3, 4 and 5. Over these interfaces, we will also run eBGP sessions. The diagram below depicts what your Virtual Network resource will create.</p> <pre><code>graph TB\n    X[\"Virtual Network\"]--&gt;A[\"Router\"]\n    A--&gt;B[\"Routed Interface 1 - 5\"]\n    A--&gt;C[\"BGP Group CNF\"]\n    A--&gt;D[\"BGP Group PE-CE\"]\n    A--&gt;E[\"BGP Peer 1 - 5\"]</code></pre>"},{"location":"telco-cloud/unequal-ecmp.html#tasks","title":"Tasks","text":""},{"location":"telco-cloud/unequal-ecmp.html#create-the-virtual-network-with-bgp-pe-ce-edge-connectivity","title":"Create the Virtual Network with BGP PE-CE edge connectivity","text":"Unequal ECMP service architecture <p>Before enabling weighted ECMP, we will deploy the service used for this use-case. Deploy the Unequal ECMP service architecture using the VNVirtual Networks resource. </p> <p>In a single virtual network resource you will be able to define:</p> <ul> <li>a Router to create the IP-VRF of the EVPNVXLAN type</li> <li>five Routed Interfaces to connect the Router to the <code>client1</code>, <code>client3</code>, <code>client4</code> and <code>client5</code> over the VLAN 400</li> <li>two BGP Groups where you specify the used <code>Routing Policies</code>, address families and AS numbers</li> <li>five BGP Peers that reference a <code>Routed Interface</code>, inherit properties from a <code>BGP Group</code>, and where you define the peer IP address</li> </ul> <p></p> <p>Note</p> <p>Hosts <code>client1</code>, <code>client3</code> and <code>client4</code> are running BGP with ASN 65554. Host <code>client5</code> is running BGP with ASN 65556.</p> Hint <p>In this lab environment, for simplicity, we can use the <code>accept-all</code> routing policy.</p> Solution <pre><code>apiVersion: services.eda.nokia.com/v1\nkind: VirtualNetwork\nmetadata:\n  name: vrf1\n  namespace: eda\nspec:\n  protocols:\n    bgp:\n      bgpGroups:\n        - name: bgp-group-cnf\n          spec:\n            exportPolicy:\n              - accept-all\n            importPolicy:\n              - accept-all\n            ipv4Unicast:\n              enabled: true\n            localAS:\n              autonomousSystem: 65555\n            peerAS:\n              autonomousSystem: 65554\n        - name: bgp-group-pe\n          spec:\n            exportPolicy:\n              - accept-all\n            importPolicy:\n              - accept-all\n            ipv4Unicast:\n              enabled: true\n            localAS:\n              autonomousSystem: 65555\n            peerAS:\n              autonomousSystem: 65556\n      bgpPeers:\n        - name: cnf1\n          spec:\n            dynamicNeighbor: false\n            group: bgp-group-cnf\n            interface: vrf1-routed-interface-client1\n            interfaceKind: ROUTEDINTERFACE\n            peerIP: 10.40.1.1\n        - name: cnf3\n          spec:\n            dynamicNeighbor: false\n            group: bgp-group-cnf\n            interface: vrf1-routed-interface-client3\n            interfaceKind: ROUTEDINTERFACE\n            peerIP: 10.40.3.1\n        - name: cnf4\n          spec:\n            dynamicNeighbor: false\n            group: bgp-group-cnf\n            interface: vrf1-routed-interface-client4\n            interfaceKind: ROUTEDINTERFACE\n            peerIP: 10.40.4.1\n        - name: pe5-1\n          spec:\n            dynamicNeighbor: false\n            group: bgp-group-pe\n            interface: vrf1-routed-interface-bleaf1-client5\n            interfaceKind: ROUTEDINTERFACE\n            peerIP: 20.40.1.1\n        - name: pe5-2\n          spec:\n            dynamicNeighbor: false\n            group: bgp-group-pe\n            interface: vrf1-routed-interface-bleaf2-client5\n            interfaceKind: ROUTEDINTERFACE\n            peerIP: 20.40.2.1\n  routedInterfaces:\n    - name: vrf1-routed-interface-client1\n      spec:\n        arpTimeout: 14400\n        interface: leaf1-client1\n        ipMTU: 1500\n        ipv4Addresses:\n          - ipPrefix: 10.40.1.0/31\n        learnUnsolicited: NONE\n        router: router-vrf1\n        vlanID: '400'\n        vlanPool: vlan-pool\n    - name: vrf1-routed-interface-client3\n      spec:\n        arpTimeout: 14400\n        interface: leaf3-client3\n        ipMTU: 1500\n        ipv4Addresses:\n          - ipPrefix: 10.40.3.0/31\n        learnUnsolicited: NONE\n        router: router-vrf1\n        vlanID: '400'\n        vlanPool: vlan-pool\n    - name: vrf1-routed-interface-client4\n      spec:\n        arpTimeout: 14400\n        interface: leaf3-client4\n        ipMTU: 1500\n        ipv4Addresses:\n          - ipPrefix: 10.40.4.0/31\n        learnUnsolicited: NONE\n        router: router-vrf1\n        vlanID: '400'\n        vlanPool: vlan-pool\n    - name: vrf1-routed-interface-bleaf1-client5\n      spec:\n        arpTimeout: 14400\n        interface: borderleaf1-client5\n        ipMTU: 1500\n        ipv4Addresses:\n          - ipPrefix: 20.40.1.0/31\n        learnUnsolicited: NONE\n        router: router-vrf1\n        vlanID: '400'\n        vlanPool: vlan-pool\n    - name: vrf1-routed-interface-bleaf2-client5\n      spec:\n        arpTimeout: 14400\n        interface: borderleaf2-client5\n        ipMTU: 1500\n        ipv4Addresses:\n          - ipPrefix: 20.40.2.0/31\n        learnUnsolicited: NONE\n        router: router-vrf1\n        vlanID: '400'\n        vlanPool: vlan-pool\n  routers:\n    - name: router-vrf1\n      spec:\n        bgp:\n          autonomousSystem: 65555\n          ebgpPreference: 170\n          enabled: true\n          ibgpPreference: 170\n          ipv4Unicast:\n            enabled: true\n            multipath:\n              allowMultipleAS: true\n              maxAllowedPaths: 64\n          minWaitToAdvertise: 0\n          rapidWithdrawl: true\n          waitForFIBInstall: false\n        eviPool: evi-pool\n        tunnelIndexPool: tunnel-index-pool\n        type: EVPNVXLAN\n        vniPool: vni-pool\n</code></pre>"},{"location":"telco-cloud/unequal-ecmp.html#validate-ecmp-traffic-load-balancing","title":"Validate ECMP traffic load-balancing","text":"<p>You can run traffic between <code>client5</code> and the anycast service advertised by the CNFs using the script <code>clab/configs/client/run-traffic.sh</code>. This scripts takes the input of amount of seconds to run the traffic. This script will run 100 different iperf flows of 50kbps across the fabric to the 1.1.1.0/24 subnet.</p> <pre><code>$ bash clab/configs/client/run-traffic.sh 120\nclient1: 7d4e2829e2fc\nclient3: cfc6f672bb4d\nclient4: 15ab2fd79ff7\nclient5: 811ead78f872\niperf server already running in container 7d4e2829e2fc\niperf server already running in container cfc6f672bb4d\niperf server already running in container 15ab2fd79ff7\nStarting iperf flows from client5...\n# clipped\n</code></pre>"},{"location":"telco-cloud/unequal-ecmp.html#grafana-dashboard","title":"Grafana Dashboard","text":"<p>Navigate to <code>https://{your-ip}:9443/core/httpproxy/v1/grafana/dashboard</code> to see the live traffic distribution accross the fabric.</p> <p></p>"},{"location":"telco-cloud/unequal-ecmp.html#custom-eda-dashboard","title":"Custom EDA Dashboard","text":"<p>In EDA, you can also build custom dashboards. This allows you to create visualizations of your network's state information for specific use-cases. In this case, we are interested in the ingress traffic distribution between the different leaf nodes. We've prepared such a dashboard for you, it can be found at <code>Dashboards</code></p> <p> </p>"},{"location":"telco-cloud/unequal-ecmp.html#enable-unequal-ecmp-for-evpn-ip-prefix-routes","title":"Enable Unequal ECMP for EVPN IP prefix routes","text":"<p>From the SR Linux documentation, we can see that we require some configuration in the BGP Peer context and the <code>bgp-evpn</code> context, to enable weighted EVPN ECMP for PE-CE BGP routes.</p> <p>To achieve this we need to configure the following on <code>leaf1</code> and <code>leaf3</code>:</p> <ol> <li>Enable advertisements of the EVPN link bandwidth extended community: <pre><code>network-instance router-vrf1 {\n    protocols {\n        bgp-evpn {\n            bgp-instance 1 {\n                routes {\n                    route-table {\n                        ip-prefix {\n                            evpn-link-bandwidth {\n                                advertise {\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre></li> <li>Configure a weight to be internally added to the received PE-CE BGP routes: <pre><code>network-instance router-vrf1 {\n    protocols {\n        bgp {\n            group bgp-group-cnf {\n                afi-safi ipv4-unicast {\n                    ipv4-unicast {\n                        link-bandwidth {\n                            add-next-hop-count-to-received-bgp-routes 1\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre></li> </ol> <p>Similarly, we need to enable weighted ECMP on the borderleafs. When weighted ECMP is enabled, the system takes into account the EVPN link-bandwidth extended community when installing an ECMP set for an EVPN IP prefix route in the IP-VRF route table.</p> <pre><code>network-instance router-vrf1 {\n    protocols {\n        bgp-evpn {\n            bgp-instance 1 {\n                routes {\n                    route-table {\n                        ip-prefix {\n                            evpn-link-bandwidth {\n                                weighted-ecmp {\n                                    admin-state enable\n                                    max-ecmp-hash-buckets-per-next-hop-group 4\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Off course, we will not log into every single node and configure this manually. With EDA, you can use <code>Configlets</code> to configure anything that is not covered by intents.</p> <p>Translate these config snippets into EDA <code>Configlets</code> to easily deploy this configuration on multiple nodes. To achiieve this, the steps involve:</p> <ol> <li>Navigate to the Configlets resource and create a new resource </li> <li>Select your target nodes using a label or reference them directly. Specify the NOS and version. </li> <li>Specify your configlet details, this includes the <code>YANG</code> path in <code>jspath</code> notation, and the node configuration in JSON formatting. </li> </ol> Hint <p>To easily retrieve the jspath and configuration, you can log into a node and push your required configuration. Next, you can use the command <code>pwc jspath</code> to retrieve the current working context in jspath format. Finally, you can retrieve the configuration in JSON format using the command <code>info | as json</code></p> Solution EVPN Link Bandwidth AdvertisePE-CE BGP weighted routesEnable Weighted ECMP <pre><code>apiVersion: config.eda.nokia.com/v1alpha1\nkind: Configlet\nmetadata:\n  name: router-vrf1-evpn-link-bandwidth-advertise\n  namespace: eda\nspec:\n  configs:\n    - config: '{}'\n      operation: Create\n      path: &gt;-\n        .network-instance{.name==\"router-vrf1\"}.protocols.bgp-evpn.bgp-instance{.id==1}.routes.route-table.ip-prefix.evpn-link-bandwidth.advertise\n  endpoints:\n    - leaf1\n    - leaf3\n  operatingSystem: srl\n  priority: 0\n  version: 25.10.1\n</code></pre> <pre><code>apiVersion: config.eda.nokia.com/v1alpha1\nkind: Configlet\nmetadata:\n  name: bgp-group-cnf-link-bandwith\n  namespace: eda\nspec:\n  configs:\n    - config: |\n        {\n          \"link-bandwidth\": {\n            \"add-next-hop-count-to-received-bgp-routes\": 1\n          }\n        }\n      operation: Create\n      path: &gt;-\n        .network-instance{.name==\"router-vrf1\"}.protocols.bgp.group{.group-name==\"bgp-group-cnf\"}.afi-safi{.afi-safi-name==\"ipv4-unicast\"}.ipv4-unicast\n  endpoints:\n    - leaf1\n    - leaf3\n  operatingSystem: srl\n  priority: 0\n  version: 25.10.1\n</code></pre> <pre><code>apiVersion: config.eda.nokia.com/v1alpha1\nkind: Configlet\nmetadata:\n  name: router-vrf1-enable-weighted-ecmp\n  namespace: eda\nspec:\n  configs:\n    - config: |-\n        {\n          \"admin-state\": \"enable\",\n          \"max-ecmp-hash-buckets-per-next-hop-group\": 4\n        }\n      operation: Create\n      path: &gt;-\n        .network-instance{.name==\"router-vrf1\"}.protocols.bgp-evpn.bgp-instance{.id==1}.routes.route-table.ip-prefix.evpn-link-bandwidth.weighted-ecmp\n  endpoints:\n    - borderleaf1\n    - borderleaf2\n  operatingSystem: srl\n  priority: 0\n  version: 25.10.1\n</code></pre>"},{"location":"telco-cloud/unequal-ecmp.html#validate-weighted-ecmp-traffic-load-balancing","title":"Validate Weighted ECMP traffic load-balancing","text":"<p>You can run traffic between <code>client5</code> and the anycast service advertised by the CNFs using the script <code>clab/configs/client/run-traffic.sh</code>. This scripts takes the input of amount of seconds to run the traffic. This script will run 100 different iperf flows of 50kbps across the fabric to the 1.1.1.0/24 subnet.</p> <pre><code>$ bash clab/configs/client/run-traffic.sh 120\nclient1: 7d4e2829e2fc\nclient3: cfc6f672bb4d\nclient4: 15ab2fd79ff7\nclient5: 811ead78f872\niperf server already running in container 7d4e2829e2fc\niperf server already running in container cfc6f672bb4d\niperf server already running in container 15ab2fd79ff7\nStarting iperf flows from client5...\n# clipped\n</code></pre>"},{"location":"telco-cloud/unequal-ecmp.html#grafana-dashboard_1","title":"Grafana Dashboard","text":"<p>Navigate to <code>https://{your-ip}:9443/core/httpproxy/v1/grafana/dashboard</code> to see the live traffic distribution accross the fabric.</p> <p></p>"},{"location":"telco-cloud/unequal-ecmp.html#custom-eda-dashboard_1","title":"Custom EDA Dashboard","text":""},{"location":"telco-cloud/unequal-ecmp.html#summary","title":"Summary","text":"<p>In this exercise, you successfully created a Virtual Network that enables layer-3 connectivity and PE-CE BGP sessions in a single abstracted intent. Specifically:</p> <ul> <li>You created a Virtual Network resource that defined multiple components in one declaration:<ul> <li>A Router to create an IP-VRF for layer-3 routing</li> <li>Routed Interfaces to connect clients directly to the Router over specific VLANs</li> <li>BGP Peerings to manage edge connectivity</li> </ul> </li> </ul> <p>Next to this you enabled Weighted ECMP for EVPN IP prefix routes, to ensure an equal traffic distribution on the edge links.</p>"},{"location":"underlay/fabrics.html","title":"Fabrics","text":"Short Description Creating underlay connectivity and overlay control plane using the fabric resource Estimated Time 30 minutes Topology Nodes  spine1,  spine2,  leaf1,  leaf2,  leaf3,  borderleaf1,  borderleaf2"},{"location":"underlay/fabrics.html#objective","title":"Objective","text":"<p>In this exercise, we enable IP connectivity between the switches in our lab topology. This underlay network is the basis of our fabric. It provides connectivity and allows EVPN routes to be exchanged to build services.</p>"},{"location":"underlay/fabrics.html#technology-explanation","title":"Technology explanation","text":"<p>Typically in a Data Center Fabric network, BGP is used as the de-facto routing protocol. The control plane is split into two functions, the underlay and the overlay network. </p>"},{"location":"underlay/fabrics.html#underlay-network","title":"Underlay Network","text":"<p>The underlay network provides IP connectivity between the data center's servers and routers. Typically, eBGP is being used as routing protocol for its dependability and scalability.</p> Underlay Network"},{"location":"underlay/fabrics.html#overlay-network","title":"Overlay Network","text":"<p>An overlay network is established using tunneling techniques to carry traffic over the underlay network. This makes an overlay network logically separate and independent from the addressing and protocols used in the underlay network. It also keeps the overlay networks logically separate from each other. Workloads that are connected to the same overlay network can send Ethernet or IP packets to each other, but not to workloads in other overlay networks. Typically, iBGP is used to distribute reachability information for the workload endpoints.</p> Overlay Network"},{"location":"underlay/fabrics.html#building-fabrics-using-eda","title":"Building Fabrics using EDA","text":"<p>We will need to establish eBGP sessions between leafs and spines, and a full mesh of iBGP sessions to setup the underlay and overlay networks in our fabric. EDA will abstract the concept of a \"fabric\" and translate the user's input into node configuration.</p> <p>When building a fabric, you need to be weary of many different things, ISL IP addresses, ASNs, routing policies, loopback IP addresses, etc. EDA will automatically allocate these parameters from a pool. However, if you want more control over these choices, this is still possible.</p> <p>EDA is built on apps, the <code>Fabrics</code> app allows you to create a fabric, which on its turn will create multiple resources in other apps, which in its turn are translated into node configuration. </p>"},{"location":"underlay/fabrics.html#tasks","title":"Tasks","text":"<p>Remove existing fabric</p> <p>Before continuing to this activity, make sure you remove the already existing fabric resource. This was set in place to run the other activities smoothly.</p> <p>To remove, navigate to the <code>Fabrics</code> resource, and delete the <code>srexperts-fabric</code> resource. </p>"},{"location":"underlay/fabrics.html#validate-that-no-ip-connectivity-is-present","title":"Validate that no IP connectivity is present","text":"<p>In SR Linux, the underlay routing protocol is specified in the default network-instance. Therefore, the absolute minimum configuration required to build a fabric, is the default network-instance.</p> <p>Login into one of the nodes and verify whether the default network-instance is configured.</p> Solution CommandExpected Output <pre><code>admin@leaf1# info network-instance default\n</code></pre> <pre><code>*EMPTY*\n</code></pre>"},{"location":"underlay/fabrics.html#create-a-fabric","title":"Create a Fabric","text":"<p>Navigate to the fabrics app and create a new fabric resource.</p> <p></p> <p>Go through the form and build your fabric.</p> Hint <p>Make sure, when filling out the form, that you are using the appropriate labels to build your fabric resource efficiently.</p> Node role labels <pre><code># &lt;SNIP&gt;\n  borderLeafs:\n    borderLeafNodeSelector:\n      - eda.nokia.com/role=borderleaf\n  leafs:\n    leafNodeSelector:\n      - eda.nokia.com/role=leaf\n  spines:\n    spineNodeSelector:\n      - eda.nokia.com/role=spine\n# &lt;SNIP&gt;\n</code></pre> Hint <p>When selecting your inter-switch links (ISLs), you can allocate them to an address pool, or skip this entirely by using IPv6 unnumbered interfaces. This also saves you some IP addressing space. <pre><code># &lt;SNIP&gt;\n  interSwitchLinks:\n    linkSelector:\n      - eda.nokia.com/role=interSwitch\n    unnumbered: IPV6\n# &lt;SNIP&gt;\n</code></pre></p> Solution <p>It might be tricky to solve this challenge if you see EDA for the first time, so here is a solution: <pre><code>apiVersion: fabrics.eda.nokia.com/v1alpha1\nkind: Fabric\nmetadata:\n  name: my-fabric\n  namespace: eda\nspec:\n  borderLeafs:\n    borderLeafNodeSelector:\n      - eda.nokia.com/role=borderleaf\n  interSwitchLinks:\n    linkSelector:\n      - eda.nokia.com/role=interSwitch\n    unnumbered: IPV6\n  leafs:\n    leafNodeSelector:\n      - eda.nokia.com/role=leaf\n  overlayProtocol:\n    bfd:\n      enabled: true\n    bgp:\n      autonomousSystem: 65000\n      clusterID: '1'\n      rrClientNodeSelector:\n        - eda.nokia.com/role=leaf\n        - eda.nokia.com/role=borderleaf\n      rrNodeSelector:\n        - eda.nokia.com/role=spine\n    protocol: IBGP\n  spines:\n    spineNodeSelector:\n      - eda.nokia.com/role=spine\n  systemPoolIPV4: systemipv4-pool\n  underlayProtocol:\n    bfd:\n      enabled: true\n    bgp:\n      asnPool: asn-pool\n    protocol:\n      - EBGP\n</code></pre></p> Other fabric types <p>You may have noticed that eBGP underlay / iBGP overlay is not the only option in our fabric abstraction. EDA allows you to build fabrics using eBGP, OSPFv2 and OSPFv3 on the underlay, and iBGP or eBGP on the overlay.</p> example: OSPFv2 underlay, iBGP overlay <pre><code>apiVersion: fabrics.eda.nokia.com/v1alpha1\nkind: Fabric\nmetadata:\n  name: my-fabric\n  namespace: eda\nspec:\n  borderLeafs:\n    borderLeafNodeSelector:\n      - eda.nokia.com/role = borderleaf\n  interSwitchLinks:\n    linkSelector:\n      - eda.nokia.com/role = interSwitch\n    poolIPV4: ipv4-pool\n  leafs:\n    leafNodeSelector:\n      - eda.nokia.com/role = leaf\n  overlayProtocol:\n    bfd:\n      desiredMinTransmitInt: 1000000\n      detectionMultiplier: 3\n      enabled: true\n      minEchoReceiveInterval: 1000000\n      requiredMinReceive: 1000000\n    bgp:\n      autonomousSystem: 65000\n      clusterID: '1'\n      rrClientNodeSelector:\n        - eda.nokia.com/role=leaf\n        - eda.nokia.com/role=borderleaf\n      rrNodeSelector:\n        - eda.nokia.com/role=spine\n    protocol: IBGP\n  spines:\n    spineNodeSelector:\n      - eda.nokia.com/role = spine\n  systemPoolIPV4: systemipv4-pool\n  underlayProtocol:\n    bfd:\n      enabled: true\n    protocol:\n      - OSPFv2\n</code></pre> example: eBGP underlay, eBGP overlay <pre><code>apiVersion: fabrics.eda.nokia.com/v1alpha1\nkind: Fabric\nmetadata:\n  name: my-fabric\n  namespace: eda\nspec:\n  borderLeafs:\n    borderLeafNodeSelector:\n      - eda.nokia.com/role = borderleaf\n  interSwitchLinks:\n    linkSelector:\n      - eda.nokia.com/role = interSwitch\n    unnumbered: IPV6\n  leafs:\n    leafNodeSelector:\n      - eda.nokia.com/role = leaf\n  overlayProtocol:\n    bgp: {}\n    protocol: EBGP\n  spines:\n    spineNodeSelector:\n      - eda.nokia.com/role = spine\n  systemPoolIPV4: systemipv4-pool\n  underlayProtocol:\n    bfd:\n      enabled: true\n    protocol:\n      - EBGP\n    bgp:\n      asnPool: asn-pool\n</code></pre>"},{"location":"underlay/fabrics.html#validate-underlay-connectivity","title":"Validate underlay connectivity","text":""},{"location":"underlay/fabrics.html#fabric-summary-dashboard","title":"Fabric summary dashboard","text":"<p>Most EDA applications are shipped with their dedicated dashboards. This way you can monitor your network's health in the blink of an eye.</p> <p></p>"},{"location":"underlay/fabrics.html#using-eda-workflows","title":"Using EDA Workflows","text":"<p>EDA comes with a set of operational automation tools, defined in <code>Workflows</code>. In this scenario, we can use the <code>Check BGP</code> workflow to validate the default BGP peers and the <code>Ping</code> workflow to ping one of the system loopback addresses from all nodes to validate the underlay routing.</p>"},{"location":"underlay/fabrics.html#check-bgp","title":"Check BGP","text":"<p>The only input required for the <code>Check BGP</code> workflow is the target node. Use a common label for all nodes to easily select all nodes in your topology in one go.</p> <code>Check BGP</code> Solution <code>Check BGP</code> WorkflowExpected Result <pre><code>apiVersion: protocols.eda.nokia.com/v1\nkind: CheckDefaultBgpPeers\nmetadata:\nname: checkdefaultbgppeers-c4ad2cea-6192-46f4-a4ff-ed292d6fbab8\nnamespace: eda\nspec:\nnodeSelector:\n    - containerlab=managedSrl\n</code></pre> <p></p>"},{"location":"underlay/fabrics.html#ping","title":"Ping","text":"<p>Identify the system loopback IP address using EQL. One of these addresses will serve as an input in the <code>Ping</code> workflow.</p> EQL solution EQLExpected Output <pre><code>.namespace.node.srl.interface.subinterface.ipv4.address where (.namespace.node.srl.interface.name = \"system0\")\n</code></pre> <p></p> Workflow solution Ping WorkflowExpected Result <p>This <code>Ping</code> workflow will ping the system0 loopback interface on leaf-1 from all nodes. <pre><code>apiVersion: oam.eda.nokia.com/v1alpha1\nkind: Ping\nmetadata:\nname: ping-ced7f273-7304-44ae-9f57-925773515224\nnamespace: eda\nspec:\ncount: 10\ntimeoutSeconds: 5\naddress: 11.0.0.3\nnodeSelectors:\n    - containerlab = managedSrl\nnetworkInstance: default\n</code></pre></p> <p>In the Workflow Results, you can inspect the ping details and statistics.</p> <p></p>"},{"location":"underlay/fabrics.html#sr-linux-cli","title":"SR Linux CLI","text":"<p>EDA offers great observability features, but sometimes it can still be useful to use the CLI to assess the network's health.</p>"},{"location":"underlay/fabrics.html#configuration-inspection","title":"Configuration inspection","text":"<p>Log into one of the nodes and inspect the running configuration using the <code>info &lt;YANG PATH&gt;</code> command.</p> CommandExpected Output <pre><code>admin@leaf1# info with-context network-instance default\n</code></pre> <pre><code>    network-instance default {\n        !!! EDA Source CRs: fabrics.eda.nokia.com/v1alpha1/Fabric/my-fabric\n        type default !!! EDA Source CRs: fabrics.eda.nokia.com/v1alpha1/Fabric/my-fabric\n        admin-state enable !!! EDA Source CRs: fabrics.eda.nokia.com/v1alpha1/Fabric/my-fabric\n        description \"fabric: my-fabric role: leaf\" !!! EDA Source CRs: fabrics.eda.nokia.com/v1alpha1/Fabric/my-fabric\n        router-id 11.0.0.3 !!! EDA Source CRs: fabrics.eda.nokia.com/v1alpha1/Fabric/my-fabric\n        ip-forwarding {\n            !!! EDA Source CRs: fabrics.eda.nokia.com/v1alpha1/Fabric/my-fabric\n            receive-ipv4-check false\n        }\n        interface ethernet-1/31.0 {\n            !!! EDA Source CRs: fabrics.eda.nokia.com/v1alpha1/Fabric/my-fabric\n    # clipped\n</code></pre> Transaction details <p>Alternatively, you can also inspect the changes in EDA, by looking at the transaction details. This view will show all resources that were created when running your intent. Next to this, the actual translation to node config is also shown here.</p>"},{"location":"underlay/fabrics.html#state-information","title":"State information","text":"<p>With SR Linux' CLI you can easily fetch state information from your node using the <code>info from state &lt;YANG PATH&gt;</code> command. For example:</p> CommandExpected Output <pre><code>admin@leaf1# info with-context from state network-instance default protocols bgp oper-state\n</code></pre> <pre><code>network-instance default {\n    protocols {\n        bgp {\n            oper-state up\n        }\n    }\n}\n</code></pre> EDA Query Language <p>Alternatively, you can also monitor the full network state in EDA using queries. The full YANG tree of state information is populated into the EDA state database as well. You can use EQL to query this database. The above example would equate to <code>.namespace.node.srl.network-instance fields [ oper-state ] where (name = \"default\")</code> in EQL.</p>"},{"location":"underlay/fabrics.html#show-commands","title":"Show commands","text":"<p>Instead of directly inspecting the raw state information, you can also use show commands in SR Linux. These present state information in a more human readable format.</p> CommandExpected Output <pre><code>admin@leaf1# show network-instance default protocols bgp neighbor\n</code></pre> <pre><code>-----------------------------------------------------------------------------------------------------------------------\nBGP neighbor summary for network-instance \"default\"\nFlags: S static, D dynamic, L discovered by LLDP, B BFD enabled, - disabled, * slow\n-----------------------------------------------------------------------------------------------------------------------\n-----------------------------------------------------------------------------------------------------------------------\n+-------------+-------------------+-------------+-----+-------+-----------+-----------+----------+-------------------+\n|  Net-Inst   |       Peer        |    Group    | Fla | Peer- |   State   |  Uptime   | AFI/SAFI |  [Rx/Active/Tx]   |\n|             |                   |             | gs  |  AS   |           |           |          |                   |\n+=============+===================+=============+=====+=======+===========+===========+==========+===================+\n| default     | 11.0.0.4          | bgpgroup-   | SB  | 65000 | establish | 3d:5h:47m | evpn     | [5/5/1]           |\n|             |                   | ibgp-       |     |       | ed        | :9s       |          |                   |\n|             |                   | rrclient-   |     |       |           |           |          |                   |\n|             |                   | my-fabric   |     |       |           |           |          |                   |\n| default     | 11.0.0.5          | bgpgroup-   | SB  | 65000 | establish | 3d:5h:47m | evpn     | [5/0/1]           |\n|             |                   | ibgp-       |     |       | ed        | :9s       |          |                   |\n|             |                   | rrclient-   |     |       |           |           |          |                   |\n|             |                   | my-fabric   |     |       |           |           |          |                   |\n| default     | fe80::1844:bff:fe | bgpgroup-   | DB  | 100   | establish | 3d:5h:47m | ipv4-    | [5/5/6]           |\n|             | ff:1%ethernet-    | ebgp-my-    |     |       | ed        | :15s      | unicast  | [0/0/0]           |\n|             | 1/31.0            | fabric      |     |       |           |           | ipv6-    |                   |\n|             |                   |             |     |       |           |           | unicast  |                   |\n| default     | fe80::1856:cff:fe | bgpgroup-   | DB  | 100   | establish | 3d:5h:47m | ipv4-    | [5/5/2]           |\n|             | ff:1%ethernet-    | ebgp-my-    |     |       | ed        | :14s      | unicast  | [0/0/0]           |\n|             | 1/32.0            | fabric      |     |       |           |           | ipv6-    |                   |\n|             |                   |             |     |       |           |           | unicast  |                   |\n+-------------+-------------------+-------------+-----+-------+-----------+-----------+----------+-------------------+\n-----------------------------------------------------------------------------------------------------------------------\nSummary:\n2 configured neighbors, 2 configured sessions are established, 0 disabled peers\n2 dynamic peers\n</code></pre> EDA Dashboards <p>As you know <code>show</code> commands display <code>state</code> information in a human readable manner. Similarly, in EDA, network-wide state information can be used to create and populate dashboards, as we saw in Fabric summary dashboard.</p>"},{"location":"underlay/fabrics.html#operational-commands","title":"Operational commands","text":"<p>SR Linux' CLI also has some operational command. For example, you can use <code>ping</code> to validate the route-table and check connectivity.</p> CommandExpected Output <pre><code>admin@leaf1# ping 11.0.0.2 network-instance default\n</code></pre> <pre><code>Using network instance default\nPING 11.0.0.2 (11.0.0.2) 56(84) bytes of data.\n64 bytes from 11.0.0.2: icmp_seq=1 ttl=63 time=3.29 ms\n64 bytes from 11.0.0.2: icmp_seq=2 ttl=63 time=3.40 ms\n64 bytes from 11.0.0.2: icmp_seq=3 ttl=63 time=3.05 ms\n64 bytes from 11.0.0.2: icmp_seq=4 ttl=63 time=3.52 ms\n^CCommand execution aborted : 'ping 11.0.0.2 network-instance default '\n</code></pre> EDA Workflows <p>The same can be done using EDA workflows as we saw in Using EDA Workflows.</p>"},{"location":"underlay/fabrics.html#third-party-tools","title":"Third party tools","text":"<p>EDA's database is populated with a lot of useful metrics. All of these metrics can be exported and consumed by third party tools. For example, you can set up a telemetry stack using EDA's Prometheus exporter, which will export selected metrics into a Prometheus time series database. These metrics can then be visualized in a Grafana dashboard.</p> EDA Telemetry stack <p>For this hackathon, a Grafana dashboard was created beforehand, that showcases a couple of useful metrics, such as fabric health, BGP peers, interface throughput, and so on.</p> <p>The dashboard is available at: <code>https://{your-ip}:9443/core/httpproxy/v1/grafana/dashboard</code></p> <p>You can inspect the Prometheus time series database at: <code>https://{your-ip}:9443/core/httpproxy/v1/prometheus/query</code></p> <p></p>"},{"location":"underlay/fabrics.html#summary","title":"Summary","text":"<p>In this exercise, you successfully created the underlay network in your Data Center Fabric, enabling connectivity between the different nodes.</p> <ul> <li>You created a Fabric resource which automatically triggered the creation of all components required to build your underlay connectivity.</li> <li>You validated the Fabric's deployment using Dashboards, EQL, Workflows, SR Linux CLI and a Grafana dashboard.</li> </ul> <p>This exercise demonstrated the automation power of EDA when deploying Day 0 networks. It showcased the observability in EDA, and the ability to perform operational tasks.</p>"}]}